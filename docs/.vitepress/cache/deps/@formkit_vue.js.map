{
  "version": 3,
  "sources": ["../../../../node_modules/@formkit/utils/src/index.ts", "../../../../node_modules/@formkit/core/src/dispatcher.ts", "../../../../node_modules/@formkit/core/src/node.ts", "../../../../node_modules/@formkit/core/src/events.ts", "../../../../node_modules/@formkit/core/src/errors.ts", "../../../../node_modules/@formkit/core/src/store.ts", "../../../../node_modules/@formkit/core/src/ledger.ts", "../../../../node_modules/@formkit/core/src/registry.ts", "../../../../node_modules/@formkit/core/src/config.ts", "../../../../node_modules/@formkit/core/src/submitForm.ts", "../../../../node_modules/@formkit/core/src/reset.ts", "../../../../node_modules/@formkit/core/src/schema.ts", "../../../../node_modules/@formkit/core/src/compiler.ts", "../../../../node_modules/@formkit/core/src/classes.ts", "../../../../node_modules/@formkit/core/src/setErrors.ts", "../../../../node_modules/@formkit/core/src/index.ts", "../../../../node_modules/@formkit/observer/src/index.ts", "../../../../node_modules/@formkit/rules/src/accepted.ts", "../../../../node_modules/@formkit/rules/src/date_after.ts", "../../../../node_modules/@formkit/rules/src/date_after_or_equal.ts", "../../../../node_modules/@formkit/rules/src/date_after_node.ts", "../../../../node_modules/@formkit/rules/src/alpha.ts", "../../../../node_modules/@formkit/rules/src/alpha_spaces.ts", "../../../../node_modules/@formkit/rules/src/alphanumeric.ts", "../../../../node_modules/@formkit/rules/src/date_before.ts", "../../../../node_modules/@formkit/rules/src/date_before_node.ts", "../../../../node_modules/@formkit/rules/src/date_before_or_equal.ts", "../../../../node_modules/@formkit/rules/src/between.ts", "../../../../node_modules/@formkit/rules/src/confirm.ts", "../../../../node_modules/@formkit/rules/src/contains_alpha.ts", "../../../../node_modules/@formkit/rules/src/contains_alpha_spaces.ts", "../../../../node_modules/@formkit/rules/src/contains_alphanumeric.ts", "../../../../node_modules/@formkit/rules/src/contains_lowercase.ts", "../../../../node_modules/@formkit/rules/src/contains_numeric.ts", "../../../../node_modules/@formkit/rules/src/contains_symbol.ts", "../../../../node_modules/@formkit/rules/src/contains_uppercase.ts", "../../../../node_modules/@formkit/rules/src/date_between.ts", "../../../../node_modules/@formkit/rules/src/date_format.ts", "../../../../node_modules/@formkit/rules/src/email.ts", "../../../../node_modules/@formkit/rules/src/ends_with.ts", "../../../../node_modules/@formkit/rules/src/is.ts", "../../../../node_modules/@formkit/rules/src/length.ts", "../../../../node_modules/@formkit/rules/src/lowercase.ts", "../../../../node_modules/@formkit/rules/src/matches.ts", "../../../../node_modules/@formkit/rules/src/max.ts", "../../../../node_modules/@formkit/rules/src/min.ts", "../../../../node_modules/@formkit/rules/src/not.ts", "../../../../node_modules/@formkit/rules/src/number.ts", "../../../../node_modules/@formkit/rules/src/require_one.ts", "../../../../node_modules/@formkit/rules/src/required.ts", "../../../../node_modules/@formkit/rules/src/starts_with.ts", "../../../../node_modules/@formkit/rules/src/symbol.ts", "../../../../node_modules/@formkit/rules/src/uppercase.ts", "../../../../node_modules/@formkit/rules/src/url.ts", "../../../../node_modules/@formkit/validation/src/validation.ts", "../../../../node_modules/@formkit/i18n/src/locales/ar.ts", "../../../../node_modules/@formkit/i18n/src/formatters.ts", "../../../../node_modules/@formkit/i18n/src/locales/az.ts", "../../../../node_modules/@formkit/i18n/src/locales/bg.ts", "../../../../node_modules/@formkit/i18n/src/locales/bs.ts", "../../../../node_modules/@formkit/i18n/src/locales/ca.ts", "../../../../node_modules/@formkit/i18n/src/locales/cs.ts", "../../../../node_modules/@formkit/i18n/src/locales/da.ts", "../../../../node_modules/@formkit/i18n/src/locales/de.ts", "../../../../node_modules/@formkit/i18n/src/locales/el.ts", "../../../../node_modules/@formkit/i18n/src/locales/en.ts", "../../../../node_modules/@formkit/i18n/src/locales/es.ts", "../../../../node_modules/@formkit/i18n/src/locales/fa.ts", "../../../../node_modules/@formkit/i18n/src/locales/fi.ts", "../../../../node_modules/@formkit/i18n/src/locales/fr.ts", "../../../../node_modules/@formkit/i18n/src/locales/fy.ts", "../../../../node_modules/@formkit/i18n/src/locales/he.ts", "../../../../node_modules/@formkit/i18n/src/locales/hr.ts", "../../../../node_modules/@formkit/i18n/src/locales/hu.ts", "../../../../node_modules/@formkit/i18n/src/locales/id.ts", "../../../../node_modules/@formkit/i18n/src/locales/is.ts", "../../../../node_modules/@formkit/i18n/src/locales/it.ts", "../../../../node_modules/@formkit/i18n/src/locales/ja.ts", "../../../../node_modules/@formkit/i18n/src/locales/kk.ts", "../../../../node_modules/@formkit/i18n/src/locales/ko.ts", "../../../../node_modules/@formkit/i18n/src/locales/lt.ts", "../../../../node_modules/@formkit/i18n/src/locales/lv.ts", "../../../../node_modules/@formkit/i18n/src/locales/mn.ts", "../../../../node_modules/@formkit/i18n/src/locales/nb.ts", "../../../../node_modules/@formkit/i18n/src/locales/nl.ts", "../../../../node_modules/@formkit/i18n/src/locales/pl.ts", "../../../../node_modules/@formkit/i18n/src/locales/pt.ts", "../../../../node_modules/@formkit/i18n/src/locales/ro.ts", "../../../../node_modules/@formkit/i18n/src/locales/ru.ts", "../../../../node_modules/@formkit/i18n/src/locales/sk.ts", "../../../../node_modules/@formkit/i18n/src/locales/sl.ts", "../../../../node_modules/@formkit/i18n/src/locales/sr.ts", "../../../../node_modules/@formkit/i18n/src/locales/sv.ts", "../../../../node_modules/@formkit/i18n/src/locales/tet.ts", "../../../../node_modules/@formkit/i18n/src/locales/tg.ts", "../../../../node_modules/@formkit/i18n/src/locales/th.ts", "../../../../node_modules/@formkit/i18n/src/locales/tr.ts", "../../../../node_modules/@formkit/i18n/src/locales/uk.ts", "../../../../node_modules/@formkit/i18n/src/locales/uz.ts", "../../../../node_modules/@formkit/i18n/src/locales/vi.ts", "../../../../node_modules/@formkit/i18n/src/locales/zh.ts", "../../../../node_modules/@formkit/i18n/src/locales/zh-TW.ts", "../../../../node_modules/@formkit/i18n/src/i18n.ts", "../../../../node_modules/@formkit/i18n/src/index.ts", "../../../../node_modules/@formkit/inputs/src/plugin.ts", "../../../../node_modules/@formkit/inputs/src/props.ts", "../../../../node_modules/@formkit/inputs/src/features/options.ts", "../../../../node_modules/@formkit/inputs/src/createSection.ts", "../../../../node_modules/@formkit/inputs/src/compose.ts", "../../../../node_modules/@formkit/inputs/src/sections/actions.ts", "../../../../node_modules/@formkit/inputs/src/sections/box.ts", "../../../../node_modules/@formkit/inputs/src/sections/boxHelp.ts", "../../../../node_modules/@formkit/inputs/src/sections/boxInner.ts", "../../../../node_modules/@formkit/inputs/src/sections/boxLabel.ts", "../../../../node_modules/@formkit/inputs/src/sections/boxOption.ts", "../../../../node_modules/@formkit/inputs/src/sections/boxOptions.ts", "../../../../node_modules/@formkit/inputs/src/sections/boxWrapper.ts", "../../../../node_modules/@formkit/inputs/src/sections/buttonInput.ts", "../../../../node_modules/@formkit/inputs/src/sections/buttonLabel.ts", "../../../../node_modules/@formkit/inputs/src/sections/decorator.ts", "../../../../node_modules/@formkit/inputs/src/sections/fieldset.ts", "../../../../node_modules/@formkit/inputs/src/sections/fileInput.ts", "../../../../node_modules/@formkit/inputs/src/sections/fileItem.ts", "../../../../node_modules/@formkit/inputs/src/sections/fileList.ts", "../../../../node_modules/@formkit/inputs/src/sections/fileName.ts", "../../../../node_modules/@formkit/inputs/src/sections/fileRemove.ts", "../../../../node_modules/@formkit/inputs/src/sections/formInput.ts", "../../../../node_modules/@formkit/inputs/src/sections/fragment.ts", "../../../../node_modules/@formkit/inputs/src/sections/help.ts", "../../../../node_modules/@formkit/inputs/src/sections/icon.ts", "../../../../node_modules/@formkit/inputs/src/sections/inner.ts", "../../../../node_modules/@formkit/inputs/src/sections/label.ts", "../../../../node_modules/@formkit/inputs/src/sections/legend.ts", "../../../../node_modules/@formkit/inputs/src/sections/message.ts", "../../../../node_modules/@formkit/inputs/src/sections/messages.ts", "../../../../node_modules/@formkit/inputs/src/sections/noFiles.ts", "../../../../node_modules/@formkit/inputs/src/sections/optGroup.ts", "../../../../node_modules/@formkit/inputs/src/sections/option.ts", "../../../../node_modules/@formkit/inputs/src/sections/optionSlot.ts", "../../../../node_modules/@formkit/inputs/src/sections/outer.ts", "../../../../node_modules/@formkit/inputs/src/sections/prefix.ts", "../../../../node_modules/@formkit/inputs/src/sections/selectInput.ts", "../../../../node_modules/@formkit/inputs/src/sections/submitInput.ts", "../../../../node_modules/@formkit/inputs/src/sections/suffix.ts", "../../../../node_modules/@formkit/inputs/src/sections/textInput.ts", "../../../../node_modules/@formkit/inputs/src/sections/textareaInput.ts", "../../../../node_modules/@formkit/inputs/src/sections/wrapper.ts", "../../../../node_modules/@formkit/inputs/src/features/renamesRadios.ts", "../../../../node_modules/@formkit/inputs/src/features/checkboxes.ts", "../../../../node_modules/@formkit/inputs/src/features/normalizeBoxes.ts", "../../../../node_modules/@formkit/inputs/src/features/icon.ts", "../../../../node_modules/@formkit/inputs/src/features/disables.ts", "../../../../node_modules/@formkit/inputs/src/features/localize.ts", "../../../../node_modules/@formkit/inputs/src/features/files.ts", "../../../../node_modules/@formkit/inputs/src/features/forms.ts", "../../../../node_modules/@formkit/inputs/src/features/ignores.ts", "../../../../node_modules/@formkit/inputs/src/features/initialValue.ts", "../../../../node_modules/@formkit/inputs/src/features/casts.ts", "../../../../node_modules/@formkit/inputs/src/features/radios.ts", "../../../../node_modules/@formkit/inputs/src/features/selects.ts", "../../../../node_modules/@formkit/inputs/src/inputs/button.ts", "../../../../node_modules/@formkit/inputs/src/inputs/checkbox.ts", "../../../../node_modules/@formkit/inputs/src/inputs/file.ts", "../../../../node_modules/@formkit/inputs/src/inputs/form.ts", "../../../../node_modules/@formkit/inputs/src/inputs/group.ts", "../../../../node_modules/@formkit/inputs/src/inputs/hidden.ts", "../../../../node_modules/@formkit/inputs/src/inputs/list.ts", "../../../../node_modules/@formkit/inputs/src/inputs/meta.ts", "../../../../node_modules/@formkit/inputs/src/inputs/radio.ts", "../../../../node_modules/@formkit/inputs/src/inputs/select.ts", "../../../../node_modules/@formkit/inputs/src/inputs/textarea.ts", "../../../../node_modules/@formkit/inputs/src/inputs/text.ts", "../../../../node_modules/@formkit/inputs/src/index.ts", "../../../../node_modules/@formkit/themes/src/index.ts", "../../../../node_modules/@formkit/dev/src/index.ts", "../../../../node_modules/@formkit/vue/src/bindings.ts", "../../../../node_modules/@formkit/vue/src/defaultConfig.ts", "../../../../node_modules/@formkit/vue/src/FormKit.ts", "../../../../node_modules/@formkit/vue/src/FormKitSchema.ts", "../../../../node_modules/@formkit/vue/src/composables/onSSRComplete.ts", "../../../../node_modules/@formkit/vue/src/FormKitRoot.ts", "../../../../node_modules/@formkit/vue/src/composables/useInput.ts", "../../../../node_modules/@formkit/vue/src/plugin.ts", "../../../../node_modules/@formkit/vue/src/composables/createInput.ts", "../../../../node_modules/@formkit/vue/src/composables/defineFormKitConfig.ts", "../../../../node_modules/@formkit/vue/src/FormKitKitchenSink.ts", "../../../../node_modules/@formkit/vue/src/FormKitMessages.ts", "../../../../node_modules/@formkit/vue/src/FormKitProvider.ts", "../../../../node_modules/@formkit/vue/src/composables/useContext.ts", "../../../../node_modules/@formkit/vue/src/FormKitSummary.ts", "../../../../node_modules/@formkit/vue/src/index.ts", "../../../../node_modules/@formkit/vue/src/FormKitIcon.ts", "../../../../node_modules/@formkit/vue/src/utilities/resetCount.ts"],
  "sourcesContent": ["/**\n * Commonly shared utility functions between official FormKit packages.\n *\n * You can add this package by using `npm install @formkit/utils` or `yarn add @formkit/utils`.\n *\n * @packageDocumentation\n */\n\nconst isBrowser = typeof window !== 'undefined'\n\n/**\n * Explicit keys that should always be cloned.\n */\nconst explicitKeys = [\n  '__key',\n  '__init',\n  '__shim',\n  '__original',\n  '__index',\n  '__prevKey',\n]\n\n/**\n * Generates a random string.\n *\n * @example\n *\n * ```javascript\n * import { token } from '@formkit/utils'\n *\n * const tk = token()\n * // 'jkbyqnphqm'\n * ```\n *\n * @returns string\n *\n * @public\n */\nexport function token(): string {\n  return Math.random().toString(36).substring(2, 15)\n}\n\n/**\n * Creates a new set of the specified type and uses the values from an Array or\n * an existing Set.\n *\n * @example\n *\n * ```javascript\n * import { setify } from '@formkit/utils'\n *\n * const tk = setify(['a', 'b'])\n * // Set(2) {'a', 'b'}\n * ```\n *\n * @param items - An array or a Set.\n *\n * @returns `Set<T>`\n *\n * @public\n */\nexport function setify<T>(items: Set<T> | T[] | null | undefined): Set<T> {\n  return items instanceof Set ? items : new Set<T>(items)\n}\n\n/**\n * Given 2 arrays, return them as a combined array with no duplicates.\n *\n * @param arr1 - First array.\n * @param arr2 - Second array.\n *\n * @returns `any[]`\n *\n * @public\n */\nexport function dedupe<T extends any[] | Set<any>, X extends any[] | Set<any>>(\n  arr1: T,\n  arr2?: X\n): any[] {\n  const original = arr1 instanceof Set ? arr1 : new Set(arr1)\n  if (arr2) arr2.forEach((item: any) => original.add(item))\n  return [...original]\n}\n\n/**\n * Checks if the given property exists on the given object.\n *\n * @param obj - An object to check.\n * @param property - The property to check.\n *\n * @returns `boolean`\n *\n * @public\n */\nexport function has(\n  obj: {\n    [index: string]: any\n    [index: number]: any\n  },\n  property: string | symbol | number\n): boolean {\n  return Object.prototype.hasOwnProperty.call(obj, property)\n}\n\n/**\n * Compare two values for equality, optionally at depth.\n *\n * @param valA - First value.\n * @param valB - Second value.\n * @param deep - If it will compare deeply if it's an object.\n * @param explicit - An array of keys to explicity check.\n *\n * @returns `boolean`\n *\n * @public\n */\nexport function eq(\n  valA: any, // eslint-disable-line\n  valB: any, // eslint-disable-line\n  deep = true,\n  explicit: string[] = ['__key']\n): boolean {\n  if (valA === valB) return true\n  if (typeof valB === 'object' && typeof valA === 'object') {\n    if (valA instanceof Map) return false\n    if (valA instanceof Set) return false\n    if (valA instanceof Date && valB instanceof Date)\n      return valA.getTime() === valB.getTime()\n    if (valA instanceof RegExp && valB instanceof RegExp)\n      return eqRegExp(valA, valB)\n    if (valA === null || valB === null) return false\n    if (Object.keys(valA).length !== Object.keys(valB).length) return false\n    for (const k of explicit) {\n      if ((k in valA || k in valB) && valA[k] !== valB[k]) return false\n    }\n    for (const key in valA) {\n      if (!(key in valB)) return false\n      if (valA[key] !== valB[key] && !deep) return false\n      if (deep && !eq(valA[key], valB[key], deep, explicit)) return false\n    }\n    return true\n  }\n  return false\n}\n\n/**\n * A regular expression to test for a valid date string.\n * @param x - A RegExp to compare.\n * @param y - A RegExp to compare.\n * @public\n */\nexport function eqRegExp(x: RegExp, y: RegExp): boolean {\n  return (\n    x.source === y.source &&\n    x.flags.split('').sort().join('') === y.flags.split('').sort().join('')\n  )\n}\n\n/**\n * Determines if a value is empty or not.\n *\n * @param value - The value to check if it's empty.\n *\n * @returns `boolean`\n *\n * @public\n */\nexport function empty(\n  value: any // eslint-disable-line\n): boolean {\n  const type = typeof value\n  if (type === 'number') return false\n  if (value === undefined) return true\n  if (type === 'string') {\n    return value === ''\n  }\n  if (type === 'object') {\n    if (value === null) return true\n    for (const _i in value) return false\n    if (value instanceof RegExp) return false\n    if (value instanceof Date) return false\n    return true\n  }\n  return false\n}\n\n/**\n * Escape a string for use in regular expressions.\n *\n * @param string - String to be escaped.\n *\n * @returns `string`\n *\n * @public\n */\nexport function escapeExp(string: string): string {\n  // $& means the whole matched string\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n}\n\n/**\n * The date token strings that can be used for date formatting.\n *\n * @public\n */\nexport type FormKitDateTokens = 'MM' | 'M' | 'DD' | 'D' | 'YYYY' | 'YY'\n\n/**\n * Given a string date format, return a regex to match against.\n *\n * @param format - String to be transformed to RegExp.\n *\n * @example\n *\n * ```javascript\n * regexForFormat('MM') // returns '(0[1-9]|1[012])'\n * ```\n *\n * @returns `RegExp`\n *\n * @public\n */\nexport function regexForFormat(format: string): RegExp {\n  const escaped = `^${escapeExp(format)}$`\n  const formats: Record<FormKitDateTokens, string> = {\n    MM: '(0[1-9]|1[012])',\n    M: '([1-9]|1[012])',\n    DD: '([012][0-9]|3[01])',\n    D: '([012]?[0-9]|3[01])',\n    YYYY: '\\\\d{4}',\n    YY: '\\\\d{2}',\n  }\n  const tokens = Object.keys(formats) as FormKitDateTokens[]\n  return new RegExp(\n    tokens.reduce((regex, format) => {\n      return regex.replace(format, formats[format])\n    }, escaped)\n  )\n}\n\n/**\n * Given a FormKit input type, returns the correct lowerCased() type.\n *\n * @param type - String to return to check for correct type\n *\n * @returns `'list' | 'group' | 'input'`\n *\n * @public\n */\nexport function nodeType(type: string): 'list' | 'group' | 'input' {\n  const t = type.toLowerCase()\n  if (t === 'list') return 'list'\n  if (t === 'group') return 'group'\n  return 'input'\n}\n\n/**\n * Determines if an object is an object.\n *\n * @param o - The value to be checked.\n *\n * @returns `boolean`\n *\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function isRecord(o: unknown): o is Record<PropertyKey, unknown> {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\n/**\n * Checks if an object is a simple array or record.\n *\n * @param o - Value to be checked.\n *\n * @returns `boolean`\n *\n * @public\n */\nexport function isObject(\n  o: unknown\n): o is Record<PropertyKey, unknown> | unknown[] {\n  return isRecord(o) || Array.isArray(o)\n}\n\n/**\n * Attempts to determine if an object is a POJO (Plain Old JavaScript Object).\n * Mostly lifted from is-plain-object: https://github.com/jonschlinkert/is-plain-object\n * Copyright (c) 2014-2017, Jon Schlinkert.\n *\n * @param o - The value to be checked.\n *\n * @returns `boolean`\n *\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function isPojo(o: any): o is Record<string, any> {\n  if (isRecord(o) === false) return false\n  if (o.__FKNode__ || o.__POJO__ === false) return false\n  const ctor = o.constructor\n  if (ctor === undefined) return true\n  const prot = ctor.prototype\n  if (isRecord(prot) === false) return false\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false\n  }\n  return true\n}\n\n/**\n * Recursively merge data from additional into original returning a new object.\n *\n * @param original - The original array.\n * @param additional - The array to merge.\n * @param extendArrays - If it will extend/concatenate array values instead of\n * replacing them.\n * @param ignoreUndefined - If it will preserve values from the original object\n * even if the additional object has those values set to undefined.\n *\n * @returns `Record<string, any> | string | null`\n *\n * @public\n *\n */\nexport const extend = /*#__NO_SIDE_EFFECTS__*/ (\n  original: Record<string, any>,\n  additional: Record<string, any> | string | null,\n  extendArrays = false,\n  ignoreUndefined = false\n): Record<string, any> | string | null => {\n  if (additional === null) return null\n  const merged: Record<string, any> = {}\n  if (typeof additional === 'string') return additional\n  for (const key in original) {\n    if (\n      has(additional, key) &&\n      (additional[key] !== undefined || !ignoreUndefined)\n    ) {\n      if (\n        extendArrays &&\n        Array.isArray(original[key]) &&\n        Array.isArray(additional[key])\n      ) {\n        merged[key] = original[key].concat(additional[key])\n        continue\n      }\n      if (additional[key] === undefined) {\n        continue\n      }\n      if (isPojo(original[key]) && isPojo(additional[key])) {\n        merged[key] = extend(\n          original[key],\n          additional[key],\n          extendArrays,\n          ignoreUndefined\n        )\n      } else {\n        merged[key] = additional[key]\n      }\n    } else {\n      merged[key] = original[key]\n    }\n  }\n  for (const key in additional) {\n    if (!has(merged, key) && additional[key] !== undefined) {\n      merged[key] = additional[key]\n    }\n  }\n  return merged\n}\n\n/**\n * Determine if the given string is fully quoted.\n *\n * @example\n *\n * ```javascript\n * hello - false\n * \"hello\" - true\n * 'world' - true\n * \"hello\"==\"world\" - false\n * \"hello'this'\" - false\n * \"hello\"'there' - false\n * \"hello\"\"there\" - false\n * 'hello === world' - true\n * ```\n *\n * @param str - The string to check.\n *\n * @returns `boolean`\n *\n * @public\n */\nexport function isQuotedString(str: string): boolean {\n  // quickly return false if the value is note quoted\n  if (str[0] !== '\"' && str[0] !== \"'\") return false\n  if (str[0] !== str[str.length - 1]) return false\n  const quoteType = str[0]\n  for (let p = 1; p < str.length; p++) {\n    if (\n      str[p] === quoteType &&\n      (p === 1 || str[p - 1] !== '\\\\') &&\n      p !== str.length - 1\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Remove extra escape characters.\n *\n * @param str - String to remove extra escape characters from.\n *\n * @returns `string`\n *\n * @public\n */\nexport function rmEscapes(str: string): string {\n  if (!str.length) return ''\n  let clean = ''\n  let lastChar = ''\n  for (let p = 0; p < str.length; p++) {\n    const char = str.charAt(p)\n    if (char !== '\\\\' || lastChar === '\\\\') {\n      clean += char\n    }\n    lastChar = char\n  }\n  return clean\n}\n\n/**\n * Performs a recursive `Object.assign`-like operation.\n *\n * @param a - An object to be assigned.\n * @param b - An object to get values from.\n *\n * @returns `A & B`\n *\n * @public\n */\nexport function assignDeep<\n  A extends Record<PropertyKey, any>,\n  B extends Record<PropertyKey, any>\n>(a: A, b: B): A & B {\n  for (const key in a) {\n    if (\n      has(b, key) &&\n      (a[key] as any) !== b[key] &&\n      !(isPojo(a[key]) && isPojo(b[key]))\n    ) {\n      a[key] = b[key]\n    } else if (isPojo(a[key]) && isPojo(b[key])) {\n      assignDeep(a[key], b[key])\n    }\n  }\n  for (const key in b) {\n    if (!has(a, key)) {\n      a[key] = b[key]\n    }\n  }\n  return a\n}\n\n/**\n * Filters out values from an object that should not be considered \"props\" of\n * a core node, like \"value\" and \"name\".\n *\n * @param sets - The arrays to get values filtered out of.\n *\n * @returns `Record<string, any>`\n *\n * @public\n */\nexport function nodeProps(\n  ...sets: Array<Record<string, any>>\n): Record<string, any> {\n  return sets.reduce((valid, props) => {\n    const { value, name, modelValue, config, plugins, ...validProps } = props // eslint-disable-line\n    return Object.assign(valid, validProps)\n  }, {})\n}\n\n/**\n * Parse a string for comma-separated arguments.\n *\n * @param str - String to parse arguments from.\n *\n * @returns `string[]`\n *\n * @public\n */\nexport function parseArgs(str: string): string[] {\n  const args: string[] = []\n  let arg = ''\n  let depth = 0\n  let quote = ''\n  let lastChar = ''\n  for (let p = 0; p < str.length; p++) {\n    const char = str.charAt(p)\n    if (char === quote && lastChar !== '\\\\') {\n      quote = ''\n    } else if ((char === \"'\" || char === '\"') && !quote && lastChar !== '\\\\') {\n      quote = char\n    } else if (char === '(' && !quote) {\n      depth++\n    } else if (char === ')' && !quote) {\n      depth--\n    }\n    if (char === ',' && !quote && depth === 0) {\n      args.push(arg)\n      arg = ''\n    } else if (char !== ' ' || quote) {\n      arg += char\n    }\n    lastChar = char\n  }\n  if (arg) {\n    args.push(arg)\n  }\n  return args\n}\n\n/**\n * Return a new (shallow) object with any desired props removed.\n *\n * @param obj - The starting object.\n * @param toRemove - The array of properties to remove. Accepts strings or\n * regular expressions.\n *\n * @returns `Record<string, any>`\n *\n * @public\n */\nexport function except(\n  obj: Record<string, any>,\n  toRemove: Array<string | RegExp>\n): Record<string, any> {\n  const clean: Record<string, any> = {}\n  const exps = toRemove.filter((n) => n instanceof RegExp) as RegExp[]\n  const keysToRemove = new Set(toRemove)\n  for (const key in obj) {\n    if (!keysToRemove.has(key) && !exps.some((exp) => exp.test(key))) {\n      clean[key] = obj[key]\n    }\n  }\n  return clean\n}\n\n/**\n * Extracts a set of keys from a given object. Importantly, this will extract\n * values even if they are not set on the original object — they will just have\n * an undefined value.\n *\n * @param obj - The object to get values from.\n * @param include - The array of items to get.\n *\n * @returns `Record<string, any>`\n *\n * @public\n */\nexport function only(\n  obj: Record<string, any>,\n  include: Array<string | RegExp>\n): Record<string, any> {\n  const clean: Record<string, any> = {}\n  const exps = include.filter((n) => n instanceof RegExp) as RegExp[]\n  include.forEach((key) => {\n    if (!(key instanceof RegExp)) {\n      clean[key] = obj[key]\n    }\n  })\n  Object.keys(obj).forEach((key) => {\n    if (exps.some((exp) => exp.test(key))) {\n      clean[key] = obj[key]\n    }\n  })\n  return clean\n}\n\n/**\n * This converts kebab-case to camelCase. It ONLY converts from kebab to camel.\n *\n * @param str - String to be camel cased.\n *\n * @returns `string`\n *\n * @public\n */\nexport function camel(str: string): string {\n  return str.replace(/-([a-z0-9])/gi, (_s: string, g: string) =>\n    g.toUpperCase()\n  )\n}\n\n/**\n * This converts camel-case to kebab case. It ONLY converts from camel to kebab.\n *\n * @param str - String to be kebabed.\n *\n * @returns `string`\n *\n * @public\n */\nexport function kebab(str: string): string {\n  return str\n    .replace(\n      /([a-z0-9])([A-Z])/g,\n      (_s: string, trail: string, cap: string) =>\n        trail + '-' + cap.toLowerCase()\n    )\n    .replace(' ', '-')\n    .toLowerCase()\n}\n\n/**\n * Shallowly clones the given object.\n *\n * @param obj - Object to be shallowly cloned.\n * @param explicit - The array of keys to be explicity cloned.\n *\n * @returns `T`\n *\n * @public\n */\nexport function shallowClone<T>(obj: T, explicit: string[] = explicitKeys): T {\n  if (obj !== null && typeof obj === 'object') {\n    let returnObject: any[] | Record<string, any> | undefined\n    if (Array.isArray(obj)) returnObject = [...obj]\n    else if (isPojo(obj)) returnObject = { ...obj }\n    if (returnObject) {\n      applyExplicit(obj, returnObject, explicit)\n      return returnObject as T\n    }\n  }\n  return obj\n}\n\n/**\n * Perform a recursive clone on a given object. Only intended to be used\n * for simple objects like arrays and POJOs.\n *\n * @param obj - Object to be cloned.\n * @param explicit - Array of items to be explicity cloned.\n *\n * @returns `T`\n *\n * @public\n */\nexport function clone<T extends Record<string, unknown> | unknown[] | null>(\n  obj: T,\n  explicit: string[] = explicitKeys\n): T {\n  if (\n    obj === null ||\n    obj instanceof RegExp ||\n    obj instanceof Date ||\n    obj instanceof Map ||\n    obj instanceof Set ||\n    (typeof File === 'function' && obj instanceof File)\n  )\n    return obj\n  let returnObject\n  if (Array.isArray(obj)) {\n    returnObject = obj.map((value) => {\n      if (typeof value === 'object') return clone(value as unknown[], explicit)\n      return value\n    }) as T\n  } else {\n    returnObject = Object.keys(obj).reduce((newObj, key) => {\n      newObj[key] =\n        typeof obj[key] === 'object'\n          ? clone(obj[key] as unknown[], explicit)\n          : obj[key]\n      return newObj\n    }, {} as Record<string, unknown>) as T\n  }\n  for (const key of explicit) {\n    if (key in obj) {\n      Object.defineProperty(returnObject, key, {\n        enumerable: false,\n        value: (obj as any)[key],\n      })\n    }\n  }\n  return returnObject\n}\n\n/**\n * Clones anything. If the item is scalar, no worries, it passes it back. If it\n * is an object, it performs a (fast/loose) clone operation.\n *\n * @param obj - The value to be cloned.\n *\n * @returns `T`\n *\n * @public\n */\nexport function cloneAny<T>(obj: T): T {\n  return typeof obj === 'object'\n    ? (clone(obj as Record<string, unknown>) as T)\n    : obj\n}\n\n/**\n * Get a specific value via dot notation.\n *\n * @param obj - An object to fetch data from.\n * @param addr - An \"address\" in dot notation.\n *\n * @returns `unknown`\n *\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function getAt(obj: any, addr: string): unknown {\n  if (!obj || typeof obj !== 'object') return null\n  const segments = addr.split('.')\n  let o = obj\n  for (const i in segments) {\n    const segment = segments[i]\n    if (has(o, segment)) {\n      o = o[segment]\n    }\n    if (+i === segments.length - 1) return o\n    if (!o || typeof o !== 'object') return null\n  }\n  return null\n}\n\n/**\n * Determines if the value of a prop that is either present (true) or not\n * present (undefined). For example, the prop disabled should disable\n * by just existing, but what if it is set to the string \"false\" — then it\n * should not be disabled.\n *\n * @param value - Value to check for undefined.\n *\n * @returns `true | undefined`\n *\n * @public\n */\nexport function undefine(value: unknown): true | undefined {\n  return value !== undefined && value !== 'false' && value !== false\n    ? true\n    : undefined\n}\n\n/**\n * Defines an object as an initial value.\n *\n * @param obj - Object to be added an initial value.\n *\n * @returns `T & { __init?: true }`\n *\n * @public\n */\n/* eslint-disable-next-line @typescript-eslint/ban-types */\nexport function init<T extends object>(obj: T): T & { __init?: true } {\n  return !Object.isFrozen(obj)\n    ? (Object.defineProperty(obj, '__init', {\n        enumerable: false,\n        value: true,\n      }) as T & { __init: true })\n    : obj\n}\n\n/**\n * Turn any string into a URL/DOM-safe string.\n *\n * @param str - String to be slugified to a URL-safe string.\n *\n * @returns `string`\n *\n * @public\n */\nexport function slugify(str: string): string {\n  return str\n    .normalize('NFD')\n    .replace(/[\\u0300-\\u036f]/g, '')\n    .toLowerCase()\n    .replace(/[^a-z0-9]/g, ' ')\n    .trim()\n    .replace(/\\s+/g, '-')\n}\n\n/**\n * Spreads an object or an array, otherwise returns the same value.\n *\n * @param obj - The object to be spread.\n * @param explicit - The array of items to be explicity spread.\n *\n * @returns `T`\n *\n * @public\n */\nexport function spread<T>(obj: T, explicit: string[] = explicitKeys): T {\n  if (obj && typeof obj === 'object') {\n    if (obj instanceof RegExp) return obj\n    if (obj instanceof Date) return obj\n    let spread: T\n    if (Array.isArray(obj)) {\n      spread = [...obj] as unknown as T\n    } else {\n      spread = { ...(obj as Record<PropertyKey, any>) } as T\n    }\n\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    return applyExplicit(\n      obj as Record<PropertyKey, any> | any[],\n      spread as Record<PropertyKey, any>,\n      explicit\n    ) as unknown as T\n  }\n  return obj\n}\n\n/**\n * Apply non enumerable properties to an object.\n *\n * @param original - Original object\n * @param obj - Objecto to aplly the values\n * @param explicit - Array of items to be explicity added.\n *\n * @returns `T`\n *\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction applyExplicit<T extends object | any[]>(\n  original: T,\n  obj: T,\n  explicit: string[]\n): T {\n  for (const key of explicit) {\n    if (key in original) {\n      Object.defineProperty(obj, key, {\n        enumerable: false,\n        value: original[key as keyof T],\n      })\n    }\n  }\n  return obj\n}\n\n/**\n * Uses a global mutation observer to wait for a given element to appear in the\n * DOM.\n * @param childId - The id of the child node.\n * @param callback - The callback to call when the child node is found.\n *\n * @public\n */\nexport function whenAvailable(\n  childId: string,\n  callback: (el: Element) => void,\n  root?: Document | ShadowRoot\n): void {\n  if (!isBrowser) return\n  if (!root) root = document\n  const el = root.getElementById(childId)\n  if (el) return callback(el)\n  const observer = new MutationObserver(() => {\n    const el = root?.getElementById(childId)\n    if (el) {\n      observer?.disconnect()\n      callback(el)\n    }\n  })\n  observer.observe(root, { childList: true, subtree: true })\n}\n\n/**\n * Given a function only 1 call will be made per call stack. All others will\n * be discarded.\n * @param fn - The function to be called once per tick.\n * @returns\n * @public\n */\nexport function oncePerTick<T extends CallableFunction>(fn: T): T {\n  let called = false\n  return ((...args: any[]) => {\n    if (called) return\n    called = true\n    queueMicrotask(() => (called = false))\n    return fn(...args)\n  }) as unknown as T\n}\n\n/**\n * Converts any value to a boolean value — but assumes that the default is true.\n * This is used on naked attributes like `disabled` or `required`.\n * @param value - The value to be converted to a boolean.\n * @public\n */\nexport function boolGetter(value: unknown): true | undefined {\n  if (value === 'false' || value === false) return undefined\n  return true\n}\n", "/**\n * All FormKitMiddleware conform to the pattern of accepting a payload and a\n * `next()` function. They can either pass the payload to the next middleware\n * explicitly (as an argument of next), or implicitly (no argument for next).\n *\n * @public\n */\nexport type FormKitMiddleware<T = unknown> = (\n  payload: T,\n  next: (payload: T) => T\n) => T\n\n/**\n * The FormKitDispatcher interface is responsible creating/running \"hooks\".\n *\n * @public\n */\nexport interface FormKitDispatcher<T> {\n  (dispatchable: FormKitMiddleware<T>): number\n  unshift: (dispatchable: FormKitMiddleware<T>) => number\n  remove: (dispatchable: FormKitMiddleware<T>) => void\n  dispatch: (payload: T) => T\n}\n/**\n * Creates a new dispatcher that allows the addition/removal of middleware\n * functions, and the ability to dispatch a payload to all middleware.\n *\n * @returns FormKitDispatcher\n *\n * @internal\n */\nexport default function createDispatcher<T>(): FormKitDispatcher<T> {\n  const middleware: FormKitMiddleware<T>[] = []\n  let currentIndex = 0\n  const use = (dispatchable: FormKitMiddleware<T>) =>\n    middleware.push(dispatchable)\n  const dispatch = (payload: T): T => {\n    const current = middleware[currentIndex]\n    if (typeof current === 'function') {\n      return current(payload, (explicitPayload: T) => {\n        currentIndex++\n        return dispatch(explicitPayload)\n      })\n    }\n    currentIndex = 0\n    return payload\n  }\n  use.dispatch = dispatch\n  use.unshift = (dispatchable: FormKitMiddleware<T>) =>\n    middleware.unshift(dispatchable)\n  use.remove = (dispatchable: FormKitMiddleware<T>) => {\n    const index = middleware.indexOf(dispatchable)\n    if (index > -1) middleware.splice(index, 1)\n  }\n  return use\n}\n", "import createDispatcher, { FormKitDispatcher } from './dispatcher'\nimport {\n  dedupe,\n  eq,\n  has,\n  camel,\n  kebab,\n  undefine,\n  init,\n  cloneAny,\n  clone,\n  isObject,\n  boolGetter,\n  extend as merge,\n  isRecord,\n} from '@formkit/utils'\nimport {\n  createEmitter,\n  FormKitEvent,\n  FormKitEventEmitter,\n  emit,\n  bubble,\n  on,\n  off,\n  FormKitEventListener,\n} from './events'\nimport { error } from './errors'\nimport {\n  createStore,\n  FormKitMessageProps,\n  FormKitMessage,\n  FormKitStore,\n} from './store'\nimport { createLedger, FormKitLedger } from './ledger'\nimport { deregister, register } from './registry'\nimport {\n  FormKitExtendableSchemaRoot,\n  FormKitSchemaNode,\n  FormKitSchemaCondition,\n} from './schema'\nimport { FormKitClasses } from './classes'\nimport { FormKitRootConfig, configChange } from './config'\nimport { submitForm } from './submitForm'\nimport { createMessages, ErrorMessages } from './store'\nimport { reset } from './reset'\n\n/**\n * Definition of a library item — when registering a new library item, these\n * are the required and available properties.\n *\n * @public\n */\nexport type FormKitTypeDefinition<V = unknown> = {\n  /**\n   * The FormKit core node type. Can only be input | list | group.\n   */\n  type: FormKitNodeType\n  /**\n   * Groups the input into a given family of inputs, generally for styling\n   * purposes only. For example the \"text\" family would apply to all text-like\n   * inputs.\n   */\n  family?: string\n  /**\n   * An optional name for the input’s type (e.g. \"select\" for a select input).\n   * If used, this value takes precedence over the \"type\" prop string.\n   */\n  forceTypeProp?: string\n  /**\n   * Custom props that should be added to the input.\n   */\n  props?: FormKitPseudoProps\n  /**\n   * The schema used to create the input. Either this or the component is\n   * required.\n   */\n  schema?:\n    | FormKitExtendableSchemaRoot\n    | FormKitSchemaNode[]\n    | FormKitSchemaCondition\n  /**\n   * A component to use to render the input. Either this or the schema is\n   * required.\n   */\n  component?: unknown\n  /**\n   * A library of components to provide to the internal input schema.\n   */\n  library?: Record<string, unknown>\n  /**\n   * An array of additional feature functions to load when booting the input.\n   */\n  features?: Array<(node: FormKitNode<V>) => void>\n  /**\n   * An optional string to use as a comparison key for memoizing the schema.\n   */\n  schemaMemoKey?: string\n}\n\n/**\n * A library of inputs, keyed by the name of the type.\n *\n * @public\n */\nexport interface FormKitLibrary {\n  [index: string]: FormKitTypeDefinition\n}\n\n/**\n * The base interface definition for a FormKitPlugin. It's just a function that\n * accepts a node argument.\n *\n * @public\n */\nexport interface FormKitPlugin {\n  (node: FormKitNode): false | any | void\n  library?: (node: FormKitNode) => void\n}\n\n/**\n * Text fragments are small pieces of text used for things like interface\n * validation messages, or errors that may be exposed for modification or\n * even translation.\n *\n * @public\n */\nexport type FormKitTextFragment = Partial<FormKitMessageProps> & {\n  key: string\n  value: string\n  type: string\n}\n\n/**\n * The available hooks for middleware.\n *\n * @public\n */\nexport interface FormKitHooks {\n  classes: FormKitDispatcher<{\n    property: string\n    classes: Record<string, boolean>\n  }>\n  commit: FormKitDispatcher<any>\n  error: FormKitDispatcher<string>\n  setErrors: FormKitDispatcher<{\n    localErrors: ErrorMessages\n    childErrors?: ErrorMessages\n  }>\n  init: FormKitDispatcher<FormKitNode>\n  input: FormKitDispatcher<any>\n  submit: FormKitDispatcher<Record<string, any>>\n  message: FormKitDispatcher<FormKitMessage>\n  prop: FormKitDispatcher<{\n    prop: string | symbol\n    value: any\n  }>\n  text: FormKitDispatcher<FormKitTextFragment>\n  schema: FormKitDispatcher<FormKitSchemaNode[] | FormKitSchemaCondition>\n}\n\n/**\n * The definition of a FormKitTrap. These are somewhat like methods on each\n * FormKitNode. They are always symmetrical (get/set) — although it's acceptable\n * for either to throw an Exception.\n *\n * @public\n */\nexport interface FormKitTrap {\n  get: TrapGetter\n  set: TrapSetter\n}\n\n/**\n * Describes the path to a particular node from the top of the tree.\n *\n * @public\n */\nexport type FormKitAddress = Array<string | number>\n\n/**\n * These are the types of nodes that can be created. These are different from\n * the type of inputs available and rather describe their purpose in the tree.\n *\n * @public\n */\nexport type FormKitNodeType = 'input' | 'list' | 'group'\n\n/**\n * FormKit inputs of type 'group' must have keyed values by default.\n *\n * @public\n */\nexport interface FormKitGroupValue {\n  [index: string]: unknown\n  __init?: boolean\n}\n\n/**\n * FormKit inputs of type 'list' must have array values by default.\n *\n * @public\n */\nexport type FormKitListContextValue<T = any> = Array<T>\n\n/**\n * Arbitrary data that has properties. Could be a POJO, could be an array.\n *\n * @public\n */\nexport interface KeyedValue {\n  [index: number]: any\n  [index: string]: any\n}\n\n/**\n * Define the most basic shape of a context object for type guards trying to\n * reason about a context's value.\n *\n * @public\n */\nexport interface FormKitContextShape {\n  type: FormKitNodeType\n  value: unknown\n  _value: unknown\n}\n\n/**\n * The simplest definition for a context of type \"list\".\n *\n * @public\n */\nexport interface FormKitListContext {\n  type: 'list'\n  value: FormKitListContextValue\n  _value: FormKitListContextValue\n}\n\n/**\n * Signature for any of the node's getter traps. Keep in mind that because these\n * are traps and not class methods, their response types are declared explicitly\n * in the FormKitNode interface.\n *\n * @public\n */\nexport type TrapGetter =\n  | ((node: FormKitNode, context: FormKitContext, ...args: any[]) => unknown)\n  | false\n\n/**\n * The signature for a node's trap setter — these are more rare than getter\n * traps, but can be useful for blocking access to certain context properties\n * or modifying the behavior of an assignment (ex. see setParent).\n *\n * @public\n */\nexport type TrapSetter =\n  | ((\n      node: FormKitNode,\n      context: FormKitContext,\n      property: string | number | symbol,\n      value: any\n    ) => boolean | never)\n  | false\n\n/**\n * The map signature for a node's traps Map.\n *\n * @public\n */\nexport type FormKitTraps = Map<string | symbol, FormKitTrap>\n\n/**\n * General \"app\" like configuration options, these are automatically inherited\n * by all children — they are not reactive.\n *\n * @public\n */\nexport interface FormKitConfig {\n  /**\n   * The delimiter character to use for a node’s tree address. By default this\n   * is a dot `.`, but if you use dots in your input names you may want to\n   * change this to something else.\n   */\n  delimiter: string\n  /**\n   * Classes to apply on the various sections. These classes are applied after\n   * rootClasses has already run.\n   */\n  classes?: Record<string, FormKitClasses | string | Record<string, boolean>>\n  /**\n   * The rootClasses function is called to allocate the base layer of classes\n   * for each section. These classes can be further extended or modified by the\n   * classes config, classes prop, and section-class props.\n   */\n  rootClasses:\n    | ((sectionKey: string, node: FormKitNode) => Record<string, boolean>)\n    | false\n  /**\n   * A root config object. This object is usually the globally defined options.\n   */\n  rootConfig?: FormKitRootConfig\n\n  /**\n   * The merge strategy is a map of names to merge strategies. The merge\n   * strategy is used to determine how a node’s value should be merged if there\n   * are 2 nodes with the same name.\n   */\n  mergeStrategy?: Record<string | symbol, 'synced'>\n\n  [index: string]: any\n}\n\n/**\n * The user-land per-instance \"props\", which are generally akin to the props\n * passed into components on the front end.\n *\n * @public\n */\nexport type FormKitProps<V = unknown> = {\n  /**\n   * An instance of the current document’s root. When inside the context of a\n   * custom element, this will be the ShadowRoot. In most other instances this\n   * will be the Document. During SSR and other server-side contexts this will\n   * be undefined.\n   */\n  __root?: Document | ShadowRoot\n  /**\n   * An object or array of \"props\" that should be applied to the input. When\n   * using Vue, these are pulled from the attrs and placed into the node.props\n   * according to the definition provided here.\n   */\n  readonly __propDefs: FormKitPseudoProps\n  /**\n   * The total amount of time in milliseconds to debounce the input before the\n   * committing the value to the form tree.\n   */\n  delay: number\n  /**\n   * The unique id of the input. These should *always* be globally unique.\n   */\n  id: string\n  /**\n   * A function that defines how the validationLabel should be provided. By\n   * default this is the validation-label, label, then name in decreasing\n   * specificity.\n   */\n  validationLabelStrategy?: (node?: FormKitNode) => string\n  /**\n   * An object of validation rules.\n   */\n  validationRules?: Record<\n    string,\n    (node: FormKitNode, ...args: any[]) => boolean | Promise<boolean>\n  >\n  /**\n   * An object of validation messages.\n   */\n  validationMessages?: Record<\n    string,\n    ((ctx: { name: string; args: any[]; node: FormKitNode }) => string) | string\n  >\n  /**\n   * The definition of the node’s input type (if it has one).\n   */\n  definition?: FormKitTypeDefinition<V>\n  /**\n   * The framework’s context object. This is how FormKit’s core interacts with\n   * the front end framework (Vue/React/etc). This object is created by the\n   * component and is responsible for providing all the data to the framework\n   * for rendering and interaction.\n   */\n  context?: FormKitFrameworkContext\n\n  /**\n   * The merge strategy that is applied to this specific node. It can only be\n   * inherited by a parent by using the mergeStrategy config option.\n   */\n  readonly mergeStrategy?: 'synced'\n\n  [index: string]: any\n} & FormKitConfig\n\n/**\n * The interface of a FormKit node's context object. A FormKit node is a\n * proxy of this object.\n *\n * @public\n */\nexport interface FormKitContext {\n  /**\n   * A node’s internal disturbance counter.\n   */\n  _d: number\n  /**\n   * A node’s internal event emitter.\n   */\n  _e: FormKitEventEmitter\n  /**\n   * A unique identifier for a node.\n   */\n  uid: symbol\n  /**\n   * A node’s internal disturbance counter promise.\n   */\n  _resolve: ((value: unknown) => void) | false\n  /**\n   * A node’s internal input timeout.\n   */\n  _tmo: number | false\n  /**\n   * A node’s internal pre-commit value.\n   */\n  _value: unknown\n  /**\n   * An array of child nodes (groups and lists)\n   */\n  children: Array<FormKitNode | FormKitPlaceholderNode>\n  /**\n   * Configuration state for a given tree.\n   */\n  config: FormKitConfig\n  /**\n   * The context object of the current front end framework being used.\n   */\n  context?: FormKitFrameworkContext\n  /**\n   * Set of hooks\n   */\n  hook: FormKitHooks\n  /**\n   * Begins as false, set to true when the node is finished being created.\n   */\n  isCreated: boolean\n  /**\n   * Boolean determines if the node is in a settled state or not.\n   */\n  isSettled: boolean\n  /**\n   * A counting ledger for arbitrary message counters.\n   */\n  ledger: FormKitLedger\n  /**\n   * The name of the input — should be treated as readonly.\n   */\n  name: string | symbol\n  /**\n   * The parent of a node.\n   */\n  parent: FormKitNode | null\n  /**\n   * A Set of plugins registered on this node that can be inherited by children.\n   */\n  plugins: Set<FormKitPlugin>\n  /**\n   * An proxied object of props. These are typically provided by the adapter\n   * of choice.\n   */\n  props: Partial<FormKitProps>\n  /**\n   * A promise that resolves when an input is in a settled state.\n   */\n  settled: Promise<unknown>\n  /**\n   * The internal node store.\n   */\n  store: FormKitStore\n  /**\n   * The traps available to a node.\n   */\n  traps: FormKitTraps\n  /**\n   * The type of node, should only be 'input', 'list', or 'group'.\n   */\n  type: FormKitNodeType\n  /**\n   * Only used on list nodes, this flag determines whether or not the list\n   * should sync its values with the underlying node children.\n   */\n  sync: boolean\n  /**\n   * The actual value of the node.\n   */\n  value: unknown\n}\n\n/**\n * Context object to be created by and used by each respective UI framework. No\n * values are created or output by FormKitCore, but this interface\n * should be followed by each respective plugin.\n *\n * @public\n */\nexport interface FormKitFrameworkContext<T = any> {\n  [index: string]: unknown\n  /**\n   * The current \"live\" value of the input. Not debounced.\n   */\n  _value: T\n  /**\n   * The root document or shadow root the input is inside. This can be set by\n   * using a higher-order `<FormKitRoot>` component.\n   */\n  __root?: Document | ShadowRoot\n  /**\n   * An object of attributes that (generally) should be applied to the root\n   * <input> element.\n   */\n  attrs: Record<string, any>\n  /**\n   * Classes to apply on the various sections.\n   */\n  classes: Record<string, string>\n  /**\n   * Event handlers.\n   */\n  handlers: {\n    blur: (e?: FocusEvent) => void\n    touch: () => void\n    DOMInput: (e: Event) => void\n  } & Record<string, (...args: any[]) => void>\n  /**\n   * Utility functions, generally for use in the input’s schema.\n   */\n  fns: Record<string, (...args: any[]) => any>\n  /**\n   * The help text of the input.\n   */\n  help?: string\n  /**\n   * The unique id of the input. Should also be applied as the id attribute.\n   * This is generally required for accessibility reasons.\n   */\n  id: string\n  /**\n   * An array of symbols that represent the a child’s nodes. These are not the\n   * child’s nodes but are just symbols representing them. They are used to\n   * iterate over the children for rendering purposes.\n   */\n  items: symbol[]\n  /**\n   * The label of the input.\n   */\n  label?: string\n  /**\n   * A list of messages to be displayed on the input. Often these are validation\n   * messages and error messages, but other `visible` core node messages do also\n   * apply here. This object is only populated when the validation should be\n   * actually displayed.\n   */\n  messages: Record<string, FormKitMessage>\n  /**\n   * The core node of this input.\n   */\n  node: FormKitNode\n  /**\n   * If this input type accepts options (like select lists and checkboxes) then\n   * this will be populated with a properly structured list of options.\n   */\n  options?: Array<Record<string, any> & { label: string; value: any }>\n  /**\n   * Whether or not to render messages in the standard location.\n   */\n  defaultMessagePlacement: boolean\n  /**\n   * A record of slots that have been passed into the top level component\n   * responsible for creating the node.\n   */\n  slots: Record<string, CallableFunction>\n  /**\n   * A collection of state trackers/details about the input.\n   */\n  state: FormKitFrameworkContextState\n  /**\n   * The type of input \"text\" or \"select\" (retrieved from node.props.type). This\n   * is not the core node type (input, group, or list).\n   */\n  type: string\n  /**\n   * Translated ui messages that are not validation related. These are generally\n   * used for interface messages like \"loading\" or \"saving\".\n   */\n  ui: Record<string, FormKitMessage>\n  /**\n   * The current committed value of the input. This is the value that should be\n   * used for most use cases.\n   */\n  value: T\n}\n\n/**\n * The state inside a node’s framework context. Usually used to track things\n * like blurred and validity states.\n *\n * @public\n */\nexport interface FormKitFrameworkContextState {\n  /**\n   * If the input has been blurred.\n   */\n  blurred: boolean\n  /**\n   * True when these conditions are met:\n   *\n   * Either:\n   * - The input has validation rules\n   * - The validation rules are all passing\n   * - There are no errors on the input\n   * Or:\n   * - The input has no validation rules\n   * - The input has no errors\n   * - The input is dirty and has a value\n   *\n   * This is not intended to be used on forms/groups/lists but instead on\n   * individual inputs. Imagine placing a green checkbox next to each input\n   * when the user filled it out correctly — thats what these are for.\n   */\n  complete: boolean\n  /**\n   * If the input has had a value typed into it or a change made to it.\n   */\n  dirty: boolean\n  /**\n   * If the input has explicit errors placed on it, or in the case of a group,\n   * list, or form, this is true if any children have errors on them.\n   */\n  errors: boolean\n  /**\n   * Determines if the input should be considered \"invalid\" — note that this\n   * is not the opposite of the valid state. A valid input is one where the\n   * input is not loading, not pending validation, not unsettled, and\n   * passes all validation rules. An invalid input is one whose validation\n   * rules are not explicitly not passing, and those rules are visible to the user.\n   */\n  invalid: boolean\n  /**\n   * Whether or not the input includes the \"required\" validation rule. This rule\n   * is uniquely called out for accessibility reasons and should be used to\n   * power the `aria-required` attribute.\n   */\n  required: boolean\n  /**\n   * True when the input has validation rules. Has nothing to do with the\n   * state of those validation rules.\n   */\n  rules: boolean\n  /**\n   * True when the input has completed its internal debounce cycle and the\n   * value was committed to the form.\n   */\n  settled: boolean\n  /**\n   * If the form has been submitted.\n   */\n  submitted: boolean\n  /**\n   * If the input (or group/form/list) is passing all validation rules. In\n   * the case of groups, forms, and lists this includes the validation state\n   * of all its children.\n   */\n  valid: boolean\n  /**\n   * If the validation-visibility has been satisfied and any validation\n   * messages should be displayed.\n   */\n  validationVisible: boolean\n  /**\n   * Allow users to add their own arbitrary states.\n   */\n  [index: string]: boolean\n}\n\n/**\n * Options that can be used to instantiate a new node via `createNode()`.\n *\n * @public\n */\nexport type FormKitOptions = Partial<\n  Omit<FormKitContext, 'children' | 'plugins' | 'config' | 'hook'> & {\n    /**\n     * Config settings for the node, these are automatically exposed as props\n     * but are also checked in during hierarchical for prop checking.\n     */\n    config: Partial<FormKitConfig>\n    /**\n     * Props directly set on this node, these are not inherited.\n     */\n    props: Partial<FormKitProps>\n    /**\n     * The children of the node.\n     */\n    children: FormKitNode[] | Set<FormKitNode>\n    /**\n     * The explicit index of this node when used in a list. If specified, this\n     * node will be created at this index atomically.\n     */\n    index?: number\n    /**\n     * Should only be specified on list nodes — when true this indicates if the\n     * list node should automatically sync its child nodes with the value of\n     * the list node. In other words, if the list node’s value is an array of\n     * strings, and one string is popped off, the corresponding node should be\n     * removed the list and destroyed.\n     */\n    sync: boolean\n    /**\n     * Any plugins that should be registered on this node explicitly. These will\n     * automatically be inherited by any children.\n     */\n    plugins: FormKitPlugin[]\n    /**\n     * For internal use only.\n     */\n    alias: string\n    /**\n     * For internal use only.\n     */\n    schemaAlias: string\n  }\n>\n\n/**\n * The callback type for node.each().\n *\n * @public\n */\nexport interface FormKitChildCallback {\n  (child: FormKitNode): any\n}\n\n/**\n * A descriptor of a child value, generally passed up a node tree.\n *\n * @public\n */\nexport interface FormKitChildValue {\n  name: string | number | symbol\n  value: any\n  from?: number | symbol\n}\n\n/**\n * An empty interface for adding FormKit node extensions.\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface FormKitNodeExtensions {}\n\n/**\n * FormKit's Node object produced by createNode(). Every `<FormKit />` input has\n * 1 FormKitNode (\"core node\") associated with it. All inputs, forms, and groups\n * are instances of nodes. Read more about core nodes in the\n * {@link https://formkit.com/essentials/architecture#node | architecture\n * documentation.}\n *\n * @param add -\n * Add a child to a node. The node must be a group or list.\n *\n * #### Signature\n *\n * ```typescript\n * add: (node: FormKitNode, index?: number) => FormKitNode\n * ```\n *\n * #### Parameters\n *\n * - node — A {@link FormKitNode | FormKitNode}.\n * - index *optional* — A index to where it will added to.\n *\n * #### Returns\n *\n * The added {@link FormKitNode | FormKitNode}.\n *\n * @param address -\n * The address of the current node from the root of the tree.\n *\n * #### Signature\n *\n * ```typescript\n * address: FormKitAddress\n * ```\n *\n * #### Returns\n *\n * A {@link FormKitAddress | FormKitAddress}.\n *\n * @param addProps -\n * Adds props to the given node by removing them from node.props.attrs and\n * moving them to the top-level node.props object.\n *\n * #### Signature\n *\n * ```typescript\n * addProps: (props: string[]) => FormKitNode\n * ```\n *\n * #### Parameters\n *\n * - `props` — An array of strings to be added as keys for props.\n *\n * #### Returns\n *\n * The {@link FormKitNode | FormKitNode}.\n *\n * @param at -\n * Gets a node at another address. Addresses are dot-syntax paths (or arrays) of node names.\n * For example: `form.users.0.first_name`. There are a few \"special\" traversal tokens as well:\n *\n * - `$root` — Selects the root node.\n * - `$parent` — Selects the parent node.\n * - `$self` — Selects the current node.\n *\n * #### Signature\n *\n * ```typescript\n * at: (address: FormKitAddress | '$root' | '$parent' | '$self' | (string & {})) => FormKitNode | undefined\n * ```\n *\n * #### Parameters\n *\n * - `address` — An valid string or {@link FormKitAddress | FormKitAddress}.\n *\n * #### Returns\n *\n * The found {@link FormKitNode | FormKitNode} or `undefined`.\n *\n * @param children -\n * An array of child nodes (groups and lists).\n *\n * #### Signature\n *\n * ```typescript\n * children: Array<FormKitNode>\n * ```\n *\n * #### Returns\n *\n * An array of {@link FormKitNode | FormKitNode}.\n *\n * @param clearErrors -\n * Clears the errors of the node, and optionally all the children.\n *\n * #### Signature\n *\n * ```typescript\n * clearErrors: (clearChildren?: boolean, sourceKey?: string) => FormKitNode\n * ```\n *\n * #### Parameters\n *\n * - `clearChildren` *optional* — If it should clear the children.\n * - `sourceKey` *optional* — A source key to use for reset.\n *\n * #### Returns\n *\n * The {@link FormKitNode | FormKitNode}.\n *\n * @param config -\n * An object of {@link FormKitConfig | FormKitConfig} that is shared tree-wide\n * with various configuration options that should be applied to the entire tree.\n *\n * #### Signature\n *\n * ```typescript\n * config: FormKitConfig\n * ```\n *\n * #### Returns\n *\n * A {@link FormKitConfig | FormKitConfig}.\n *\n * @param define -\n * Defines the current input's library type definition including node type,\n * schema, and props.\n *\n * #### Signature\n *\n * ```typescript\n * define: (definition: FormKitTypeDefinition) => void\n * ```\n *\n * #### Parameters\n *\n * - `definition` — A {@link FormKitTypeDefinition | FormKitTypeDefinition}.\n *\n * @param destroy -\n * Removes the node from the global registry, its parent, and emits the\n * 'destroying' event.\n *\n * #### Signature\n *\n * ```typescript\n * destroy: () => void\n * ```\n *\n * @param each -\n * Perform given callback on each of the given node's children.\n *\n * #### Signature\n *\n * ```typescript\n * each: (callback: FormKitChildCallback) => void\n * ```\n *\n * #### Parameters\n *\n * - `callback` — A {@link FormKitChildCallback | FormKitChildCallback} to be called for each child.\n *\n * @param emit -\n * Emit an event from the node so it can be listened by {@link FormKitNode | on}.\n *\n * #### Signature\n *\n * ```typescript\n * emit: (event: string, payload?: any, bubble?: boolean, meta: Record<string, unknown>) => FormKitNode\n * ```\n *\n * #### Parameters\n *\n * - `event` — The event name to be emitted.\n * - `payload` *optional* — A value to be passed together with the event.\n * - `bubble` *optional* — If the event should bubble to the parent.\n *\n * #### Returns\n *\n * The {@link FormKitNode | FormKitNode}.\n *\n * @param extend -\n * Extend a {@link FormKitNode | FormKitNode} by adding arbitrary properties\n * that are accessible via `node.{property}()`.\n *\n * #### Signature\n *\n * ```typescript\n * extend: (property: string, trap: FormKitTrap) => FormKitNode\n * ```\n *\n * #### Parameters\n *\n * - `property` — The property to add the core node (`node.{property}`).\n * - `trap` — An object with a get and set property.\n *\n * #### Returns\n *\n * The {@link FormKitNode | FormKitNode}.\n *\n * @param find -\n * Within a given tree, find a node matching a given selector. Selectors can be simple strings or a function.\n *\n * #### Signature\n *\n * ```typescript\n * find: (\n *  selector: string,\n *  searcher?: keyof FormKitNode | FormKitSearchFunction\n * ) => FormKitNode | undefined\n * ```\n *\n * #### Parameters\n *\n * - `selector` — A selector string.\n * - `searcher` *optional* — A keyof {@link FormKitNode | FormKitNode} or {@link FormKitSearchFunction | FormKitSearchFunction}.\n *\n * #### Returns\n *\n * The found {@link FormKitNode | FormKitNode} or `undefined`.\n *\n * @param hook -\n * Set of hooks.\n *\n * #### Signature\n *\n * ```typescript\n * hook: FormKitHooks\n * ```\n *\n * #### Returns\n *\n * The {@link FormKitHooks | FormKitHooks}.\n *\n * @param index -\n * The index of a node compared to its siblings. This is only applicable in cases where a node is a child of a list.\n *\n * #### Signature\n *\n * ```typescript\n * index: number\n * ```\n *\n * #### Returns\n *\n * A `number`.\n *\n * @param input -\n * The function used to set the value of a node. All changes to a node's value\n * should use this function as it ensures the tree's state is always fully tracked.\n *\n * #### Signature\n *\n * ```typescript\n * input: (value: unknown, async?: boolean) => Promise<unknown>\n * ```\n *\n * #### Parameters\n *\n * - `value` — Any value to used for the node.\n * - `async` *optional* — If the input should happen asynchronously.\n *\n * #### Returns\n *\n * A `Promise<unknown>`.\n *\n * @param isCreated -\n * Begins as false, set to true when the node is finished being created.\n *\n * #### Signature\n *\n * ```typescript\n * isCreated: boolean\n * ```\n *\n * #### Returns\n *\n * A `boolean`.\n *\n * @param isSettled -\n * Boolean reflecting the settlement state of the node and its subtree.\n *\n * #### Signature\n *\n * ```typescript\n * isSettled: boolean\n * ```\n *\n * #### Returns\n *\n * A `boolean`.\n *\n * @param ledger -\n * A counting ledger for arbitrary message counters.\n *\n * #### Signature\n *\n * ```typescript\n * ledger: FormKitLedger\n * ```\n *\n * #### Returns\n *\n * A {@link FormKitLedger | FormKitLedger}.\n *\n * @param name -\n * The name of the input in the node tree. When a node is a child of a list,\n * this automatically becomes its index.\n *\n * #### Signature\n *\n * ```typescript\n * name: string\n * ```\n *\n * #### Returns\n *\n * A `string`.\n *\n * @param off -\n * Removes an event listener by its token.\n * Receipts can be shared among many event listeners by explicitly declaring the \"receipt\" property of the listener function.\n *\n * #### Signature\n *\n * ```typescript\n * off: (receipt: string) => FormKitNode\n * ```\n *\n * #### Parameters\n *\n * - `receipt` — A receipt generated by the `on` function.\n *\n * #### Returns\n *\n * A receipt `string`.\n *\n * @param on -\n * Adds an event listener for a given event, and returns a \"receipt\" which is a random string token.\n * This token should be used to remove the listener in the future.\n * Alternatively you can assign a \"receipt\" property to the listener function and that receipt will be used instead.\n * This allows multiple listeners to all be de-registered with a single off() call if they share the same receipt.\n *\n * #### Signature\n *\n * ```typescript\n * on: (eventName: string, listener: FormKitEventListener, pos: 'push' | 'unshift') => string\n * ```\n *\n * #### Parameters\n *\n * - `eventName` — The event name to listen to.\n * - `listener` — A {@link FormKitEventListener | FormKitEventListener} to run when the event happens.\n *\n * #### Returns\n *\n * A receipt `string`.\n *\n * @param parent -\n * The parent of a node.\n *\n * #### Signature\n *\n * ```typescript\n * parent: FormKitNode | null\n * ```\n *\n * #### Returns\n *\n * If found a {@link FormKitNode | FormKitNode} or `null`.\n *\n * @param props -\n * An proxied object of props. These are typically provided by the adapter\n * of choice.\n *\n * #### Signature\n *\n * ```typescript\n * props: Partial<FormKitProps>\n * ```\n *\n * #### Returns\n *\n * An optional list of {@link FormKitProps | FormKitProps}.\n *\n * @param remove -\n * Removes a child from the node.\n *\n * #### Signature\n *\n * ```typescript\n * remove: (node: FormKitNode) => FormKitNode\n * ```\n *\n * #### Parameters\n *\n * - `node` — A {@link FormKitNode | FormKitNode} to be removed.\n *\n * #### Returns\n *\n * The {@link FormKitNode | FormKitNode}.\n *\n * @param reset -\n * Resets the node’s value back to its original value.\n *\n * #### Signature\n *\n * ```typescript\n * reset: () => FormKitNode\n * ```\n *\n * #### Returns\n *\n * The {@link FormKitNode | FormKitNode}.\n *\n * @param root -\n * Retrieves the root node of a tree. This is accomplished via tree-traversal\n * on-request, and as such should not be used in frequently called functions.\n *\n * #### Signature\n *\n * ```typescript\n * root: FormKitNode\n * ```\n *\n * #### Returns\n *\n * The {@link FormKitNode | FormKitNode}.\n *\n * @param setErrors -\n * Sets errors on the input, and optionally to child inputs.\n *\n * #### Signature\n *\n * ```typescript\n * setErrors: (localErrors: ErrorMessages, childErrors?: ErrorMessages) => void\n * ```\n *\n * #### Parameters\n *\n * - `localErrors` — A {@link ErrorMessages | ErrorMessages} to be used.\n * - `childErrors` *optional* — A {@link ErrorMessages | ErrorMessages} to be used for children.\n *\n * @param settled -\n * A promise that resolves when a node and its entire subtree is settled.\n * In other words — all the inputs are done committing their values.\n *\n * #### Signature\n *\n * ```typescript\n * settled: Promise<unknown>\n * ```\n *\n * #### Returns\n *\n * A `Promise<unknown>`.\n *\n * @param store -\n * The internal node store.\n *\n * #### Signature\n *\n * ```typescript\n * store: FormKitStore\n * ```\n *\n * #### Returns\n *\n * A {@link FormKitStore | FormKitStore}.\n *\n * @param submit -\n * Triggers a submit event on the nearest form.\n *\n * #### Signature\n *\n * ```typescript\n * submit: () => void\n * ```\n *\n * @param t -\n * A text or translation function that exposes a given string to the \"text\"\n * hook. All text shown to users should be passed through this function\n * before being displayed — especially for core and plugin authors.\n *\n * #### Signature\n *\n * ```typescript\n * t: (key: string | FormKitTextFragment) => string\n * ```\n *\n * #### Parameters\n *\n * - `key` — A key or a {@link FormKitTextFragment | FormKitTextFragment} to find the translation for.\n *\n * #### Returns\n *\n * The translated `string`.\n *\n * @param type -\n * The type of node, should only be 'input', 'list', or 'group'.\n *\n * #### Signature\n *\n * ```typescript\n * type: FormKitNodeType\n * ```\n *\n * #### Returns\n *\n * A {@link FormKitNodeType | FormKitNodeType}.\n *\n * @param use -\n * Registers a new plugin on the node and its subtree.\n *\n * #### Signature\n *\n * ```typescript\n * use: (\n *  plugin: FormKitPlugin | FormKitPlugin[] | Set<FormKitPlugin>,\n *  run?: boolean,\n *  library?: boolean\n * ) => FormKitNode\n * ```\n *\n * #### Parameters\n *\n * - `plugin` — A {@link FormKitPlugin | FormKitPlugin} or an Array or Set of {@link FormKitPlugin | FormKitPlugin}.\n * - `run` *optional* — Should the plugin be executed on creation.\n * - `library` *optional* — Should the plugin's library function be executed on creation.\n *\n * #### Returns\n *\n * The {@link FormKitNode | FormKitNode}.\n *\n * @param value -\n * The value of the input. This should never be directly modified. Any\n * desired mutations should be made through {@link FormKitNode | input}.\n *\n * #### Signature\n *\n * ```typescript\n * readonly value: unknown\n * ```\n *\n * @param walk -\n * Performs a function on every node in its subtree (but not the node itself).\n * This is an expensive operation so it should be done very rarely and only lifecycle events that are relatively rare like boot up and shut down.\n *\n * #### Signature\n *\n * ```typescript\n * walk: (callback: FormKitChildCallback, stopOnFalse?: boolean, recurseOnFalse?: boolean) => void\n * ```\n *\n * #### Parameters\n *\n * - `callback` — A {@link FormKitChildCallback | FormKitChildCallback} to be executed for each child.\n * - `stopOnFalse` *optional* — If it should stop when the return is false.\n *\n * @public\n */\nexport type FormKitNode<V = unknown> = {\n  /**\n   * Boolean true indicating this object is a valid FormKitNode\n   */\n  readonly __FKNode__: true\n  /**\n   * The value of the input. This should never be directly modified. Any\n   * desired mutations should be made through node.input()\n   */\n  readonly value: V\n  /**\n   * The internal FormKitContext object — this is not a public API and should\n   * never be used outside of the core package itself. It is only here for\n   * internal use and as an escape hatch.\n   */\n  _c: FormKitContext\n  /**\n   * Add a child to a node, the node must be a group or list.\n   */\n  add: (node: FormKitNode, index?: number) => FormKitNode\n  /**\n   * Adds props to the given node by removing them from node.props.attrs and\n   * moving them to the top-level node.props object.\n   */\n  addProps: (props: FormKitPseudoProps) => FormKitNode\n  /**\n   * Gets a node at another address. Addresses are dot-syntax paths (or arrays)\n   * of node names. For example: form.users.0.first_name. There are a few\n   * \"special\" traversal tokens as well:\n   * - $root - Selects the root node\n   * - $parent - Selects the parent node\n   * - $self — Selects the current node\n   */\n  at: (\n    address: FormKitAddress | '$root' | '$parent' | '$self' | (string & {})\n  ) => FormKitNode | undefined\n  /**\n   * The address of the current node from the root of the tree.\n   */\n  address: FormKitAddress\n  /**\n   * An internal function used to bubble an event from a child to a parent.\n   */\n  bubble: (event: FormKitEvent) => FormKitNode\n  /**\n   * An internal mechanism for calming a disturbance — which is a mechanism\n   * used to know the state of input settlement in the tree.\n   */\n  calm: (childValue?: FormKitChildValue) => FormKitNode\n  /**\n   * Clears the errors of the node, and optionally all the children.\n   */\n  clearErrors: (clearChildren?: boolean, sourceKey?: string) => FormKitNode\n  /**\n   * An object that is shared tree-wide with various configuration options that\n   * should be applied to the entire tree.\n   */\n  config: FormKitConfig\n  /**\n   * Defines the current input's library type definition — including node type,\n   * schema, and props.\n   */\n  define: (definition: FormKitTypeDefinition<V>) => void\n  /**\n   * Increments a disturbance. A disturbance is a record that the input or a\n   * member of its subtree is no longer \"settled\". Disturbed nodes are ones\n   * that have had their value modified, but have not yet committed that value\n   * to the rest of the tree.\n   */\n  disturb: () => FormKitNode\n  /**\n   * Removes the node from the global registry, its parent, and emits the\n   * 'destroying' event.\n   */\n  destroy: () => void\n  /**\n   * Perform given callback on each of the given node's children.\n   */\n  each: (callback: FormKitChildCallback) => void\n  /**\n   * Emit an event from the node.\n   */\n  emit: (\n    event: string,\n    payload?: any,\n    bubble?: boolean,\n    meta?: Record<string, unknown>\n  ) => FormKitNode\n  /**\n   * Extend the core node by giving it a key and a trap.\n   */\n  extend: (key: string, trap: FormKitTrap) => FormKitNode\n  /**\n   * Within a given tree, find a node matching a given selector. Selectors\n   * can be simple strings or a function.\n   */\n  find: (\n    selector: string,\n    searcher?: keyof FormKitNode | FormKitSearchFunction\n  ) => FormKitNode | undefined\n  /**\n   * An internal mechanism to hydrate values down a node tree.\n   */\n  hydrate: () => FormKitNode\n  /**\n   * The index of a node compared to its siblings. This is only applicable in\n   * cases where a node is a child of a list.\n   */\n  index: number\n  /**\n   * The function used to set the value of a node. All changes to a node's value\n   * should use this function as it ensures the tree's state is always fully\n   * tracked.\n   */\n  input: (value: unknown, async?: boolean) => Promise<unknown>\n  /**\n   * The name of the input in the node tree. When a node is a child of a list,\n   * this automatically becomes its index.\n   */\n  name: string\n  /**\n   * Adds an event listener for a given event, and returns a \"receipt\" which is\n   * a random string token. This token should be used to remove the listener\n   * in the future. Alternatively you can assign a \"receipt\" property to the\n   * listener function and that receipt will be used instead — this allows\n   * multiple listeners to all be de-registered with a single off() call if they\n   * share the same receipt.\n   */\n  on: (\n    eventName: string,\n    listener: FormKitEventListener,\n    pos?: 'push' | 'unshift'\n  ) => string\n  /**\n   * Removes an event listener by its token. Receipts can be shared among many\n   * event listeners by explicitly declaring the \"receipt\" property of the\n   * listener function.\n   */\n  off: (receipt: string) => FormKitNode\n  /**\n   * Remove a child from a node.\n   */\n  remove: (node: FormKitNode | FormKitPlaceholderNode) => FormKitNode\n  /**\n   * Retrieves the root node of a tree. This is accomplished via tree-traversal\n   * on-request, and as such should not be used in frequently called functions.\n   */\n  root: FormKitNode\n  /**\n   * Resets the configuration of a node.\n   */\n  resetConfig: () => void\n  /**\n   * Reset a node’s value back to its original value.\n   */\n  reset: (value?: unknown) => FormKitNode\n  /**\n   * Sets errors on the input, and optionally to child inputs.\n   */\n  setErrors: (localErrors: ErrorMessages, childErrors?: ErrorMessages) => void\n  /**\n   * A promise that resolves when a node and its entire subtree is settled.\n   * In other words — all the inputs are done committing their values.\n   */\n  settled: Promise<unknown>\n  /**\n   * Triggers a submit event on the nearest form.\n   */\n  submit: () => void\n  /**\n   * A text or translation function that exposes a given string to the \"text\"\n   * hook. All text shown to users should be passed through this function\n   * before being displayed — especially for core and plugin authors.\n   */\n  t: (key: string | FormKitTextFragment) => string\n  /**\n   * Boolean reflecting the settlement state of the node and its subtree.\n   */\n  isSettled: boolean\n  /**\n   * A unique identifier for the node.\n   */\n  uid: symbol\n  /**\n   * Registers a new plugin on the node and its subtree.\n   * run = should the plugin be executed or not\n   * library = should the plugin's library function be executed (if there)\n   */\n  use: (\n    plugin: FormKitPlugin | FormKitPlugin[] | Set<FormKitPlugin>,\n    run?: boolean,\n    library?: boolean\n  ) => FormKitNode\n  /**\n   * Performs a function on every node in the subtree (not itself). This is an\n   * expensive operation so it should be done very rarely and only lifecycle\n   * events that are relatively rare like boot up and shut down.\n   */\n  walk: (\n    callback: FormKitChildCallback,\n    stopOnFalse?: boolean,\n    skipSubtreeOnFalse?: boolean\n  ) => void\n} & Omit<FormKitContext, 'value' | 'name' | 'config'> &\n  FormKitNodeExtensions\n\n/**\n * A faux node that is used as a placeholder in the children node array during\n * various node manipulations.\n * @public\n */\nexport interface FormKitPlaceholderNode<V = unknown> {\n  /**\n   * Flag indicating this is a placeholder.\n   */\n  __FKP: true\n  /**\n   * A unique symbol identifying this placeholder.\n   */\n  uid: symbol\n  /**\n   * The type of placeholder node, if relevant.\n   */\n  type: FormKitNodeType\n  /**\n   * A value at the placeholder location.\n   */\n  value: V\n  /**\n   * The uncommitted value, in a placeholder will always be the same\n   * as the value.\n   */\n  _value: V\n  /**\n   * Artificially use a plugin (performs no-op)\n   */\n  use: (...args: any[]) => void\n  /**\n   * Artificial props\n   */\n  props: Record<string, any>\n  /**\n   * A name to use.\n   */\n  name: string\n  /**\n   * Sets the value of the placeholder.\n   */\n  input: (value: unknown, async?: boolean) => Promise<unknown>\n  /**\n   * A placeholder is always settled.\n   */\n  isSettled: boolean\n}\n\n/**\n * A prop definition for a pseudo prop that defines a type and a default value.\n * @public\n */\nexport type FormKitPseudoProp =\n  | {\n      boolean?: true\n      default?: boolean\n      setter?: undefined\n      getter?: undefined\n    }\n  | {\n      boolean?: undefined\n      default?: unknown\n      setter?: (value: unknown, node: FormKitNode) => unknown\n      getter?: (value: unknown, node: FormKitNode) => unknown\n    }\n\n/**\n * Pseudo props are \"non-runtime\" props. Props that are not initially declared\n * as props, and are fetch out of the attrs object (in the context of VueJS).\n * @public\n */\nexport type FormKitPseudoProps =\n  | string[]\n  | Record<PropertyKey, FormKitPseudoProp>\n\n/**\n * Breadth and depth-first searches can use a callback of this notation.\n *\n * @public\n */\nexport type FormKitSearchFunction = (\n  node: FormKitNode,\n  searchTerm?: string | number\n) => boolean\n\n/**\n * Default configuration options.\n */\nconst defaultConfig: Partial<FormKitConfig> = {\n  delimiter: '.',\n  delay: 0,\n  locale: 'en',\n  rootClasses: (key: string) => ({ [`formkit-${kebab(key)}`]: true }),\n}\n\n/**\n * If a node’s name is set to useIndex, it replaces the node’s name with the\n * index of the node relative to its parent’s children.\n *\n * @internal\n */\nexport const useIndex = Symbol('index')\n\n/**\n * When propagating values up a tree, this value indicates the child should be\n * removed.\n *\n * @internal\n */\nexport const valueRemoved = Symbol('removed')\n\n/**\n * When propagating values up a tree, this value indicates the child should be\n * moved.\n *\n * @internal\n */\nexport const valueMoved = Symbol('moved')\n\n/**\n * When creating a new node and having its value injected directly at a specific\n * location.\n *\n * @internal\n */\nexport const valueInserted = Symbol('inserted')\n\n/**\n * A simple type guard to determine if the context being evaluated is a list\n * type.\n *\n * @param arg - A {@link FormKitContextShape | FormKitContextShape}.\n *\n * @returns Returns a `boolean`.\n *\n * @public\n */\nexport function isList(arg: FormKitContextShape): arg is FormKitListContext {\n  return arg.type === 'list' && Array.isArray(arg._value)\n}\n\n/**\n * Determine if a given object is a node.\n *\n * @example\n *\n * ```javascript\n * import { isNode, createNode } from '@formkit/core'\n *\n * const input = createNode({\n *   type: 'input', // defaults to 'input' if not specified\n *   value: 'hello node world',\n * })\n *\n * const obj = {};\n *\n * isNode(obj)\n * // false\n *\n * isNode(input)\n * // true\n * ```\n *\n * @param node - Any value.\n *\n * @returns Returns a `boolean`.\n *\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function isNode(node: any): node is FormKitNode {\n  return node && typeof node === 'object' && node.__FKNode__ === true\n}\n\n/**\n * The setter you are trying to access is invalid.\n */\nconst invalidSetter = (\n  node: FormKitNode,\n  _context: FormKitContext,\n  property: PropertyKey\n): never => {\n  error(102, [node, property])\n}\n\nconst traps = {\n  _c: trap(getContext, invalidSetter, false),\n  add: trap(addChild),\n  addProps: trap(addProps),\n  address: trap(getAddress, invalidSetter, false),\n  at: trap(getNode),\n  bubble: trap(bubble),\n  clearErrors: trap(clearErrors),\n  calm: trap(calm),\n  config: trap(false),\n  define: trap(define),\n  disturb: trap(disturb),\n  destroy: trap(destroy),\n  extend: trap(extend),\n  hydrate: trap(hydrate),\n  index: trap(getIndex, setIndex, false),\n  input: trap(input),\n  each: trap(eachChild),\n  emit: trap(emit),\n  find: trap(find),\n  on: trap(on),\n  off: trap(off),\n  parent: trap(false, setParent),\n  plugins: trap(false),\n  remove: trap(removeChild),\n  root: trap(getRoot, invalidSetter, false),\n  reset: trap(resetValue),\n  resetConfig: trap(resetConfig),\n  setErrors: trap(setErrors),\n  submit: trap(submit),\n  t: trap(text),\n  use: trap(use),\n  name: trap(getName, false, false),\n  walk: trap(walkTree),\n}\n\n/**\n * These are all the available \"traps\" for a given node. You can think of these\n * a little bit like methods, but they are really Proxy interceptors.\n */\nfunction createTraps(): FormKitTraps {\n  return new Map<string | symbol, FormKitTrap>(Object.entries(traps))\n}\n\n/**\n * Creates a getter/setter trap and curries the context/node pair\n *\n * @param getter - The getter function\n * @param setter - The setter function\n * @param curryGetter - Indicates if the getter should be curried or not\n *\n * @returns A {@link FormKitTrap | FormKitTrap}\n */\nfunction trap(\n  getter?: TrapGetter,\n  setter?: TrapSetter,\n  curryGetter = true\n): FormKitTrap {\n  return {\n    get: getter\n      ? (node, context) =>\n          curryGetter\n            ? (...args: any[]) => getter(node, context, ...args)\n            : getter(node, context)\n      : false,\n    set: setter !== undefined ? setter : invalidSetter.bind(null),\n  }\n}\n\n/**\n * Create all of the node's hook dispatchers.\n */\nfunction createHooks(): FormKitHooks {\n  const hooks: Map<string, FormKitDispatcher<unknown>> = new Map()\n  return new Proxy(hooks, {\n    get(_, property: string) {\n      if (!hooks.has(property)) {\n        hooks.set(property, createDispatcher())\n      }\n      return hooks.get(property)\n    },\n  }) as unknown as FormKitHooks\n}\n\n/**\n * This is a simple integer counter of every createName() where the name needs\n * to be generated.\n */\nlet nameCount = 0\n/**\n * This is a simple integer counter of every default id created.\n */\nlet idCount = 0\n\n/**\n * Resets the global number of node registrations, useful for deterministic\n * node naming.\n *\n * @public\n */\nexport function resetCount(): void {\n  nameCount = 0\n  idCount = 0\n}\n\n/**\n * Create a name-based dictionary of all children in an array.\n *\n * @param children - An array of {@link FormKitNode | FormKitNode}.\n *\n * @returns A dictionary of named {@link FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport function names(children: FormKitNode[]): {\n  [index: string]: FormKitNode\n} {\n  return children.reduce(\n    (named, child) => Object.assign(named, { [child.name]: child }),\n    {}\n  )\n}\n\n/**\n * This node is responsible for deterministically generating an id for this\n * node. This cannot just be a random id, it _must_ be deterministic to ensure\n * re-hydration of the form (like post-SSR) produces the same names/ids.\n *\n * @param options - A {@link FormKitOptions | FormKitOptions}\n *\n * @returns `string | symbol`\n *\n * @internal\n */\nfunction createName(options: FormKitOptions): string | symbol {\n  if (options.parent?.type === 'list') return useIndex\n  return options.name || `${options.props?.type || 'input'}_${++nameCount}`\n}\n\n/**\n * Creates the initial value for a node based on the options passed in and the\n * type of the input.\n *\n * @param options - A {@link FormKitOptions | FormKitOptions}.\n *\n * @returns `unknown`\n *\n * @public\n */\nexport function createValue(options: FormKitOptions): unknown {\n  if (options.type === 'group') {\n    return init(\n      options.value &&\n        typeof options.value === 'object' &&\n        !Array.isArray(options.value)\n        ? options.value\n        : {}\n    )\n  } else if (options.type === 'list') {\n    return init(Array.isArray(options.value) ? options.value : [])\n  }\n  return options.value\n}\n/**\n * Sets the internal value of the node.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param value - A input value to the node\n * @param async - If its an async call\n *\n * @returns `Promise<unknown>`\n *\n * @internal\n */\nfunction input(\n  node: FormKitNode,\n  context: FormKitContext,\n  value: unknown,\n  async = true\n): Promise<unknown> {\n  context._value = validateInput(node, node.hook.input.dispatch(value))\n  node.emit('input', context._value)\n  if (\n    node.isCreated &&\n    node.type === 'input' &&\n    eq(context._value, context.value) &&\n    !node.props.mergeStrategy\n  ) {\n    node.emit('commitRaw', context.value)\n    // Perform an early return if the value hasn't changed during this input.\n    return context.settled\n  }\n  if (context.isSettled) node.disturb()\n  if (async) {\n    if (context._tmo) clearTimeout(context._tmo)\n    context._tmo = setTimeout(\n      commit,\n      node.props.delay,\n      node,\n      context\n    ) as unknown as number\n  } else {\n    commit(node, context)\n  }\n  return context.settled\n}\n\n/**\n * Validate that the current input is allowed.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param value - The value that is being validated\n *\n * @returns `T`\n *\n * @internal\n */\nfunction validateInput<T>(node: FormKitNode, value: T): T {\n  switch (node.type) {\n    // Inputs are allowed to have any type\n    case 'input':\n      break\n    case 'group':\n      if (!value || typeof value !== 'object') error(107, [node, value])\n      break\n    case 'list':\n      if (!Array.isArray(value)) error(108, [node, value])\n      break\n  }\n  return value\n}\n\n/**\n * Commits the working value to the node graph as the value of this node.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param calm - If it calms the node\n * @param hydrate - If it hydrates the node\n *\n * @internal\n */\nfunction commit(\n  node: FormKitNode,\n  context: FormKitContext,\n  calm = true,\n  hydrate = true\n) {\n  context._value = context.value = node.hook.commit.dispatch(context._value)\n  if (node.type !== 'input' && hydrate) node.hydrate()\n  node.emit('commitRaw', context.value)\n  node.emit('commit', context.value)\n  if (calm) node.calm()\n}\n\n/**\n * Perform a modification to a single element of a parent aggregate value. This\n * is only performed on the pre-committed value (_value), although typically\n * the value and _value are both linked in memory.\n *\n * @param context - A {@link FormKitContext | FormKitContext}\n *\n * @internal\n */\nfunction partial(\n  context: FormKitContext,\n  { name, value, from }: FormKitChildValue\n) {\n  if (Object.isFrozen(context._value)) return\n  if (isList(context)) {\n    const insert: any[] =\n      value === valueRemoved\n        ? []\n        : value === valueMoved && typeof from === 'number'\n        ? context._value.splice(from, 1)\n        : [value]\n    context._value.splice(\n      name as number,\n      value === valueMoved || from === valueInserted ? 0 : 1,\n      ...insert\n    )\n    return\n  }\n\n  if (value !== valueRemoved) {\n    ;(context._value as FormKitGroupValue)[name as string] = value\n  } else {\n    delete (context._value as FormKitGroupValue)[name as string]\n  }\n}\n\n/**\n * Hydrate node and its children\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n *\n * @returns A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction hydrate(node: FormKitNode, context: FormKitContext): FormKitNode {\n  const _value = context._value as KeyedValue\n  // For \"synced\" lists the underlying nodes need to be synced to their values\n  // before hydration.\n  if (node.type === 'list' && node.sync) syncListNodes(node, context)\n  context.children.forEach((child) => {\n    if (typeof _value !== 'object') return\n    if (child.name in _value) {\n      // In this case, the parent has a value to give to the child, so we\n      // perform a down-tree synchronous input which will cascade values down\n      // and then ultimately back up.\n      const childValue =\n        child.type !== 'input' ||\n        (_value[child.name] && typeof _value[child.name] === 'object')\n          ? init(_value[child.name])\n          : _value[child.name]\n      // If the two are already equal or the child is currently disturbed then\n      // don’t send the value down since it will squash the child’s value.\n      if (\n        !child.isSettled ||\n        ((!isObject(childValue) || child.props.mergeStrategy) &&\n          eq(childValue, child._value))\n      )\n        return\n\n      // If there is a change to the child, push the new value down.\n      child.input(childValue, false)\n    } else {\n      if (node.type !== 'list' || typeof child.name === 'number') {\n        // In this case, the parent’s values have no knowledge of the child\n        // value — this typically occurs on the commit at the end of addChild()\n        // we need to create a value reservation for this node’s name. This is\n        // especially important when dealing with lists where index matters.\n        partial(context, { name: child.name, value: child.value })\n      }\n      if (!_value.__init) {\n        // In this case, someone has explicitly set the value to an empty object\n        // with node.input({}) so we do not define the __init property:\n        if (child.type === 'group') child.input({}, false)\n        else if (child.type === 'list') child.input([], false)\n        else child.input(undefined, false)\n      }\n    }\n  })\n  return node\n}\n\n/**\n * Hydrate a list node and its children. There are some assumptions about the\n * child nodes that are made here:\n * 1. The child nodes are either:\n *    - Are scalars and their values can be exchanged.\n *    - Are groups and should maintain node identity.\n * 2. The value of the list will be a 1-1 representation of the children.\n * 3. If new values are *added* to the list, those nodes must be created by some\n *   other means — adding a value does not add a node automatically.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n */\nfunction syncListNodes(node: FormKitNode, context: FormKitContext) {\n  const _value = node._value\n  if (!Array.isArray(_value)) return\n\n  const newChildren: Array<FormKitNode | FormKitPlaceholderNode | null> = []\n  const unused = new Set(context.children)\n  const placeholderValues = new Map<unknown, number[]>()\n\n  // 1. Iterate over the values and if the values at the same index are equal\n  //    then we can reuse the node. Otherwise we add a `null` placeholder.\n  _value.forEach((value, i) => {\n    if (context.children[i] && context.children[i]._value === value) {\n      newChildren.push(context.children[i])\n      unused.delete(context.children[i])\n    } else {\n      newChildren.push(null)\n\n      const indexes = placeholderValues.get(value) || []\n      indexes.push(i)\n      placeholderValues.set(value, indexes)\n    }\n  })\n\n  // 2. If there are unused nodes, and there are null nodes in the new children\n  //    then we attempt to match those irregardless of their index.\n  if (unused.size && placeholderValues.size) {\n    unused.forEach((child) => {\n      if (placeholderValues.has(child._value)) {\n        /* eslint-disable @typescript-eslint/no-non-null-assertion */\n        const indexes = placeholderValues.get(child._value)!\n        const index = indexes.shift()!\n        /* eslint-enable @typescript-eslint/no-non-null-assertion */\n        newChildren[index] = child\n        unused.delete(child)\n        if (!indexes.length) placeholderValues.delete(child._value)\n      }\n    })\n  }\n\n  // 3. If there are still unused nodes, and unused placeholders, we assign the\n  //    unused nodes to the unused placeholders in order.\n  const emptyIndexes: number[] = []\n  placeholderValues.forEach((indexes) => {\n    emptyIndexes.push(...indexes)\n  })\n\n  while (unused.size && emptyIndexes.length) {\n    const child = unused.values().next().value\n    const index = emptyIndexes.shift()\n    if (index === undefined) break\n    newChildren[index] = child\n    unused.delete(child)\n  }\n\n  // 4. If there are placeholders in the children, we create true placeholders.\n  emptyIndexes.forEach((index, value) => {\n    newChildren[index] = createPlaceholder({ value })\n  })\n\n  // 5. If there are unused nodes, we remove them. To ensure we don’t remove any\n  //    values we explicitly remove each child’s parent and manually unmerge the\n  //    child from the parent’s ledger before destroying the subtree.\n  if (unused.size) {\n    unused.forEach((child) => {\n      if (!('__FKP' in child)) {\n        const parent = child._c.parent\n        if (!parent || isPlaceholder(parent)) return\n        parent.ledger.unmerge(child)\n        child._c.parent = null\n        child.destroy()\n      }\n    })\n  }\n\n  // 6. Finally, we assign the new children to the context.\n  context.children = newChildren as Array<FormKitNode | FormKitPlaceholderNode>\n}\n\n/**\n * Disturbs the state of a node from settled to unsettled — creating appropriate\n * promises and resolutions.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n *\n * @returns A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction disturb(node: FormKitNode, context: FormKitContext): FormKitNode {\n  if (context._d <= 0) {\n    context.isSettled = false\n    node.emit('settled', false, false)\n    context.settled = new Promise((resolve) => {\n      context._resolve = resolve\n    })\n    if (node.parent) node.parent?.disturb()\n  }\n  context._d++\n  return node\n}\n\n/**\n * Calms the given node's disturbed state by one.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param value - A {@link FormKitChildValue | FormKitChildValue}\n *\n * @internal\n */\nfunction calm(\n  node: FormKitNode,\n  context: FormKitContext,\n  value?: FormKitChildValue\n) {\n  if (value !== undefined && node.type !== 'input') {\n    partial(context, value)\n    const shouldHydrate = !!(\n      node.config.mergeStrategy && node.config.mergeStrategy[value.name]\n    )\n    // Commit the value up, but do not hydrate back down\n    return commit(node, context, true, shouldHydrate)\n  }\n  if (context._d > 0) context._d--\n  if (context._d === 0) {\n    context.isSettled = true\n    node.emit('settled', true, false)\n    if (node.parent)\n      node.parent?.calm({ name: node.name, value: context.value })\n    if (context._resolve) context._resolve(context.value)\n  }\n}\n\n/**\n * This node is being removed and needs to be cleaned up.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n *\n * @internal\n */\nfunction destroy(node: FormKitNode, context: FormKitContext) {\n  node.emit('destroying', node)\n  // flush all messages out\n  node.store.filter(() => false)\n  if (node.parent) {\n    node.parent.remove(node)\n  }\n  deregister(node)\n  node.emit('destroyed', node)\n  context._e.flush()\n  context._value = context.value = undefined\n  for (const property in context.context) {\n    delete context.context[property]\n  }\n  context.plugins.clear()\n  context.context = null! // eslint-disable-line @typescript-eslint/no-non-null-assertion\n}\n\n/**\n * Defines the current input type concretely.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param definition - A {@link FormKitTypeDefinition | FormKitTypeDefinition}\n *\n * @internal\n */\nfunction define(\n  node: FormKitNode,\n  context: FormKitContext,\n  definition: FormKitTypeDefinition\n) {\n  // Prop definitions that may have been registered before the input was\n  // ever defined, for example with a manual createNode()\n  // Assign the type\n  context.type = definition.type\n  // Assign the definition\n  const clonedDef = clone(definition)\n  // Merge existing prop defs into the cloned input definition.\n  // @ts-ignore-next-line\n  node.props.__propDefs = mergeProps(\n    node.props.__propDefs ?? [],\n    clonedDef?.props || []\n  )\n  // Assign the prop defs to the cloned input definition.\n  clonedDef.props = node.props.__propDefs\n\n  // Assign the definition to the props\n  context.props.definition = clonedDef\n\n  // Ensure the type is seeded with the `__init` value.\n  context.value = context._value = createValue({\n    type: node.type,\n    value: context.value,\n  })\n  /**\n   * If the user has a typename defined, use it here.\n   */\n  if (definition.forceTypeProp) {\n    if (node.props.type) node.props.originalType = node.props.type\n    context.props.type = definition.forceTypeProp\n  }\n  /**\n   * If the input is part of a family of inputs, add that prop.\n   */\n  if (definition.family) {\n    context.props.family = definition.family\n  }\n  // Apply any input features before resetting the props.\n  if (definition.features) {\n    definition.features.forEach((feature) => feature(node))\n  }\n  // Its possible that input-defined \"props\" have ended up in the context attrs\n  // these should be moved back out of the attrs object.\n  if (definition.props) {\n    node.addProps(definition.props)\n  }\n\n  node.emit('defined', definition)\n}\n\n/**\n * Adds props to a given node by stripping them out of the node.props.attrs and\n * then adding them to the nodes.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param props - An array of prop strings (in camelCase!)\n *\n * @returns A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction addProps(\n  node: FormKitNode,\n  context: FormKitContext,\n  props: FormKitPseudoProps\n): FormKitNode {\n  const propNames = Array.isArray(props) ? props : Object.keys(props)\n  const defaults: Record<string, unknown> = !Array.isArray(props)\n    ? propNames.reduce((defaults, name) => {\n        if ('default' in props[name]) {\n          defaults[name] = props[name].default\n        }\n        return defaults\n      }, {} as Record<string, unknown>)\n    : {}\n  if (node.props.attrs) {\n    const attrs = { ...node.props.attrs }\n    // Temporarily disable prop emits\n    node.props._emit = false\n    for (const attr in attrs) {\n      const camelName = camel(attr)\n      if (propNames.includes(camelName)) {\n        node.props[camelName] = attrs[attr]\n        delete attrs[attr]\n      }\n    }\n    // Assign defaults to any props\n    if (!Array.isArray(props)) {\n      propNames.forEach((prop) => {\n        if ('default' in props[prop] && node.props[prop] === undefined) {\n          node.props[prop] = defaults[prop]\n        }\n      })\n    }\n    const initial = cloneAny(context._value)\n    node.props.initial =\n      node.type !== 'input' ? init(initial as KeyedValue) : initial\n    // Re-enable prop emits\n    node.props._emit = true\n    node.props.attrs = attrs\n  }\n  const mergedProps = mergeProps(node.props.__propDefs ?? [], props)\n\n  if (node.props.definition) {\n    node.props.definition.props = mergedProps\n  }\n\n  // @ts-ignore-next-line\n  node.props.__propDefs = mergedProps\n\n  node.emit('added-props', props)\n  return node\n}\n\nfunction toPropsObj(\n  props: FormKitPseudoProps\n): Record<PropertyKey, FormKitPseudoProp> {\n  return !Array.isArray(props)\n    ? props\n    : props.reduce((props, prop) => {\n        props[prop] = {}\n        return props\n      }, {} as Record<PropertyKey, FormKitPseudoProp>)\n}\n\nfunction mergeProps(\n  props: FormKitPseudoProps,\n  newProps: FormKitPseudoProps\n): FormKitPseudoProps {\n  if (Array.isArray(props) && Array.isArray(newProps))\n    return props.concat(newProps)\n  return merge(toPropsObj(props), toPropsObj(newProps)) as Record<\n    PropertyKey,\n    FormKitPseudoProp\n  >\n}\n\n/**\n * Adds a child to the node.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A parent {@link FormKitContext | FormKitContext}\n * @param child - A {@link FormKitNode | FormKitNode}\n * @param listIndex - A index number to be added at\n *\n * @internal\n */\nfunction addChild(\n  parent: FormKitNode,\n  parentContext: FormKitContext,\n  child: FormKitNode,\n  listIndex?: number\n) {\n  if (parent.type === 'input') error(100, parent)\n  if (child.parent && child.parent !== parent) {\n    child.parent.remove(child)\n  }\n  // Synchronously set the initial value on the parent\n  if (!parentContext.children.includes(child)) {\n    if (listIndex !== undefined && parent.type === 'list') {\n      // Inject the child:\n      const existingNode = parentContext.children[listIndex]\n      if (existingNode && '__FKP' in existingNode) {\n        // The node index is populated by a placeholderNode so we need to\n        // remove that replace it with the real node (the current child).\n        child._c.uid = existingNode.uid\n        parentContext.children.splice(listIndex, 1, child)\n      } else {\n        parentContext.children.splice(listIndex, 0, child)\n      }\n\n      if (\n        Array.isArray(parent.value) &&\n        parent.value.length < parentContext.children.length\n      ) {\n        // When adding an node or value to a list it is absolutely critical to\n        // know if, at the moment of injection, the parent’s value or the node\n        // children are the source of truth. For example, if a user pushes or\n        // splices a new value onto the lists’s array then we want to use that\n        // value as the value of the new node, but if a user adds a node to the\n        // list then we want the node’s value. In this specific case, we\n        // assume (due to length) that a new node was injected into the list, so\n        // we want that new node’s value injected into the parent list value.\n        parent.disturb().calm({\n          name: listIndex,\n          value: child.value,\n          from: valueInserted,\n        })\n      }\n    } else {\n      parentContext.children.push(child)\n    }\n    if (!child.isSettled) parent.disturb()\n  }\n  if (child.parent !== parent) {\n    child.parent = parent\n    // In this edge case middleware changed the parent assignment so we need to\n    // re-add the child\n    if (child.parent !== parent) {\n      parent.remove(child)\n      child.parent.add(child)\n      return parent\n    }\n  } else {\n    // When a parent is properly assigned, we inject the parent's plugins on the\n    // child.\n    child.use(parent.plugins)\n  }\n  // Finally we call commit here, which sub-calls hydrate(), hydrate() will\n  // resolve any conflict between the parent and child values, and also ensure\n  // proper \"placeholders\" are made on the parent.\n  commit(parent, parentContext, false)\n  parent.ledger.merge(child)\n  parent.emit('child', child)\n  return parent\n}\n\n/**\n * The setter for node.parent = FormKitNode\n * @param child - A child {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param _property - A property to be setted\n * @param parent - A parent {@link FormKitNode | FormKitNode}\n *\n * @returns `boolean`\n *\n * @internal\n */\nfunction setParent(\n  child: FormKitNode,\n  context: FormKitContext,\n  _property: string | number | symbol,\n  parent: FormKitNode\n): boolean {\n  if (isNode(parent)) {\n    if (child.parent && child.parent !== parent) {\n      child.parent.remove(child)\n    }\n    context.parent = parent\n    child.resetConfig()\n    !parent.children.includes(child)\n      ? parent.add(child)\n      : child.use(parent.plugins)\n    return true\n  }\n  if (parent === null) {\n    context.parent = null\n    return true\n  }\n  return false\n}\n\n/**\n * Removes a child from the node.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param child - A child {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction removeChild(\n  node: FormKitNode,\n  context: FormKitContext,\n  child: FormKitNode\n) {\n  const childIndex = context.children.indexOf(child)\n  if (childIndex !== -1) {\n    if (child.isSettled) node.disturb()\n    context.children.splice(childIndex, 1)\n    // If an ancestor uses the preserve prop, then we are expected to not remove\n    // our values on this node either, see #53\n    let preserve = undefine(child.props.preserve)\n    let parent = child.parent\n    while (preserve === undefined && parent) {\n      preserve = undefine(parent.props.preserve)\n      parent = parent.parent\n    }\n    if (!preserve) {\n      node.calm({\n        name: node.type === 'list' ? childIndex : child.name,\n        value: valueRemoved,\n      })\n    } else {\n      node.calm()\n    }\n    child.parent = null\n    // Remove the child from the config. Is this weird? Yes. Is it ok? Yes.\n    child.config._rmn = child\n  }\n  node.ledger.unmerge(child)\n  node.emit('childRemoved', child)\n  return node\n}\n\n/**\n * Iterate over each immediate child and perform a callback.\n *\n * @param _node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param callback - A {@link FormKitChildCallback | FormKitChildCallback}\n *\n * @internal\n */\nfunction eachChild(\n  _node: FormKitNode,\n  context: FormKitContext,\n  callback: FormKitChildCallback\n) {\n  context.children.forEach((child) => !('__FKP' in child) && callback(child))\n}\n\n/**\n * Walk all nodes below this one and execute a callback.\n *\n * @param _node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param callback - A {@link FormKitChildCallback | FormKitChildCallback}\n * @param stopIfFalse - Boolean to stop running on children\n * @param skipSubtreeOnFalse - Boolean that when true prevents recursion into a deeper node when the callback returns false\n *\n * @internal\n */\nfunction walkTree(\n  _node: FormKitNode,\n  context: FormKitContext,\n  callback: FormKitChildCallback,\n  stopIfFalse = false,\n  skipSubtreeOnFalse = false\n) {\n  context.children.some((child) => {\n    if ('__FKP' in child) return false\n    const val = callback(child)\n    // return true to stop the walk early\n    if (stopIfFalse && val === false) return true\n    if (skipSubtreeOnFalse && val === false) return false\n    return child.walk(callback, stopIfFalse, skipSubtreeOnFalse)\n  })\n}\n\n/**\n * Set the configuration options of the node and it's subtree.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n *\n * @internal\n */\nfunction resetConfig(node: FormKitNode, context: FormKitContext) {\n  const parent = node.parent || undefined\n  context.config = createConfig(node.config._t, parent)\n  node.walk((n) => n.resetConfig())\n}\n\n/**\n * Adds a plugin to the node, its children, and executes it.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param plugin -\n * {@link FormKitPlugin | FormKitPlugin}\n * {@link FormKitPlugin | FormKitPlugin[]}\n * {@link FormKitPlugin | Set<FormKitPlugin>}\n * @param run - If it will run on creation\n * @param library - If it will run on library creation\n *\n * @returns A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nexport function use(\n  node: FormKitNode,\n  context: FormKitContext,\n  plugin: FormKitPlugin | FormKitPlugin[] | Set<FormKitPlugin>,\n  run = true,\n  library = true\n): FormKitNode {\n  if (Array.isArray(plugin) || plugin instanceof Set) {\n    plugin.forEach((p: FormKitPlugin) => use(node, context, p))\n    return node\n  }\n  if (!context.plugins.has(plugin)) {\n    if (library && typeof plugin.library === 'function') plugin.library(node)\n    // When plugins return false, they are never added as to the plugins Set\n    // meaning they only ever have access to the single node they were added on.\n    if (run && plugin(node) !== false) {\n      context.plugins.add(plugin)\n      node.children.forEach((child) => child.use(plugin))\n    }\n  }\n  return node\n}\n\n/**\n * Moves a node in the parent’s children to the given index.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param _context - A {@link FormKitContext | FormKitContext}\n * @param _property - A property to add\n * @param setIndex - The index to move the node\n *\n * @internal\n */\nfunction setIndex(\n  node: FormKitNode,\n  _context: FormKitContext,\n  _property: string | number | symbol,\n  setIndex: number\n) {\n  if (isNode(node.parent)) {\n    const children = node.parent.children\n    const index =\n      setIndex >= children.length\n        ? children.length - 1\n        : setIndex < 0\n        ? 0\n        : setIndex\n    const oldIndex = children.indexOf(node)\n    if (oldIndex === -1) return false\n    children.splice(oldIndex, 1)\n    children.splice(index, 0, node)\n    node.parent.children = children\n    if (node.parent.type === 'list')\n      node.parent\n        .disturb()\n        .calm({ name: index, value: valueMoved, from: oldIndex })\n    return true\n  }\n  return false\n}\n\n/**\n * Retrieves the index of a node from the parent’s children.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction getIndex(node: FormKitNode) {\n  if (node.parent) {\n    const index = [...node.parent.children].indexOf(node)\n    // If the index is currently -1 then the node isnt finished booting, so it\n    // must be the next node.\n    return index === -1 ? node.parent.children.length : index\n  }\n  return -1\n}\n\n/**\n * Retrieves the context object of a given node. This is intended to be a\n * private trap and should absolutely not be used in plugins or user-land code.\n *\n * @param _node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n *\n * @internal\n */\nfunction getContext(_node: FormKitNode, context: FormKitContext) {\n  return context\n}\n\n/**\n * Get the name of the current node, allowing for slight mutations.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n *\n * @internal\n */\nfunction getName(node: FormKitNode, context: FormKitContext) {\n  if (node.parent?.type === 'list') return node.index\n  return context.name !== useIndex ? context.name : node.index\n}\n\n/**\n * Returns the address of the current node.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n *\n * @internal\n */\nfunction getAddress(\n  node: FormKitNode,\n  context: FormKitContext\n): FormKitAddress {\n  return context.parent\n    ? context.parent.address.concat([node.name])\n    : [node.name]\n}\n\n/**\n * Fetches a node from the tree by its address.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param _context - A {@link FormKitContext | FormKitContext}\n * @param locator - A string or {@link FormKitAddress | FormKitAddress} to find in the tree.\n *\n * @returns A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction getNode(\n  node: FormKitNode,\n  _context: FormKitContext,\n  locator: string | FormKitAddress\n): FormKitNode | undefined {\n  const address =\n    typeof locator === 'string' ? locator.split(node.config.delimiter) : locator\n  if (!address.length) return undefined\n  const first = address[0]\n  let pointer: FormKitNode | null | undefined = node.parent\n  if (!pointer) {\n    // This address names the root node, remove it to get child name:\n    if (String(address[0]) === String(node.name)) address.shift()\n    // All root nodes start at themselves ultimately:\n    pointer = node\n  }\n  // Any addresses starting with $parent should discard it\n  if (first === '$parent') address.shift()\n  while (pointer && address.length) {\n    const name = address.shift() as string | number\n    switch (name) {\n      case '$root':\n        pointer = node.root\n        break\n      case '$parent':\n        pointer = pointer.parent\n        break\n      case '$self':\n        pointer = node\n        break\n      default:\n        pointer =\n          (pointer.children.find(\n            (c) => !('__FKP' in c) && String(c.name) === String(name)\n          ) as FormKitNode | undefined) || select(pointer, name)\n    }\n  }\n  return pointer || undefined\n}\n\n/**\n * Perform selections on a subtree using the address \"selector\" methods.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param selector - A `string | number` to find in the node\n *\n * @returns A {@link FormKitNode | FormKitNode} or `undefined`\n *\n * @internal\n */\nfunction select(\n  node: FormKitNode,\n  selector: string | number\n): FormKitNode | undefined {\n  const matches = String(selector).match(/^(find)\\((.*)\\)$/)\n  if (matches) {\n    const [, action, argStr] = matches\n    const args = argStr.split(',').map((arg) => arg.trim())\n    switch (action) {\n      case 'find':\n        return node.find(args[0], args[1] as keyof FormKitNode)\n      default:\n        return undefined\n    }\n  }\n  return undefined\n}\n\n/**\n * Perform a breadth first search and return the first instance of a node that\n * is found in the subtree or undefined.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param _context - A {@link FormKitContext | FormKitContext}\n * @param searchTerm - The term we are searching for\n * @param searcher - Either a key of {@link FormKitNode | FormKitNode}, or a {@link FormKitSearchFunction | FormKitSearchFunction}\n *\n * @returns A {@link FormKitNode | FormKitNode} or `undefined`\n *\n * @internal\n */\nfunction find(\n  node: FormKitNode,\n  _context: FormKitContext,\n  searchTerm: string,\n  searcher: keyof FormKitNode | FormKitSearchFunction\n): FormKitNode | undefined {\n  return bfs(node, searchTerm, searcher)\n}\n\n/**\n * Perform a breadth-first search on a node subtree and locate the first\n * instance of a match.\n *\n * @param tree - A {@link FormKitNode | FormKitNode} to start from.\n * @param searchValue - A value to be searched.\n * @param searchGoal - A goal value.\n *\n * @returns A {@link FormKitNode | FormKitNode } or `undefined`.\n *\n * @public\n */\nexport function bfs(\n  tree: FormKitNode,\n  searchValue: string | number,\n  searchGoal: keyof FormKitNode | FormKitSearchFunction = 'name'\n): FormKitNode | undefined {\n  const search: FormKitSearchFunction =\n    typeof searchGoal === 'string'\n      ? (n: FormKitNode) => n[searchGoal] == searchValue // non-strict comparison is intentional\n      : searchGoal\n  const stack: Array<FormKitNode | FormKitPlaceholderNode> = [tree]\n  while (stack.length) {\n    const node = stack.shift()! // eslint-disable-line @typescript-eslint/no-non-null-assertion\n    if ('__FKP' in node) continue\n    if (search(node, searchValue)) return node\n    stack.push(...node.children)\n  }\n  return undefined\n}\n\n/**\n * Get the root node of the tree.\n *\n * @param n - A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction getRoot(n: FormKitNode) {\n  let node = n\n  while (node.parent) {\n    node = node.parent\n  }\n  return node\n}\n\n/**\n * Creates a new configuration option.\n *\n * @param target - An object of optional properties of {@link FormKitConfig | FormKitConfig}\n * @param parent - A parent {@link FormKitNode | FormKitNode}\n *\n * @returns {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction createConfig(\n  target: Partial<FormKitConfig> = {},\n  parent?: FormKitNode | null\n): FormKitConfig {\n  let node: FormKitNode | undefined = undefined\n  return new Proxy(target, {\n    get(...args) {\n      const prop = args[1]\n      if (prop === '_t') return target\n      const localValue = Reflect.get(...args)\n      // Check our local values first\n      if (localValue !== undefined) return localValue\n      // Then check our parent values next\n      if (parent) {\n        const parentVal = parent.config[prop as string]\n        if (parentVal !== undefined) return parentVal\n      }\n      if (target.rootConfig && typeof prop === 'string') {\n        const rootValue = target.rootConfig[prop]\n        if (rootValue !== undefined) return rootValue\n      }\n      // The default delay value should be 20\n      if (prop === 'delay' && node?.type === 'input') return 20\n      // Finally check the default values\n      return defaultConfig[prop as string]\n    },\n    set(...args) {\n      const prop = args[1] as string\n      const value = args[2]\n      if (prop === '_n') {\n        node = value as FormKitNode\n        if (target.rootConfig) target.rootConfig._add(node)\n        return true\n      }\n      if (prop === '_rmn') {\n        if (target.rootConfig) target.rootConfig._rm(node as FormKitNode)\n        node = undefined\n        return true\n      }\n      if (!eq(target[prop as string], value, false)) {\n        const didSet = Reflect.set(...args)\n        if (node) {\n          node.emit(`config:${prop}`, value, false)\n          configChange(node, prop, value)\n          // Walk the node tree and notify of config/prop changes where relevant\n          node.walk((n) => configChange(n, prop, value), false, true)\n        }\n        return didSet\n      }\n      return true\n    },\n  }) as FormKitConfig\n}\n\n/**\n * Given a string of text, expose it for modification, translation, or full\n * replacement.\n\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param _context - A {@link FormKitContext | FormKitContext}\n * @param key - A {@link FormKitTextFragment | FormKitTextFragment}, or generic string of text\n * @param type - A string to represent the text type\n *\n * @returns `string`\n *\n * @internal\n */\nfunction text(\n  node: FormKitNode,\n  _context: FormKitContext,\n  key: string | FormKitTextFragment,\n  type = 'ui'\n): string {\n  const fragment = typeof key === 'string' ? { key, value: key, type } : key\n  const value = node.hook.text.dispatch(fragment)\n  node.emit('text', value, false)\n  return value.value\n}\n\n/**\n * Submits the nearest ancestor that is a FormKit \"form\". It determines which\n * node is a form by locating an ancestor where node.props.isForm = true.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction submit(node: FormKitNode): void {\n  const name = node.name\n  do {\n    if (node.props.isForm === true) break\n    if (!node.parent) error(106, name)\n    node = node.parent\n  } while (node)\n  if (node.props.id) {\n    submitForm(node.props.id, node.props.__root)\n  }\n}\n\n/**\n * Reset to the original value.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param _context - A {@link FormKitContext | FormKitContext}\n * @param value - The value to reset to\n *\n * @internal\n */\nfunction resetValue(\n  node: FormKitNode,\n  _context: FormKitContext,\n  value?: unknown\n) {\n  return reset(node, value)\n}\n\n/**\n * Sets errors on the node and optionally its children.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param _context - A {@link FormKitContext | FormKitContext}\n * @param localErrors - An array of {@link ErrorMessages | ErrorMessages} to set on this node\n * @param childErrors - An object of name of {@link ErrorMessages | ErrorMessages} to set on children.\n *\n * @internal\n */\nfunction setErrors(\n  node: FormKitNode,\n  _context: FormKitContext,\n  localErrors: ErrorMessages,\n  childErrors?: ErrorMessages\n) {\n  const sourceKey = `${node.name}-set`\n  const errors = node.hook.setErrors.dispatch({ localErrors, childErrors })\n  createMessages(node, errors.localErrors, errors.childErrors).forEach(\n    (errors) => {\n      node.store.apply(errors, (message) => message.meta.source === sourceKey)\n    }\n  )\n  return node\n}\n\n/**\n * Clears errors on the node and optionally its children.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param _context - A {@link FormKitContext | FormKitContext}\n * @param clearChildErrors - A boolean to clear children error or not.\n * @param sourceKey - The source key string to reset.\n *\n * @internal\n */\nfunction clearErrors(\n  node: FormKitNode,\n  _context: FormKitContext,\n  clearChildErrors = true,\n  sourceKey?: string\n) {\n  // Clear all local errors:\n  node.store.filter((m) => {\n    return !(sourceKey === undefined || m.meta.source === sourceKey)\n  }, 'error')\n  if (clearChildErrors) {\n    sourceKey = sourceKey || `${node.name}-set`\n    node.walk((child) => {\n      child.store.filter((message) => {\n        return !(\n          message.type === 'error' &&\n          message.meta &&\n          message.meta.source === sourceKey\n        )\n      })\n    })\n  }\n  return node\n}\n\n/**\n * Create props based on initial values\n *\n * @param initial - An initial value to be transformed\n *\n * @internal\n */\nfunction createProps(initial: unknown) {\n  const props: Record<PropertyKey, any> = {\n    initial: typeof initial === 'object' ? cloneAny(initial) : initial,\n  }\n  let node: FormKitNode\n  let isEmitting = true\n  let propDefs: Record<PropertyKey, FormKitPseudoProp> = {}\n  return new Proxy(props, {\n    get(...args) {\n      const [_t, prop] = args\n      let val\n      if (has(props, prop)) {\n        val = Reflect.get(...args)\n        if (propDefs[prop]?.boolean) val = boolGetter(val)\n      } else if (\n        node &&\n        typeof prop === 'string' &&\n        node.config[prop] !== undefined\n      ) {\n        val = node.config[prop]\n        // If we are getting the merge strategy for an input, only retrieve this\n        // actual node’s merge strategy.\n        if (\n          prop === 'mergeStrategy' &&\n          node?.type === 'input' &&\n          isRecord(val) &&\n          node.name in val\n        ) {\n          val = val[node.name]\n        }\n      } else {\n        // default or undefined\n        val = propDefs[prop]?.default\n      }\n      const getter = propDefs[prop]?.getter\n      if (propDefs[prop]?.boolean) val = !!val\n      return getter ? getter(val, node) : val\n    },\n    set(target, property, originalValue, receiver) {\n      if (property === '_n') {\n        node = originalValue\n        return true\n      }\n      if (property === '_emit') {\n        isEmitting = originalValue\n        return true\n      }\n      // eslint-disable-next-line prefer-const\n      let { prop, value } = node.hook.prop.dispatch({\n        prop: property,\n        value: originalValue,\n      })\n      const setter = propDefs[prop]?.setter\n      value = setter ? setter(value, node) : value\n      // Typescript compiler cannot handle a symbol index, even though js can:\n      if (\n        !eq(props[prop as string], value, false) ||\n        typeof value === 'object'\n      ) {\n        const didSet = Reflect.set(target, prop, value, receiver)\n        if (prop === '__propDefs') propDefs = toPropsObj(value)\n        if (isEmitting) {\n          node.emit('prop', { prop, value })\n          if (typeof prop === 'string') node.emit(`prop:${prop}`, value)\n        }\n        return didSet\n      }\n      return true\n    },\n  })\n}\n\n/**\n * Applies a new trap to the FormKitNode allowing plugins to extend the\n * base functionality of a FormKitNode.\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param property - A string of the property name\n * @param trap - A {@link FormKitTrap | FormKitTrap}\n * @returns\n */\nfunction extend(\n  node: FormKitNode,\n  context: FormKitContext,\n  property: string,\n  trap: FormKitTrap\n) {\n  context.traps.set(property, trap)\n  return node\n}\n\n/**\n * A cheap function that iterates over all plugins and stops once node.define\n * is called.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param plugins - An array of {@link FormKitPlugin | FormKitPlugin}\n *\n * @internal\n */\nfunction findDefinition(node: FormKitNode, plugins: Set<FormKitPlugin>): void {\n  // If the definition is already there, force call to define.\n  if (node.props.definition) return node.define(node.props.definition)\n  for (const plugin of plugins) {\n    if (node.props.definition) return\n    if (typeof plugin.library === 'function') {\n      plugin.library(node)\n    }\n  }\n}\n\n/**\n * Create a new context object for our a FormKit node, given default information\n *\n * @param options - An options object of {@link FormKitOptions | FormKitOptions} to override the defaults.\n *\n * @returns A {@link FormKitContext | FormKitContext}\n *\n * @internal\n */\nfunction createContext(options: FormKitOptions): FormKitContext {\n  const value = createValue(options)\n  const config = createConfig(options.config || {}, options.parent)\n  return {\n    _d: 0,\n    _e: createEmitter(),\n    uid: Symbol(),\n    _resolve: false,\n    _tmo: false,\n    _value: value,\n    children: dedupe(options.children || []),\n    config,\n    hook: createHooks(),\n    isCreated: false,\n    isSettled: true,\n    ledger: createLedger(),\n    name: createName(options),\n    parent: options.parent || null,\n    plugins: new Set<FormKitPlugin>(),\n    props: createProps(value),\n    settled: Promise.resolve(value),\n    store: createStore(true),\n    sync: options.sync || false,\n    traps: createTraps(),\n    type: options.type || 'input',\n    value,\n  }\n}\n\n/**\n * Initialize a node object's internal properties.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param options - An options object of {@link FormKitOptions | FormKitOptions} to override the defaults.\n *\n * @returns A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction nodeInit<V>(\n  node: FormKitNode,\n  options: FormKitOptions\n): FormKitNode<V> {\n  const hasInitialId = options.props?.id\n  if (!hasInitialId) delete options.props?.id\n  // Set the internal node on the props, config, ledger and store\n  node.ledger.init((node.store._n = node.props._n = node.config._n = node))\n  // Apply given in options to the node.\n  node.props._emit = false\n  // Sets the initial props and initial ID if not provided.\n  Object.assign(\n    node.props,\n    hasInitialId ? {} : { id: `input_${idCount++}` },\n    options.props ?? {}\n  )\n  node.props._emit = true\n  // Attempt to find a definition from the pre-existing plugins.\n  findDefinition(\n    node,\n    new Set([\n      ...(options.plugins || []),\n      ...(node.parent ? node.parent.plugins : []),\n    ])\n  )\n  // Then we apply each plugin's root code, we do this with an explicit loop\n  // for that ity-bitty performance bump.\n  if (options.plugins) {\n    for (const plugin of options.plugins) {\n      use(node, node._c, plugin, true, false)\n    }\n  }\n  // Apply the parent to each child.\n  node.each((child) => node.add(child))\n  // If the node has a parent, ensure it's properly nested bi-directionally.\n  if (node.parent) node.parent.add(node, options.index)\n  // Inputs are leafs, and cannot have children\n  if (node.type === 'input' && node.children.length) error(100, node)\n  // Apply the input hook to the initial value.\n  input(node, node._c, node._value, false)\n  // Release the store buffer\n  node.store.release()\n  // Register the node globally if someone explicitly gave it an id\n  if (hasInitialId) register(node)\n  // Our node is finally ready, emit it to the world\n  node.emit('created', node)\n  node.isCreated = true\n  return node as FormKitNode<V>\n}\n\n/**\n * Creates a placeholder node that can be used to hold a place in a the children\n * array until the actual node is created.\n * @param options - FormKitOptions\n * @internal\n */\nexport function createPlaceholder(\n  options?: FormKitOptions & { name?: string }\n): FormKitPlaceholderNode {\n  return {\n    __FKP: true,\n    uid: Symbol(),\n    name: options?.name ?? `p_${nameCount++}`,\n    value: options?.value ?? null,\n    _value: options?.value ?? null,\n    type: options?.type ?? 'input',\n    props: {},\n    use: () => {\n      // noop\n    },\n    input(value: unknown) {\n      this._value = value\n      this.value = value\n      return Promise.resolve()\n    },\n    isSettled: true,\n  }\n}\n\n/**\n * Determines if a node is a placeholder node.\n * @param node - A {@link FormKitNode | FormKitNode}\n * @returns\n * @public\n */\nexport function isPlaceholder(\n  node: FormKitNode | FormKitPlaceholderNode\n): node is FormKitPlaceholderNode {\n  return '__FKP' in node\n}\n\n/**\n * Creates a new instance of a FormKit Node. Nodes are the atomic unit of a FormKit graph.\n *\n * @example\n *\n * ```javascript\n * import { createNode } from '@formkit/core'\n *\n * const input = createNode({\n *   type: 'input', // defaults to 'input' if not specified\n *   value: 'hello node world',\n * })\n *\n * console.log(input.value)\n * // 'hello node world'\n * ```\n *\n * @param options - An options object of {@link FormKitOptions | FormKitOptions} to override the defaults.\n *\n * @returns A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport function createNode<V = unknown>(\n  options?: FormKitOptions\n): FormKitNode<V> {\n  const ops = options || {}\n  const context = createContext(ops) as FormKitContext\n  // Note: The typing for the proxy object cannot be fully modeled, thus we are\n  // force-typing to a FormKitNode. See:\n  // https://github.com/microsoft/TypeScript/issues/28067\n  const node = new Proxy(context, {\n    get(...args) {\n      const [, property] = args\n      if (property === '__FKNode__') return true\n      const trap = context.traps.get(property)\n      if (trap && trap.get) return trap.get(node, context)\n      return Reflect.get(...args)\n    },\n    set(...args) {\n      const [, property, value] = args\n      const trap = context.traps.get(property)\n      if (trap && trap.set) return trap.set(node, context, property, value)\n      return Reflect.set(...args)\n    },\n  }) as unknown as FormKitNode\n\n  return nodeInit(node, ops)\n}\n", "import { token } from '@formkit/utils'\nimport { FormKitContext, FormKitNode, isNode } from './node'\n\n/**\n * Event listener functions definition.\n *\n * @public\n */\nexport interface FormKitEventListener {\n  (event: FormKitEvent): void\n  receipt?: string\n}\n\n/**\n * The internal structure of a FormKitEvent.\n *\n * @public\n */\nexport interface FormKitEvent {\n  payload: any\n  name: string\n  bubble: boolean\n  origin: FormKitNode\n  meta?: Record<string, unknown>\n}\n\n/**\n * Event listeners are wrapped in this object before being stored.\n *\n * @internal\n */\nexport interface FormKitEventListenerWrapper {\n  event: string\n  listener: FormKitEventListener\n  modifiers: string[]\n  receipt: string\n}\n\n/**\n * The FormKitEventEmitter definition.\n *\n * @public\n */\nexport interface FormKitEventEmitter {\n  (node: FormKitNode, event: FormKitEvent): void\n  on: (\n    eventName: string,\n    listener: FormKitEventListener,\n    pos?: 'push' | 'unshift'\n  ) => string\n  off: (receipt: string) => void\n  pause: (node?: FormKitNode) => void\n  play: (node?: FormKitNode) => void\n  flush: () => void\n}\n\n/**\n * Creates a new event emitter, each node uses one of these to allow it to emit\n * events to local listeners and tree listeners.\n *\n * @returns FormKitEventEmitter\n *\n * @internal\n */\nexport function createEmitter(): FormKitEventEmitter {\n  const listeners = new Map<string, FormKitEventListenerWrapper[]>()\n  const receipts = new Map<string, string[]>()\n  let buffer: undefined | Map<string, [FormKitNode, FormKitEvent]> = undefined\n\n  const emitter = (node: FormKitNode, event: FormKitEvent) => {\n    if (buffer) {\n      buffer.set(event.name, [node, event])\n      return\n    }\n    if (listeners.has(event.name)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      listeners.get(event.name)!.forEach((wrapper) => {\n        if (event.origin === node || wrapper.modifiers.includes('deep')) {\n          wrapper.listener(event)\n        }\n      })\n    }\n    if (event.bubble) {\n      node.bubble(event)\n    }\n  }\n\n  /**\n   * Completely remove all listeners and receipts and buffers from the emitter.\n   */\n  emitter.flush = () => {\n    listeners.clear()\n    receipts.clear()\n    buffer?.clear()\n  }\n\n  /**\n   * Add an event listener\n   *\n   * @param eventName - The name of the event to listen to\n   * @param listener - The callback\n   * @param pos - The position to add the listener in, can be either 'push' or 'unshift'\n   *\n   * @returns string\n   *\n   * @internal\n   */\n  emitter.on = (\n    eventName: string,\n    listener: FormKitEventListener,\n    pos: 'push' | 'unshift' = 'push'\n  ) => {\n    if (true && pos !== 'push' && pos !== 'unshift') {\n      throw new Error('Event listeners can only be added to the top or bottom')\n    }\n    const [event, ...modifiers] = eventName.split('.')\n    const receipt = listener.receipt || token()\n    const wrapper: FormKitEventListenerWrapper = {\n      modifiers,\n      event,\n      listener,\n      receipt,\n    }\n    /* eslint-disable @typescript-eslint/no-non-null-assertion */\n    listeners.has(event)\n      ? listeners.get(event)![pos](wrapper)\n      : listeners.set(event, [wrapper])\n    receipts.has(receipt)\n      ? receipts.get(receipt)![pos](event)\n      : receipts.set(receipt, [event])\n    /* eslint-enable @typescript-eslint/no-non-null-assertion */\n    return receipt\n  }\n\n  /**\n   * Remove an event listener\n   *\n   * @param listenerOrReceipt - Either a receipt or the callback function.\n   *\n   * @internal\n   */\n  emitter.off = (receipt: string) => {\n    if (receipts.has(receipt)) {\n      receipts.get(receipt)?.forEach((event) => {\n        const eventListeners = listeners.get(event)\n        if (Array.isArray(eventListeners)) {\n          listeners.set(\n            event,\n            eventListeners.filter((wrapper) => wrapper.receipt !== receipt)\n          )\n        }\n      })\n      receipts.delete(receipt)\n    }\n  }\n\n  /**\n   * Pause emitting values. Any events emitted while paused will not be emitted\n   * but rather \"stored\" — and whichever events are emitted last will be output.\n   * For example:\n   * pause()\n   * emit('foo', 1)\n   * emit('foo', 2)\n   * emit('bar', 3)\n   * emit('bar', 4)\n   * play()\n   * // would result in\n   * emit('foo', 2)\n   * emit('bar', 4)\n   * Optionally pauses all children as well.\n   *\n   * @param node - A node to pause all children on.\n   *\n   * @internal\n   */\n  emitter.pause = (node?: FormKitNode) => {\n    if (!buffer) buffer = new Map()\n    if (node) {\n      node.walk((child) => child._e.pause())\n    }\n  }\n\n  /**\n   * Release the current event buffer.\n   *\n   * @param node - A node to unpause all children on.\n   *\n   * @internal\n   */\n  emitter.play = (node?: FormKitNode) => {\n    if (!buffer) return\n    const events = buffer\n    buffer = undefined\n    events.forEach(([node, event]) => emitter(node, event))\n    if (node) {\n      node.walk((child) => child._e.play())\n    }\n  }\n\n  return emitter\n}\n\n/**\n * Emit an event from this node.\n *\n * @param node - The node that is emitting\n * @param context - The context of that node\n * @param name - The name of the event\n * @param payload - The payload to emit\n *\n * @returns FormKitNode\n *\n * @internal\n */\nexport function emit(\n  node: FormKitNode,\n  context: FormKitContext,\n  name: string,\n  payload?: any, // eslint-disable-line @typescript-eslint/explicit-module-boundary-types,\n  bubble = true,\n  meta?: Record<string, unknown>\n): FormKitNode {\n  context._e(node, {\n    payload,\n    name,\n    bubble,\n    origin: node,\n    meta,\n  })\n  return node\n}\n\n/**\n * Send an event from the given node up it's ancestor tree.\n *\n * @param node -\n * @param _context -\n * @param event -\n *\n * @internal\n */\nexport function bubble(\n  node: FormKitNode,\n  _context: FormKitContext,\n  event: FormKitEvent\n): FormKitNode {\n  if (isNode(node.parent)) {\n    node.parent._e(node.parent, event)\n  }\n  return node\n}\n\n/**\n * Adds an event listener to the node for a specific event. The event name is a\n * simple string matching the name of the event to listen to. It can optionally\n * include modifiers like eventName.deep\n *\n * @param node -\n * @param context -\n * @param name -\n * @param listener -\n *\n * @returns FormKitNode\n *\n * @internal\n */\nexport function on(\n  _node: FormKitNode,\n  context: FormKitContext,\n  name: string,\n  listener: FormKitEventListener,\n  pos?: 'push' | 'unshift'\n): string {\n  return context._e.on(name, listener, pos)\n}\n\n/**\n * Removes an event listener from a node by the returned receipt from .on().\n *\n * @param node - The node to remote the listener from\n * @param context - The context to remove\n * @param receipt - The receipt returned by .on()\n *\n * @returns FormKitNode\n *\n * @internal\n */\nexport function off(\n  node: FormKitNode,\n  context: FormKitContext,\n  receipt: string\n): FormKitNode {\n  context._e.off(receipt)\n  return node\n}\n", "import createDispatcher from './dispatcher'\n\n/**\n * Describes the data passing through the error and warning handlers.\n *\n * @public\n */\nexport interface FormKitHandlerPayload {\n  code: number\n  data: any\n  message?: string\n}\n\n/**\n * FormKit's global error handler.\n *\n * @public\n */\nexport const errorHandler = createDispatcher<FormKitHandlerPayload>()\nerrorHandler((error, next) => {\n  if (!error.message) error.message = String(`E${error.code}`)\n  return next(error)\n})\n\n/**\n * FormKit's global warning handler.\n *\n * @public\n */\nexport const warningHandler = createDispatcher<FormKitHandlerPayload>()\nwarningHandler((warning, next) => {\n  if (!warning.message) warning.message = String(`W${warning.code}`)\n  const result = next(warning)\n  if (console && typeof console.warn === 'function')\n    console.warn(result.message)\n  return result\n})\n\n/**\n * Globally emits a warning.\n *\n * @param code - The integer warning code.\n * @param data - Usually an object of information to include.\n *\n * @public\n */\nexport function warn(code: number, data: any = {}): void {\n  warningHandler.dispatch({ code, data })\n}\n\n/**\n * Emits an error. Generally should result in an exception.\n *\n * @param code - The integer error code.\n * @param data - Usually an object of information to include.\n *\n * @public\n */\nexport function error(code: number, data: any = {}): never {\n  throw Error(errorHandler.dispatch({ code, data }).message)\n}\n", "import { FormKitNode, FormKitTextFragment } from './node'\nimport { error } from './errors'\nimport { has, token, slugify } from '@formkit/utils'\n\n/**\n * The structure of a core FormKitMessage. These messages are used to store\n * information about the state of a node.\n *\n * @public\n */\nexport interface FormKitMessageProps {\n  blocking: boolean\n  key: string\n  meta: FormKitMessageMeta\n  type: string\n  value?: string | number | boolean\n  visible: boolean\n}\n\n/**\n * A FormKit message is immutable, so all properties should be readonly.\n *\n * @public\n */\nexport type FormKitMessage = Readonly<FormKitMessageProps>\n\n/**\n * A registry of input messages that should be applied to children of the node\n * they are passed to — where the string key of the object is the address of\n * the node to apply the messages on and the value is the message itself.\n *\n * @public\n */\nexport interface FormKitInputMessages {\n  [address: string]: FormKitMessage[]\n}\n\n/**\n * Child messages that were not immediately applied due to the child not existing.\n *\n * @public\n */\nexport type ChildMessageBuffer = Map<\n  string,\n  Array<[FormKitMessage[], MessageClearer | undefined]>\n>\n\n/**\n * A string or function that allows clearing messages.\n *\n * @public\n */\nexport type MessageClearer = string | ((message: FormKitMessage) => boolean)\n\n/**\n * Messages have can have any arbitrary meta data attached to them.\n *\n * @public\n */\nexport interface FormKitMessageMeta {\n  [index: string]: any\n  /**\n   * If this property is set, then message producers (like formkit/i18n) should\n   * use this key instead of the message key as the lookup for the proper\n   * message to produce.\n   */\n  messageKey?: string\n  /**\n   * If this property is set on a message then only the values in this property\n   * will be passed as arguments to an i18n message localization function.\n   */\n  i18nArgs?: any[]\n}\n\n/**\n * Defines the actual store of messages.\n *\n * @public\n */\nexport interface FormKitMessageStore {\n  [index: string]: FormKitMessage\n}\n\n/**\n * The message store contains all of the messages that pertain to a given node.\n *\n * @public\n */\nexport type FormKitStore = FormKitMessageStore & {\n  // owner node\n  _n: FormKitNode\n  // buffer array\n  _b: Array<[messages: FormKitMessage[], clear?: MessageClearer]>\n  // missed assignments map\n  _m: ChildMessageBuffer\n  // missed message listener store\n  _r?: string\n  // message buffer\n  buffer: boolean\n} & FormKitStoreTraps\n\n/**\n * The available traps on the FormKit store.\n *\n * @public\n */\nexport interface FormKitStoreTraps {\n  apply: (\n    messages: Array<FormKitMessage> | FormKitInputMessages,\n    clear?: MessageClearer\n  ) => void\n  set: (message: FormKitMessageProps) => FormKitStore\n  remove: (key: string) => FormKitStore\n  filter: (\n    callback: (message: FormKitMessage) => boolean,\n    type?: string\n  ) => FormKitStore\n  reduce: <T>(\n    reducer: (accumulator: T, message: FormKitMessage) => T,\n    accumulator: T\n  ) => T\n  release: () => void\n  touch: () => void\n}\n\n/**\n * Creates a new FormKitMessage object.\n *\n * ```ts\n * // default:\n * {\n *   blocking: false,\n *   key: token(),\n *   meta: {},\n *   type: 'state',\n *   visible: true,\n * }\n * ```\n *\n * @param conf - An object of optional properties of {@link FormKitMessage | FormKitMessage}.\n * @param node - A {@link @formkit/node#FormKitNode | FormKitNode}.\n * @returns A {@link FormKitMessageProps | FormKitMessageProps}.\n *\n * @public\n */\nexport function /* #__PURE__ */ createMessage(\n  conf: Partial<FormKitMessage>,\n  node?: FormKitNode\n): FormKitMessageProps {\n  const m = {\n    blocking: false,\n    key: token(),\n    meta: {} as FormKitMessageMeta,\n    type: 'state',\n    visible: true,\n    ...conf,\n  }\n  if (node && m.value && m.meta.localize !== false) {\n    m.value = node.t(m as FormKitTextFragment)\n    m.meta.locale = node.config.locale\n  }\n  return m\n}\n\n/**\n * The available traps on the node's store.\n *\n * @internal\n */\nconst storeTraps: {\n  [k in keyof FormKitStoreTraps]: (...args: any[]) => unknown\n} = {\n  apply: applyMessages,\n  set: setMessage,\n  remove: removeMessage,\n  filter: filterMessages,\n  reduce: reduceMessages,\n  release: releaseBuffer,\n  touch: touchMessages,\n}\n\n/**\n * Creates a new FormKit message store.\n *\n * @internal\n */\nexport function createStore(_buffer = false): FormKitStore {\n  const messages: FormKitMessageStore = {}\n  let node: FormKitNode\n  let buffer = _buffer\n  let _b = [] as Array<[messages: FormKitMessage[], clear?: MessageClearer]>\n  const _m = new Map()\n  let _r: string | undefined = undefined\n  const store = new Proxy(messages, {\n    get(...args) {\n      const [_target, property] = args\n      if (property === 'buffer') return buffer\n      if (property === '_b') return _b\n      if (property === '_m') return _m\n      if (property === '_r') return _r\n      if (has(storeTraps, property)) {\n        return storeTraps[property as keyof FormKitStoreTraps].bind(\n          null,\n          messages,\n          store,\n          node\n        )\n      }\n      return Reflect.get(...args)\n    },\n    set(_t, prop, value) {\n      if (prop === '_n') {\n        node = value\n        if (_r === '__n') releaseMissed(node, store)\n        return true\n      } else if (prop === '_b') {\n        _b = value\n        return true\n      } else if (prop === 'buffer') {\n        buffer = value\n        return true\n      } else if (prop === '_r') {\n        _r = value\n        return true\n      }\n      error(101, node)\n      return false\n    },\n  }) as FormKitStore\n  return store\n}\n\n/**\n * Adds a new value to a FormKit message bag.\n *\n * @param messageStore - The message store itself\n * @param store - The store interface\n * @param node - The node this store belongs to\n * @param message - The message object\n *\n * @internal\n */\nfunction setMessage(\n  messageStore: FormKitMessageStore,\n  store: FormKitStore,\n  node: FormKitNode,\n  message: FormKitMessageProps\n): FormKitStore {\n  if (store.buffer) {\n    store._b.push([[message]])\n    return store\n  }\n  if (messageStore[message.key] !== message) {\n    if (typeof message.value === 'string' && message.meta.localize !== false) {\n      // Expose the value to translation\n      const previous = message.value\n      message.value = node.t(message as FormKitTextFragment)\n      if (message.value !== previous) {\n        message.meta.locale = node.props.locale\n      }\n    }\n    const e = `message-${has(messageStore, message.key) ? 'updated' : 'added'}`\n    messageStore[message.key] = Object.freeze(\n      node.hook.message.dispatch(message)\n    )\n    node.emit(e, message)\n  }\n  return store\n}\n\n/**\n * Run through each message in the store, and ensure it has been translated\n * to the proper language. This most frequently happens after a locale change.\n *\n * @internal\n */\nfunction touchMessages(\n  messageStore: FormKitMessageStore,\n  store: FormKitStore\n): void {\n  for (const key in messageStore) {\n    const message = { ...messageStore[key] }\n    store.set(message)\n  }\n}\n\n/**\n * Remove a message from the store.\n *\n * @param messageStore - The message store\n * @param store - The store interface\n * @param node - The node this store belongs to\n * @param key - The message key\n *\n * @returns FormKitStore\n *\n * @internal\n */\nfunction removeMessage(\n  messageStore: FormKitMessageStore,\n  store: FormKitStore,\n  node: FormKitNode,\n  key: string\n): FormKitStore {\n  if (has(messageStore, key)) {\n    const message = messageStore[key]\n    delete messageStore[key]\n    node.emit('message-removed', message)\n  }\n  if (store.buffer === true) {\n    store._b = store._b.filter((buffered) => {\n      buffered[0] = buffered[0].filter((m) => m.key !== key)\n      return buffered[1] || buffered[0].length\n    })\n  }\n  return store\n}\n\n/**\n * Iterates over all messages removing those that are no longer wanted.\n *\n * @param messageStore - The store itself\n * @param store - The store interface\n * @param node - The node to filter for\n * @param callback - A callback accepting a message and returning a boolean\n * @param type - Pre filtered by a given message type\n *\n * @internal\n */\nfunction filterMessages(\n  messageStore: FormKitMessageStore,\n  store: FormKitStore,\n  node: FormKitNode,\n  callback: (message: FormKitMessage) => boolean,\n  type: false | string\n) {\n  for (const key in messageStore) {\n    const message = messageStore[key]\n    if ((!type || message.type === type) && !callback(message)) {\n      removeMessage(messageStore, store, node, key)\n    }\n  }\n}\n\n/**\n * Reduce the message store to some other generic value.\n *\n * @param messageStore - The store itself\n * @param _store - Unused but curried — the store interface itself\n * @param _node - The node owner of this store\n * @param reducer - The callback that performs the reduction\n * @param accumulator - The initial value\n *\n * @returns\n *\n * @internal\n */\nfunction reduceMessages<T>(\n  messageStore: FormKitMessageStore,\n  _store: FormKitStore,\n  _node: FormKitNode,\n  reducer: (value: T, message: FormKitMessage) => T,\n  accumulator: T\n) {\n  for (const key in messageStore) {\n    const message = messageStore[key]\n    accumulator = reducer(accumulator, message)\n  }\n  return accumulator\n}\n\n/**\n * @param messageStore - The store itself\n * @param _store - Unused but curried — the store interface itself\n * @param node - The node owner of this store\n * @param messages - An array of FormKitMessages to apply to this input, or an object of messages to apply to children.\n *\n * @internal\n */\nexport function applyMessages(\n  _messageStore: FormKitMessageStore,\n  store: FormKitStore,\n  node: FormKitNode,\n  messages: Array<FormKitMessage> | FormKitInputMessages,\n  clear?: MessageClearer\n): void {\n  if (Array.isArray(messages)) {\n    if (store.buffer) {\n      store._b.push([messages, clear])\n      return\n    }\n    // In this case we are applying messages to this node’s store.\n    const applied = new Set(\n      messages.map((message) => {\n        store.set(message)\n        return message.key\n      })\n    )\n    // Remove any messages that were not part of the initial apply:\n    if (typeof clear === 'string') {\n      store.filter(\n        (message) => message.type !== clear || applied.has(message.key)\n      )\n    } else if (typeof clear === 'function') {\n      store.filter((message) => !clear(message) || applied.has(message.key))\n    }\n  } else {\n    for (const address in messages) {\n      const child = node.at(address)\n      if (child) {\n        child.store.apply(messages[address], clear)\n      } else {\n        missed(node, store, address, messages[address], clear)\n      }\n    }\n  }\n}\n\n/**\n * Error messages.\n *\n * @public\n */\nexport type ErrorMessages =\n  | string\n  | string[]\n  | Record<string, string | string[]>\n\n/**\n * Creates an array of message arrays from strings.\n *\n * @param node - FormKitNode\n * @param errors - Arrays or objects of form errors or input errors\n *\n * @internal\n */\nexport function createMessages(\n  node: FormKitNode,\n  ...errors: Array<ErrorMessages | undefined>\n): Array<FormKitMessage[] | Record<string, FormKitMessage[]>> {\n  const sourceKey = `${node.name}-set`\n  const make = (error: string) =>\n    /* #__PURE__ */ createMessage({\n      key: slugify(error),\n      type: 'error',\n      value: error,\n      meta: { source: sourceKey, autoClear: true },\n    })\n  return errors\n    .filter((m) => !!m)\n    .map((errorSet): FormKitMessage[] | Record<string, FormKitMessage[]> => {\n      if (typeof errorSet === 'string') errorSet = [errorSet]\n      if (Array.isArray(errorSet)) {\n        return errorSet.map((error) => make(error))\n      } else {\n        const errors: Record<string, FormKitMessage[]> = {}\n        for (const key in errorSet) {\n          if (Array.isArray(errorSet[key])) {\n            errors[key] = (errorSet[key] as string[]).map((error) =>\n              make(error)\n            )\n          } else {\n            errors[key] = [make(errorSet[key] as string)]\n          }\n        }\n        return errors\n      }\n    })\n}\n\n/**\n * @param store - The store to apply this missed applications.\n * @param address - The address that was missed (a node path that didn't yet exist)\n * @param messages - The messages that should have been applied.\n * @param clear - The clearing function (if any)\n *\n * @internal\n */\nfunction missed(\n  node: FormKitNode,\n  store: FormKitStore,\n  address: string,\n  messages: FormKitMessage[],\n  clear?: MessageClearer\n) {\n  const misses = store._m\n  if (!misses.has(address)) misses.set(address, [])\n  // The created receipt\n  if (!store._r) store._r = releaseMissed(node, store)\n  misses.get(address)?.push([messages, clear])\n}\n\n/**\n * Releases messages that were applied to a child via parent, but the child did\n * not exist. Once the child does exist, the created event for that child will\n * bubble to this point, and any stored applications will be applied serially.\n *\n * @param store - The store object.\n *\n * @internal\n */\nfunction releaseMissed(node: FormKitNode, store: FormKitStore): string {\n  return node.on(\n    'child.deep',\n    ({ payload: child }: { payload: FormKitNode }) => {\n      store._m.forEach((misses, address) => {\n        if (node.at(address) === child) {\n          misses.forEach(([messages, clear]) => {\n            child.store.apply(messages, clear)\n          })\n          store._m.delete(address)\n        }\n      })\n      // If all the stored misses were applied, remove the listener.\n      if (store._m.size === 0 && store._r) {\n        node.off(store._r)\n        store._r = undefined\n      }\n    }\n  )\n}\n\n/**\n * Iterates over all buffered messages and applies them in sequence.\n *\n * @param messageStore - The store itself\n * @param store - The store interface\n * @param node - The node to filter for\n *\n * @internal\n */\nfunction releaseBuffer(\n  _messageStore: FormKitMessageStore,\n  store: FormKitStore\n) {\n  store.buffer = false\n  store._b.forEach(([messages, clear]) => store.apply(messages, clear))\n  store._b = []\n}\n", "import { FormKitNode } from './node'\nimport { FormKitEvent } from './events'\nimport { FormKitMessage } from './store'\nimport { has } from '@formkit/utils'\n\n/**\n * The FormKit ledger, a general-purpose message counting service provided by\n * FormKit core for counting messages throughout a tree.\n *\n * @public\n */\nexport interface FormKitLedger {\n  count: (\n    name: string,\n    condition?: FormKitCounterCondition,\n    increment?: number\n  ) => Promise<void>\n  init: (node: FormKitNode) => void\n  merge: (child: FormKitNode) => void\n  settled: (name: string) => Promise<void>\n  unmerge: (child: FormKitNode) => void\n  value: (name: string) => number\n}\n\n/**\n * Ledger counters require a condition function that determines if a given\n * message applies to it or not.\n *\n * @public\n */\nexport interface FormKitCounterCondition {\n  (message: FormKitMessage): boolean\n}\n\n/**\n * The counter object used to perform instance counting within\n * a tree.\n *\n * @public\n */\nexport interface FormKitCounter {\n  condition: FormKitCounterCondition\n  count: number\n  name: string\n  node: FormKitNode\n  promise: Promise<void>\n  resolve: () => void\n}\n\n/**\n * The internal ledger store structure.\n *\n * @internal\n */\ninterface FormKitLedgerStore {\n  [index: string]: FormKitCounter\n}\n\n/**\n * Creates a new ledger for use on a single node's context.\n *\n * @internal\n */\nexport function createLedger(): FormKitLedger {\n  const ledger: FormKitLedgerStore = {}\n  let n: FormKitNode\n  return {\n    count: (...args) => createCounter(n, ledger, ...args),\n    init(node: FormKitNode) {\n      n = node\n      node.on('message-added.deep', add(ledger, 1))\n      node.on('message-removed.deep', add(ledger, -1))\n    },\n    merge: (child) => merge(n, ledger, child),\n    settled(counterName: string): Promise<void> {\n      return has(ledger, counterName)\n        ? ledger[counterName].promise\n        : Promise.resolve()\n    },\n    unmerge: (child) => merge(n, ledger, child, true),\n    value(counterName: string) {\n      return has(ledger, counterName) ? ledger[counterName].count : 0\n    },\n  }\n}\n\n/**\n * Creates a new counter object in the counting ledger.\n *\n * @param node - FormKitNode\n * @param ledger - The actual ledger storage object\n * @param counterName - The name of the counter, can be arbitrary\n * @param condition - The condition function (or string) that filters messages\n * @param increment - The increment value\n *\n * @internal\n */\nfunction createCounter(\n  node: FormKitNode,\n  ledger: FormKitLedgerStore,\n  counterName: string,\n  condition?: FormKitCounterCondition | string,\n  increment = 0\n): Promise<void> {\n  condition = parseCondition(condition || counterName)\n  if (!has(ledger, counterName)) {\n    const counter: FormKitCounter = {\n      condition,\n      count: 0,\n      name: counterName,\n      node,\n      promise: Promise.resolve(),\n      resolve: () => {}, // eslint-disable-line @typescript-eslint/no-empty-function\n    }\n    ledger[counterName] = counter\n    increment = node.store.reduce(\n      (sum, m) => sum + (counter.condition(m) as unknown as number) * 1,\n      increment\n    )\n    node.each((child) => {\n      child.ledger.count(counter.name, counter.condition)\n      increment += child.ledger.value(counter.name)\n    })\n  }\n  return count(ledger[counterName], increment).promise\n}\n\n/**\n * We parse the condition to allow flexibility in how counters are specified.\n *\n * @param condition - The condition that, if true, allows a message to change a counter's value\n *\n * @internal\n */\nfunction parseCondition(\n  condition: string | FormKitCounterCondition\n): FormKitCounterCondition {\n  if (typeof condition === 'function') {\n    return condition\n  }\n  return (m: FormKitMessage) => m.type === condition\n}\n\n/**\n * Perform a counting action on the a given counter object of the ledger.\n *\n * @param counter - A counter object\n * @param increment - The amount by which we are changing the count value\n *\n * @internal\n */\nfunction count(counter: FormKitCounter, increment: number): FormKitCounter {\n  const initial = counter.count\n  const post = counter.count + increment\n  counter.count = post\n  if (initial === 0 && post !== 0) {\n    counter.node.emit(`unsettled:${counter.name}`, counter.count, false)\n    counter.promise = new Promise((r) => (counter.resolve = r))\n  } else if (initial !== 0 && post === 0) {\n    counter.node.emit(`settled:${counter.name}`, counter.count, false)\n    counter.resolve()\n  }\n  counter.node.emit(`count:${counter.name}`, counter.count, false)\n  return counter\n}\n\n/**\n * Returns a function to be used as an event listener for message events.\n *\n * @param ledger - A ledger to operate on\n * @param delta - The amount to add or subtract\n *\n * @internal\n */\nfunction add(ledger: FormKitLedgerStore, delta: number) {\n  return (e: FormKitEvent) => {\n    for (const name in ledger) {\n      const counter = ledger[name]\n      if (counter.condition(e.payload)) {\n        count(counter, delta)\n      }\n    }\n  }\n}\n\n/**\n * Given a child node, add the parent node's counters to the child and then\n * rectify the upstream ledger counts. Generally used when attaching a child\n * to an already counted tree.\n *\n * @param parent - The parent that is \"receiving\" the child\n * @param ledger - The ledger object\n * @param child - The child (can be a subtree) that is being attached\n * @param remove - If the merge is removing instead of adding\n *\n * @internal\n */\nfunction merge(\n  parent: FormKitNode | null,\n  ledger: FormKitLedgerStore,\n  child: FormKitNode,\n  remove = false\n) {\n  const originalParent = parent\n  for (const key in ledger) {\n    const condition = ledger[key].condition\n    if (!remove) child.ledger.count(key, condition)\n    const increment = child.ledger.value(key) * (remove ? -1 : 1)\n    if (!parent) continue\n    do {\n      parent.ledger.count(key, condition, increment)\n      parent = parent.parent\n    } while (parent)\n    parent = originalParent\n  }\n}\n", "import { FormKitNode } from './node'\nimport { createEmitter, FormKitEventListener } from './events'\n\n/**\n * A global registry of nodes by their alias or name (if root).\n */\nconst registry: Map<string, FormKitNode> = new Map()\nconst reflected: Map<FormKitNode, string> = new Map()\n\n/**\n * An event emitter for registered/set/unset nodes\n */\nconst emit = createEmitter()\n/**\n * Receipts of listeners.\n */\nconst receipts: string[] = []\n\n/**\n * Registers a node to the registry _if_ the node is a root node, _or_ if the\n * node has an explicit node.props.alias. If these two things are not true,\n * then no node is registered (idempotent).\n *\n * @param node - A {@link FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport function register(node: FormKitNode): void {\n  if (node.props.id) {\n    registry.set(node.props.id, node)\n    reflected.set(node, node.props.id)\n    emit(node, {\n      payload: node,\n      name: node.props.id,\n      bubble: false,\n      origin: node,\n    })\n  }\n}\n\n/**\n * Deregister a node from the registry.\n *\n * @param node - A {@link FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport function deregister(node: FormKitNode): void {\n  if (reflected.has(node)) {\n    const id = reflected.get(node)! // eslint-disable-line @typescript-eslint/no-non-null-assertion\n    reflected.delete(node)\n    registry.delete(id)\n    emit(node, {\n      payload: null,\n      name: id,\n      bubble: false,\n      origin: node,\n    })\n  }\n}\n\n/**\n * Get a node by a particular id.\n *\n * @param id - Get a node by a given id.\n *\n * @returns A {@link FormKitNode | FormKitNode} or `undefined`.\n *\n * @public\n */\nexport function getNode<T = unknown>(id: string): FormKitNode<T> | undefined {\n  return registry.get(id) as FormKitNode<T> | undefined\n}\n\n/**\n * Resets the entire registry. Deregisters all nodes and removes all listeners.\n *\n * @public\n */\nexport function resetRegistry(): void {\n  registry.forEach((node) => {\n    deregister(node)\n  })\n  receipts.forEach((receipt) => emit.off(receipt))\n}\n\n/**\n * A way of watching changes in the global registry.\n *\n * @param id - A dot-syntax id where the node is located.\n * @param callback - A callback in the format of {@link FormKitEventListener | FormKitEventListener} to notify when the node is set or removed.\n *\n * @public\n */\nexport function watchRegistry(\n  id: string,\n  callback: FormKitEventListener\n): string {\n  // register a listener\n  const receipt = emit.on(id, callback)\n  receipts.push(receipt)\n  return receipt\n}\n\n/**\n * Stop watching the registry for a given receipt.\n * @param receipt - a receipt to stop watching\n */\nexport function stopWatch(receipt: string): void {\n  emit.off(receipt)\n}\n", "import { FormKitConfig, FormKitNode } from './node'\n\n/**\n * Applies a given config change to the node.\n *\n * @param node - The node to check for config change\n * @param prop - Checks if this property exists in the local config or props\n * @param value - The value to set\n *\n * @internal\n */\nexport function configChange(\n  node: FormKitNode,\n  prop: string,\n  value: unknown\n): boolean {\n  // When we return false, node.walk will not continue into that child.\n  let usingFallback = true\n  !(prop in node.config._t)\n    ? node.emit(`config:${prop}`, value, false)\n    : (usingFallback = false)\n\n  if (!(prop in node.props)) {\n    node.emit('prop', { prop, value })\n    node.emit(`prop:${prop}`, value)\n  }\n  return usingFallback\n}\n\n/**\n * Global configuration options.\n *\n * @public\n */\nexport type FormKitRootConfig = Partial<FormKitConfig> & {\n  _add: (node: FormKitNode) => void\n  _rm: (node: FormKitNode) => void\n}\n\n/**\n * Creates a new instance of a global configuration option. This object is\n * essentially just a FormKitOption object, but it can be used as the root for\n * FormKitConfig's proxy and retain event \"emitting\".\n *\n * @param options - An object of optional properties of {@link FormKitConfig | FormKitConfig}.\n *\n * @returns A {@link FormKitRootConfig | FormKitRootConfig}.\n *\n * @public\n */\nexport function createConfig(\n  options: Partial<FormKitConfig> = {}\n): FormKitRootConfig {\n  const nodes = new Set<FormKitNode>()\n  const target = {\n    ...options,\n    ...{\n      _add: (node: FormKitNode) => nodes.add(node),\n      _rm: (node: FormKitNode) => nodes.delete(node),\n    },\n  }\n  const rootConfig = new Proxy(target, {\n    set(t, prop, value, r) {\n      if (typeof prop === 'string') {\n        nodes.forEach((node) => configChange(node, prop, value))\n      }\n      return Reflect.set(t, prop, value, r)\n    },\n  })\n  return rootConfig\n}\n", "import { warn } from './errors'\n\n/**\n * Submits a FormKit form programmatically.\n *\n * @param id - The id of the form.\n *\n * @public\n */\nexport function submitForm(id: string, root?: ShadowRoot | Document): void {\n  const formElement = (root || document).getElementById(id)\n  if (formElement instanceof HTMLFormElement) {\n    const event = new Event('submit', { cancelable: true, bubbles: true })\n    formElement.dispatchEvent(event)\n    return\n  }\n  warn(151, id)\n}\n", "import { cloneAny, init, isObject, empty } from '@formkit/utils'\nimport { FormKitNode } from './node'\nimport { warn } from './errors'\nimport { getNode } from './registry'\n\n/**\n * Clear all state and error messages.\n *\n * @internal\n */\nfunction clearState(node: FormKitNode) {\n  const clear = (n: FormKitNode) => {\n    for (const key in n.store) {\n      const message = n.store[key]\n      if (\n        message.type === 'error' ||\n        (message.type === 'ui' && key === 'incomplete')\n      ) {\n        n.store.remove(key)\n      } else if (message.type === 'state') {\n        n.store.set({ ...message, value: false })\n      }\n    }\n  }\n  clear(node)\n  node.walk(clear)\n}\n\n/**\n * Resets an input to its \"initial\" value. If the input is a group or list it\n * resets all the children as well.\n *\n * @param id - The id of an input to reset.\n * @param resetTo - A value to reset the node to.\n *\n * @returns A {@link FormKitNode | FormKitNode} or `undefined`.\n *\n * @public\n */\nexport function reset(\n  id: string | FormKitNode,\n  resetTo?: unknown\n): FormKitNode | undefined {\n  const node = typeof id === 'string' ? getNode(id) : id\n  if (node) {\n    const initial = (n: FormKitNode) =>\n      cloneAny(n.props.initial) ||\n      (n.type === 'group' ? {} : n.type === 'list' ? [] : undefined)\n\n    // pause all events in this tree.\n    node._e.pause(node)\n    // Set it back to basics\n    const resetValue = cloneAny(resetTo)\n    if (resetTo && !empty(resetTo)) {\n      node.props.initial = isObject(resetValue) ? init(resetValue) : resetValue\n      node.props._init = node.props.initial\n    }\n    node.input(initial(node), false)\n\n    // Set children back to basics in case they were additive (had their own value for example)\n    node.walk((child) => {\n      // Skip resetting synced lists to default.\n      if (child.type === 'list' && child.sync) return\n      child.input(initial(child), false)\n    })\n    // Finally we need to lay any values back on top (if it is a group/list) since group values\n    // take precedence over child values.\n    node.input(\n      empty(resetValue) && resetValue ? resetValue : initial(node),\n      false\n    )\n\n    // If this is a deep reset, we need to make sure the \"initial\" state of all\n    // children are also reset. Fixes https://github.com/formkit/formkit/issues/791#issuecomment-1651213253\n    const isDeepReset =\n      node.type !== 'input' && resetTo && !empty(resetTo) && isObject(resetTo)\n    if (isDeepReset) {\n      node.walk((child) => {\n        child.props.initial = isObject(child.value)\n          ? init(child.value)\n          : child.value\n        child.props._init = child.props.initial\n      })\n    }\n    // release the events.\n    node._e.play(node)\n    clearState(node)\n    node.emit('reset', node)\n    return node\n  }\n  warn(152, id)\n  return\n}\n", "import { has } from '@formkit/utils'\n\n/**\n * The value being listed out. Can be an array, an object, or a number.\n *\n * @public\n */\nexport type FormKitListValue =\n  | string\n  | Record<string, any>\n  | Array<string | number | Record<string, any>>\n  | number\n\n/**\n * A full loop statement in tuple syntax. Can be read like \"foreach value, key? in list\".\n *\n * @public\n */\nexport type FormKitListStatement =\n  | [value: any, key: number | string, list: FormKitListValue]\n  | [value: any, list: FormKitListValue]\n\n/**\n * Meta attributes are not used when parsing the schema, but can be used to\n * create tooling.\n *\n * @public\n */\nexport type FormKitSchemaMeta = {\n  [key: string]:\n    | string\n    | number\n    | boolean\n    | undefined\n    | null\n    | CallableFunction\n    | FormKitSchemaMeta\n}\n\n/**\n * Properties available in all schema nodes.\n *\n * @public\n */\nexport interface FormKitSchemaProps {\n  children?: string | FormKitSchemaNode[] | FormKitSchemaCondition\n  key?: string\n  if?: string\n  for?: FormKitListStatement\n  bind?: string\n  meta?: FormKitSchemaMeta\n}\n\n/**\n * Properties available when using a DOM node.\n *\n * @public\n */\nexport type FormKitSchemaDOMNode = {\n  $el: string | null\n  attrs?: FormKitSchemaAttributes\n} & FormKitSchemaProps\n\n/**\n * A simple text node.\n *\n * @public\n */\nexport type FormKitSchemaTextNode = string\n\n/**\n * The possible value types of attributes (in the schema).\n *\n * @public\n */\nexport type FormKitAttributeValue =\n  | string\n  | number\n  | boolean\n  | undefined\n  | FormKitSchemaAttributes\n  | FormKitSchemaAttributesCondition\n\n/**\n * Conditions nested inside attribute declarations.\n *\n * @public\n */\nexport interface FormKitSchemaAttributesCondition {\n  if: string\n  then: FormKitAttributeValue\n  else?: FormKitAttributeValue\n}\n\n/**\n * DOM attributes are simple string dictionaries.\n *\n * @public\n */\nexport type FormKitSchemaAttributes =\n  | {\n      [index: string]: FormKitAttributeValue\n    }\n  | null\n  | FormKitSchemaAttributesCondition\n\n/**\n * Properties available when defining a generic non-FormKit component.\n *\n * @public\n */\nexport type FormKitSchemaComponent = {\n  $cmp: string\n  props?: Record<string, any>\n} & FormKitSchemaProps\n\n/**\n * Syntactic sugar for a FormKitSchemaComponent node that uses FormKit.\n *\n * @public\n */\nexport type FormKitSchemaFormKit = {\n  $formkit: string\n} & Record<string, any> &\n  FormKitSchemaProps\n\n/**\n * A schema node that determines _which_ content to render.\n *\n * @public\n */\nexport type FormKitSchemaCondition = {\n  if: string\n  then: FormKitSchemaNode | FormKitSchemaNode[]\n  else?: FormKitSchemaNode | FormKitSchemaNode[]\n}\n\n/**\n * The context that is passed from one schema render to the next.\n *\n * @public\n */\nexport interface FormKitSchemaContext {\n  [index: string]: any\n  __FK_SCP: Map<symbol, Record<string, any>>\n}\n\n/**\n * Properties available then defining a schema node.\n *\n * @public\n */\nexport type FormKitSchemaNode =\n  | FormKitSchemaDOMNode\n  | FormKitSchemaComponent\n  | FormKitSchemaTextNode\n  | FormKitSchemaCondition\n  | FormKitSchemaFormKit\n\n/**\n * An entire schema object or subtree from any entry point. Can be a single\n * node, an array of nodes, or a conditional. This is the type that is passed to\n * the FormKitSchema constructor.\n *\n * @public\n */\nexport type FormKitSchemaDefinition =\n  | FormKitSchemaNode\n  | FormKitSchemaNode[]\n  | FormKitSchemaCondition\n\n/**\n * Definition for a function that can extend a given schema node.\n *\n * @public\n */\nexport interface FormKitSchemaComposable {\n  (\n    extendWith?: Partial<FormKitSchemaNode>,\n    children?: string | FormKitSchemaNode[] | FormKitSchemaCondition,\n    ...args: any[]\n  ): FormKitSchemaNode\n}\n\n/**\n * The shape of the schema definition overrides/extensions.\n * @public\n */\nexport type FormKitSectionsSchema = Record<\n  string,\n  Partial<FormKitSchemaNode> | FormKitSchemaCondition | null\n>\n\n/**\n * Defines a function that allows selectively overriding a given schema.\n *\n * @public\n */\nexport interface FormKitExtendableSchemaRoot {\n  (extensions: FormKitSectionsSchema): FormKitSchemaDefinition\n  memoKey?: string\n}\n\n/**\n * Type narrow that a node is a DOM node.\n *\n * @param node - A schema node to check\n *\n * @returns `boolean`\n *\n * @public\n */\nexport function isDOM(\n  node: string | Record<PropertyKey, any>\n): node is FormKitSchemaDOMNode {\n  return typeof node !== 'string' && has(node, '$el')\n}\n\n/**\n * Type narrow that a node is a DOM node.\n *\n * @param node - A schema node to check.\n *\n * @returns `boolean`\n *\n * @public\n */\nexport function isComponent(\n  node: string | Record<PropertyKey, any>\n): node is FormKitSchemaComponent {\n  return typeof node !== 'string' && has(node, '$cmp')\n}\n\n/**\n * Determines if a node is conditionally rendered or not.\n *\n * @param node - A schema node to check.\n *\n * @returns `boolean`\n *\n * @public\n */\nexport function isConditional(\n  node: FormKitSchemaNode\n): node is FormKitSchemaCondition\n\n/**\n * Determines if an attribute is a conditional.\n *\n * @param node - A schema node to check.\n *\n * @returns `boolean`\n *\n * @public\n */\nexport function isConditional(\n  node: FormKitSchemaAttributesCondition | FormKitSchemaAttributes\n): node is FormKitSchemaAttributesCondition\n\n/**\n * Root declaration.\n *\n * @param node - An object to check.\n */\nexport function isConditional(\n  node:\n    | FormKitSchemaNode\n    | FormKitSchemaAttributesCondition\n    | FormKitSchemaAttributes\n): node is FormKitSchemaNode | FormKitSchemaAttributesCondition {\n  if (!node || typeof node === 'string') return false\n  return has(node, 'if') && has(node, 'then')\n}\n\n/**\n * Determines if the node is syntactic sugar or not.\n *\n * @param node - A schema node to check.\n *\n * @returns `boolean`\n *\n * @public\n */\nexport function isSugar(node: FormKitSchemaNode): node is FormKitSchemaFormKit {\n  return typeof node !== 'string' && '$formkit' in node\n}\n\n/**\n * Converts syntactic sugar nodes to standard nodes.\n *\n * @param node - A node to covert.\n *\n * @returns A {@link FormKitSchemaNode | FormKitSchemaNode} without the properties of {@link FormKitSchemaFormKit | FormKitSchemaFormKit}.\n *\n * @public\n */\nexport function sugar<T extends FormKitSchemaNode>(\n  node: T\n): Exclude<FormKitSchemaNode, string | FormKitSchemaFormKit> {\n  if (typeof node === 'string') {\n    return {\n      $el: 'text',\n      children: node,\n    }\n  }\n  if (isSugar(node)) {\n    const {\n      $formkit: type,\n      for: iterator,\n      if: condition,\n      children,\n      bind,\n      ...props\n    } = node as FormKitSchemaFormKit\n    return Object.assign(\n      {\n        $cmp: 'FormKit',\n        props: { ...props, type },\n      },\n      condition ? { if: condition } : {},\n      iterator ? { for: iterator } : {},\n      children ? { children } : {},\n      bind ? { bind } : {}\n    )\n  }\n  return node\n}\n", "import { isQuotedString, rmEscapes, parseArgs, getAt } from '@formkit/utils'\nimport { warn, error } from './errors'\n\n/**\n * Tokens are strings that map to functions.\n *\n * @internal\n */\ninterface FormKitTokens {\n  [index: string]: (...args: any[]) => any\n}\n/**\n * The compiler output, a function that adds the required tokens.\n *\n * @public\n */\nexport interface FormKitCompilerOutput {\n  (tokens?: Record<string, any>): boolean | number | string\n  provide: FormKitCompilerProvider\n}\n\n/**\n * A function that accepts a callback with a token as the only argument, and\n * must return a function that provides the true value of the token.\n *\n * @public\n */\nexport type FormKitCompilerProvider = (\n  callback: (requirements: string[]) => Record<string, () => any>\n) => FormKitCompilerOutput\n\n/**\n * The operand is a value that can be used in a logical operation.\n *\n * @internal\n */\ntype Operand =\n  | string\n  | number\n  | boolean\n  | undefined\n  | ((...args: any[]) => boolean | number | string | CallableFunction)\n\n/**\n * Logical operations are always a left/right fn\n *\n * @internal\n */\ntype LogicOperator = (\n  l: any,\n  r: any,\n  t?: Record<string, any>,\n  tt?: any\n) => boolean | number | string\n\n/**\n * A set of logical operators used for parsing string logic.\n *\n * @internal\n */\ninterface LogicOperators {\n  [index: string]: LogicOperator\n}\n\n/**\n * Describes a registry of operators that occur at different periods during\n * the order of operations. Typically this is:\n * 0: Boolean\n * 1: Comparison\n * 2: Arithmetic\n *\n * @internal\n */\ntype OperatorRegistry = LogicOperators[]\n\n/**\n * Compiles a logical string like `\"a != z || b == c\"` into a single function.\n * The return value is an object with a \"provide\" method that iterates over all\n * requirement tokens to use as replacements.\n *\n * @example\n *\n * ```typescript\n * let name = {\n *   value: 'jon'\n * }\n * const condition = compile(\"$name == 'bob'\").provide((token) => {\n *  return () => name.value // must return a function!\n * })\n *\n * condition() // false\n * ```\n *\n * @param expr - A string to compile.\n *\n * @returns A {@link FormKitCompilerOutput | FormKitCompilerOutput}.\n *\n * @public\n */\nexport function compile(expr: string): FormKitCompilerOutput {\n  /**\n   * These tokens are replacements used in evaluating a given condition.\n   */\n  // const tokens: FormKitTokens = {}\n\n  /**\n   * The value of the provide() callback. Used for late binding.\n   */\n  let provideTokens: (requirements: string[]) => Record<string, () => any>\n\n  /**\n   * These are token requirements like \"$name.value\" that are need to fulfill\n   * a given condition call.\n   */\n  const requirements = new Set<string>()\n\n  /**\n   * Expands the current value if it is a function.\n   * @param operand - A left or right hand operand\n   * @returns\n   */\n  const x = function expand(operand: any, tokens?: Record<string, any>): any {\n    return typeof operand === 'function' ? operand(tokens) : operand\n  }\n\n  /**\n   * Comprehensive list of operators. This list MUST be\n   * ordered by the length of the operator characters in descending order.\n   */\n  const operatorRegistry: OperatorRegistry = [\n    {\n      '&&': (l, r, t) => x(l, t) && x(r, t),\n      '||': (l, r, t) => x(l, t) || x(r, t),\n    },\n    {\n      '===': (l, r, t) => !!(x(l, t) === x(r, t)),\n      '!==': (l, r, t) => !!(x(l, t) !== x(r, t)),\n      '==': (l, r, t) => !!(x(l, t) == x(r, t)),\n      '!=': (l, r, t) => !!(x(l, t) != x(r, t)),\n      '>=': (l, r, t) => !!(x(l, t) >= x(r, t)),\n      '<=': (l, r, t) => !!(x(l, t) <= x(r, t)),\n      '>': (l, r, t) => !!(x(l, t) > x(r, t)),\n      '<': (l, r, t) => !!(x(l, t) < x(r, t)),\n    },\n    {\n      '+': (l, r, t) => x(l, t) + x(r, t),\n      '-': (l, r, t) => x(l, t) - x(r, t),\n    },\n    {\n      '*': (l, r, t) => x(l, t) * x(r, t),\n      '/': (l, r, t) => x(l, t) / x(r, t),\n      '%': (l, r, t) => x(l, t) % x(r, t),\n    },\n  ]\n\n  /**\n   * A full list of all operator symbols.\n   */\n  const operatorSymbols = operatorRegistry.reduce((s, g) => {\n    return s.concat(Object.keys(g))\n  }, [] as string[])\n\n  /**\n   * An array of the first character of each operator.\n   */\n  const operatorChars = new Set(operatorSymbols.map((key) => key.charAt(0)))\n\n  /**\n   * Determines if the current character is the start of an operator symbol, if it\n   * is, it returns that symbol.\n   * @param symbols - An array of symbols that are considered operators\n   * @param char - The current character being operated on\n   * @param p - The position of the pointer\n   * @param expression - The full string expression\n   * @returns\n   */\n  function getOp(\n    symbols: string[],\n    char: string,\n    p: number,\n    expression: string\n  ): false | undefined | string {\n    const candidates = symbols.filter((s) => s.startsWith(char))\n    if (!candidates.length) return false\n    return candidates.find((symbol) => {\n      if (expression.length >= p + symbol.length) {\n        const nextChars = expression.substring(p, p + symbol.length)\n        if (nextChars === symbol) return symbol\n      }\n      return false\n    })\n  }\n\n  /**\n   * Determines the step number of the right or left hand operator.\n   * @param p - The position of the pointer\n   * @param expression - The full string expression\n   * @param direction - 1 = right, 0 = left\n   */\n  function getStep(p: number, expression: string, direction = 1): number {\n    let next = direction\n      ? expression.substring(p + 1).trim()\n      : expression.substring(0, p).trim()\n    if (!next.length) return -1\n    if (!direction) {\n      // left hand direction could include a function name we need to remove\n      const reversed = next.split('').reverse()\n      const start = reversed.findIndex((char) => operatorChars.has(char))\n      next = reversed.slice(start).join('')\n    }\n    const char = next[0]\n    return operatorRegistry.findIndex((operators) => {\n      const symbols = Object.keys(operators)\n      return !!getOp(symbols, char, 0, next)\n    })\n  }\n\n  /**\n   * Extracts a tail call. For example:\n   * ```\n   * $foo().bar(baz) + 7\n   * ```\n   * Would extract \"bar(baz)\" and return p of 15 (after the (baz)).\n   *\n   * @param p - The position of a closing parenthetical.\n   * @param expression - The full expression being parsed.\n   */\n  function getTail(pos: number, expression: string): [tail: string, p: number] {\n    let tail = ''\n    const length = expression.length\n    let depth = 0\n    for (let p = pos; p < length; p++) {\n      const char = expression.charAt(p)\n      if (char === '(') {\n        depth++\n      } else if (char === ')') {\n        depth--\n      } else if (depth === 0 && char === ' ') {\n        continue\n      }\n      if (depth === 0 && getOp(operatorSymbols, char, p, expression)) {\n        return [tail, p - 1]\n      } else {\n        tail += char\n      }\n    }\n    return [tail, expression.length - 1]\n  }\n\n  /**\n   * Parse a string expression into a function that returns a boolean. This is\n   * the magic behind schema logic like $if.\n   * @param expression - A string expression to parse\n   * @returns\n   */\n  function parseLogicals(\n    expression: string,\n    step = 0\n  ): () => boolean | number | string {\n    const operators = operatorRegistry[step]\n    const length = expression.length\n    const symbols = Object.keys(operators)\n    let depth = 0\n    let quote: false | string = false\n    let op: null | ((l: any, r: any) => boolean | number | string) = null\n    let operand: Operand = ''\n    let left: null | ((r?: any) => boolean | number | string) = null\n    let operation: false | undefined | string\n    let lastChar = ''\n    let char = ''\n    let parenthetical = ''\n    let parenQuote: false | string = ''\n    let startP = 0\n    const addTo = (depth: number, char: string) => {\n      depth ? (parenthetical += char) : (operand += char)\n    }\n    for (let p = 0; p < length; p++) {\n      lastChar = char\n      char = expression.charAt(p)\n      if (\n        (char === \"'\" || char === '\"') &&\n        lastChar !== '\\\\' &&\n        ((depth === 0 && !quote) || (depth && !parenQuote))\n      ) {\n        if (depth) {\n          parenQuote = char\n        } else {\n          quote = char\n        }\n        addTo(depth, char)\n        continue\n      } else if (\n        (quote && (char !== quote || lastChar === '\\\\')) ||\n        (parenQuote && (char !== parenQuote || lastChar === '\\\\'))\n      ) {\n        addTo(depth, char)\n        continue\n      } else if (quote === char) {\n        quote = false\n        addTo(depth, char)\n        continue\n      } else if (parenQuote === char) {\n        parenQuote = false\n        addTo(depth, char)\n        continue\n      } else if (char === ' ') {\n        continue\n      } else if (char === '(') {\n        if (depth === 0) {\n          startP = p\n        } else {\n          parenthetical += char\n        }\n        depth++\n      } else if (char === ')') {\n        depth--\n        if (depth === 0) {\n          // Parenthetical statements cannot be grouped up in the implicit order\n          // of left/right statements based on which step they are on because\n          // they are parsed on every step and then must be applied to the\n          // operator. Example:\n          //\n          // 5 + (3) * 2\n          //\n          // This should yield 11 not 16. This order is normally implicit in the\n          // sequence of operators being parsed, but with parenthesis the parse\n          // happens each time. Instead we need to know if the resulting value\n          // should be applied to the left or the right hand operator. The\n          // general algorithm is:\n          //\n          // 1. Does this paren have an operator on the left or right side\n          // 2. If not, it's unnecessarily wrapped (3 + 2)\n          // 3. If it does, then which order of operation is highest?\n          // 4. Wait for the highest order of operation to bind to an operator.\n\n          // If the parenthetical has a preceding token like $fn(1 + 2) then we\n          // need to subtract the existing operand length from the start\n          // to determine if this is a left or right operation\n          const fn =\n            typeof operand === 'string' && operand.startsWith('$')\n              ? operand\n              : undefined\n          const hasTail = fn && expression.charAt(p + 1) === '.'\n          // It's possible the function has a chained tail call:\n          let tail = ''\n          if (hasTail) {\n            ;[tail, p] = getTail(p + 2, expression)\n          }\n          const lStep = op ? step : getStep(startP, expression, 0)\n          const rStep = getStep(p, expression)\n          if (lStep === -1 && rStep === -1) {\n            // This parenthetical was unnecessarily wrapped at the root, or\n            // these are args of a function call.\n            operand = evaluate(parenthetical, -1, fn, tail)\n            // If the operand is still a string after evaluation, then it was a\n            // quoted string like (\"1 + 2\") which should actually evaluate to\n            // a literal of \"1 + 2\". It will be cleaned/trimmed as a string a\n            // little further on in this block at `if (!op && operand)`.\n            if (typeof operand === 'string') operand = parenthetical\n          } else if (op && (lStep >= rStep || rStep === -1) && step === lStep) {\n            // has a left hand operator with a higher order of operation\n            left = op.bind(null, evaluate(parenthetical, -1, fn, tail))\n            op = null\n            operand = ''\n          } else if (rStep > lStep && step === rStep) {\n            // should be applied to the right hand operator when it gets one\n            operand = evaluate(parenthetical, -1, fn, tail) as string\n          } else {\n            operand += `(${parenthetical})${hasTail ? `.${tail}` : ''}`\n          }\n          parenthetical = ''\n        } else {\n          parenthetical += char\n        }\n      } else if (\n        depth === 0 &&\n        (operation = getOp(symbols, char, p, expression))\n      ) {\n        if (p === 0) {\n          error(103, [operation, expression])\n        }\n\n        // We identified the operator by looking ahead in the string, so we need\n        // our position to move past the operator\n        p += operation.length - 1\n        if (p === expression.length - 1) {\n          error(104, [operation, expression])\n        }\n        if (!op) {\n          // Bind the left hand operand\n          if (left) {\n            // In this case we've already parsed the left hand operator\n            op = operators[operation].bind(null, evaluate(left, step))\n            left = null\n          } else {\n            op = operators[operation].bind(null, evaluate(operand, step))\n            operand = ''\n          }\n        } else if (operand) {\n          // Bind the right hand operand, and return the resulting expression as a new left hand operator\n          left = op.bind(null, evaluate(operand, step)) as () =>\n            | boolean\n            | number\n            | string\n          op = operators[operation].bind(null, left)\n          operand = ''\n        }\n        continue\n      } else {\n        addTo(depth, char)\n      }\n    }\n    if (operand && op) {\n      // If we were left with an operand after the loop, and an op, it should\n      // be the right hand assignment.\n      op = op.bind(null, evaluate(operand, step))\n    }\n\n    // If we don't have an op, but we do have a left hand assignment, then that\n    // is actually our operator, so just re-assign it to op\n    op = !op && left ? left : op\n\n    if (!op && operand) {\n      // If we don't have any op but we do have an operand so there is no boolean\n      // logic to perform, but that operand still means something so we need to\n      // evaluate it and return it as a function\n      op = (v: any, t: Record<string, any>): boolean => {\n        return typeof v === 'function' ? v(t) : v\n      }\n      op = op.bind(null, evaluate(operand, step))\n    }\n\n    if (!op && !operand) {\n      error(105, expression)\n    }\n    return op as () => boolean | number | string\n  }\n\n  /**\n   * Given a string like '$name==bobby' evaluate it to true or false\n   * @param operand - A left or right boolean operand — usually conditions\n   * @param step - The current order of operation\n   * @param fnToken - The token (string) representation of a function being called\n   * @returns\n   */\n  function evaluate(\n    operand: Operand,\n    step: number,\n    fnToken?: string,\n    tail?: string //eslint-disable-line\n  ): Operand {\n    if (fnToken) {\n      const fn = evaluate(fnToken, operatorRegistry.length)\n      let userFuncReturn: unknown\n      // \"Tail calls\" are dot accessors after a function $foo().value. We need\n      // to compile tail calls, and then provide the function result to the\n      // exposed tokens.\n      let tailCall: false | FormKitCompilerOutput = tail\n        ? compile(`$${tail}`)\n        : false\n      if (typeof fn === 'function') {\n        const args = parseArgs(String(operand)).map((arg: string) =>\n          evaluate(arg, -1)\n        )\n        return (tokens: Record<string, any>) => {\n          const userFunc = fn(tokens)\n          if (typeof userFunc !== 'function') {\n            warn(150, fnToken)\n            return userFunc\n          }\n          userFuncReturn = userFunc(\n            ...args.map((arg) =>\n              typeof arg === 'function' ? arg(tokens) : arg\n            )\n          )\n          if (tailCall) {\n            tailCall = tailCall.provide((subTokens) => {\n              const rootTokens = provideTokens(subTokens)\n              const t = subTokens.reduce(\n                (tokenSet: Record<string, any>, token: string) => {\n                  const isTail = token === tail || tail?.startsWith(`${token}(`)\n                  if (isTail) {\n                    const value = getAt(userFuncReturn, token)\n                    tokenSet[token] = () => value\n                  } else {\n                    tokenSet[token] = rootTokens[token]\n                  }\n                  return tokenSet\n                },\n                {} as Record<string, any>\n              )\n              return t\n            })\n          }\n          return tailCall ? tailCall() : (userFuncReturn as string)\n        }\n      }\n    } else if (typeof operand === 'string') {\n      // the word true or false will never contain further operations\n      if (operand === 'true') return true\n      if (operand === 'false') return false\n      if (operand === 'undefined') return undefined\n\n      // Truly quotes strings cannot contain an operation, return the string\n      if (isQuotedString(operand))\n        return rmEscapes(operand.substring(1, operand.length - 1))\n\n      // Actual numbers cannot be contain an operation\n      if (!isNaN(+operand)) return Number(operand)\n\n      if (step < operatorRegistry.length - 1) {\n        return parseLogicals(operand, step + 1)\n      } else {\n        if (operand.startsWith('$')) {\n          const cleaned = operand.substring(1)\n          requirements.add(cleaned)\n          return function getToken(tokens: FormKitTokens) {\n            return cleaned in tokens ? tokens[cleaned]() : undefined\n          }\n        }\n        // In this case we are dealing with an unquoted string, just treat it\n        // as a plain string.\n        return operand\n      }\n    }\n    return operand\n  }\n\n  /**\n   * Compile the string.\n   */\n  const compiled = parseLogicals(\n    expr.startsWith('$:') ? expr.substring(2) : expr\n  )\n\n  /**\n   * Convert compiled requirements to an array.\n   */\n  const reqs = Array.from(requirements)\n\n  /**\n   * Provides token values via callback to compiled output.\n   * @param callback - A callback that needs to provide all token requirements\n   * @returns\n   */\n  function provide(\n    callback: (requirements: string[]) => Record<string, () => any>\n  ): FormKitCompilerOutput {\n    provideTokens = callback\n    return Object.assign(\n      // @ts-ignore - @rollup/plugin-typescript doesn't like this\n      compiled.bind(null, callback(reqs)),\n      { provide }\n    )\n  }\n  return Object.assign(compiled, {\n    provide,\n  })\n}\n", "import { FormKitNode } from './node'\n\n/**\n * Definition for a function that produces CSS classes.\n *\n * @public\n */\nexport interface FormKitClasses {\n  (node: FormKitNode, sectionKey: string): string | Record<string, boolean>\n}\n\n/**\n * Function that produces a standardized object representation of CSS classes.\n *\n * @param propertyKey - the section key.\n * @param node - A {@link FormKitNode | FormKitNode}.\n * @param sectionClassList - A `string | Record<string, boolean>` or a {@link FormKitClasses | FormKitClasses}.\n *\n * @returns `Record<string, boolean>`\n *\n * @public\n */\nexport function createClasses(\n  propertyKey: string,\n  node: FormKitNode,\n  sectionClassList?: FormKitClasses | string | Record<string, boolean>\n): Record<string, boolean> {\n  if (!sectionClassList) return {}\n  if (typeof sectionClassList === 'string') {\n    const classKeys = sectionClassList.split(' ')\n    return classKeys.reduce(\n      (obj, key) => Object.assign(obj, { [key]: true }),\n      {}\n    )\n  } else if (typeof sectionClassList === 'function') {\n    return createClasses(\n      propertyKey,\n      node,\n      sectionClassList(node, propertyKey)\n    )\n  }\n  return sectionClassList\n}\n\n/**\n * Combines multiple class lists into a single list.\n *\n * @param node - A {@link FormKitNode | FormKitNode}.\n * @param property - The property key to which the class list will be applied.\n * @param args - And array of `Record<string, boolean>` of CSS class list(s).\n *\n * @returns `string | null`\n *\n * @public\n */\nexport function generateClassList(\n  node: FormKitNode,\n  property: string,\n  ...args: Record<string, boolean>[]\n): string | null {\n  const combinedClassList = args.reduce((finalClassList, currentClassList) => {\n    if (!currentClassList) return handleNegativeClasses(finalClassList)\n    const { $reset, ...classList } = currentClassList\n    if ($reset) {\n      return handleNegativeClasses(classList)\n    }\n    return handleNegativeClasses(Object.assign(finalClassList, classList))\n  }, {})\n\n  return Object.keys(\n    node.hook.classes.dispatch({ property, classes: combinedClassList })\n      .classes\n  )\n    .filter((key) => combinedClassList[key])\n    .join(' ') || null\n}\n\nfunction handleNegativeClasses(classList: Record<string, boolean>): Record<string, boolean> {\n  const removalToken = '$remove:'\n  let hasNegativeClassValue = false\n  const applicableClasses = Object.keys(classList).filter((className) => {\n    if (classList[className] && className.startsWith(removalToken)) {\n      hasNegativeClassValue = true\n    }\n    return classList[className]\n  })\n  if (applicableClasses.length > 1 && hasNegativeClassValue) {\n    const negativeClasses = applicableClasses.filter(className => className.startsWith(removalToken))\n    negativeClasses.map((negativeClass) => {\n      const targetClass = negativeClass.substring(removalToken.length)\n      classList[targetClass] = false\n      classList[negativeClass] = false\n    })\n  }\n  return classList\n}\n", "import { getNode } from './registry'\nimport { ErrorMessages } from './store'\nimport { warn } from './errors'\n\n/**\n * Sets errors on a form, group, or input.\n *\n * @param id - The id of a form.\n * @param localErrors - The errors to set on the form or the form’s inputs in\n * the format of {@link ErrorMessages | ErrorMessages}.\n * @param childErrors - (optional) The errors to set on the form or the form’s\n * inputs in the format of {@link ErrorMessages | ErrorMessages}.\n *\n * @public\n */\nexport function setErrors(\n  id: string,\n  localErrors: ErrorMessages,\n  childErrors?: ErrorMessages\n): void {\n  const node = getNode(id)\n  if (node) {\n    node.setErrors(localErrors, childErrors)\n  } else {\n    warn(651, id)\n  }\n}\n\n/**\n * Clears errors on the node and optionally its children.\n *\n * @param id - The id of the node you want to clear errors for.\n * @param clearChildren - Determines if the children of this node should have\n * their errors cleared.\n *\n * @public\n */\nexport function clearErrors(id: string, clearChildren = true): void {\n  const node = getNode(id)\n  if (node) {\n    node.clearErrors(clearChildren)\n  } else {\n    warn(652, id)\n  }\n}\n", "/**\n * The official FormKit core library. This package is responsible for most of FormKit’s internal functionality.\n * You can read documentation specifically on how it works at formkit.com.\n *\n * You can add this package by using `npm install @formkit/core` or `yarn add @formkit/core`.\n *\n * @packageDocumentation\n */\n\n/**\n * The current version of FormKit at the time the package is published. Is replaced\n * as part of the publishing script.\n *\n * @internal\n */\nexport const FORMKIT_VERSION = '__FKV__'\n\n/**\n * Include all exported methods from node, this is the primary API.\n */\nexport * from './node'\n\n/**\n * Include createMessage to create new messages.\n */\nexport {\n  createMessage,\n  ChildMessageBuffer,\n  FormKitInputMessages,\n  FormKitMessage,\n  FormKitMessageMeta,\n  FormKitMessageStore,\n  FormKitMessageProps,\n  FormKitStore,\n  ErrorMessages,\n  FormKitStoreTraps,\n  MessageClearer,\n} from './store'\n\n/**\n * The FormKit ledger.\n */\nexport {\n  FormKitLedger,\n  FormKitCounterCondition,\n  FormKitCounter,\n} from './ledger'\n\n/**\n * Export dispatcher typings.\n */\nexport { FormKitDispatcher, FormKitMiddleware } from './dispatcher'\n\n/**\n * Export event typings.\n */\nexport {\n  FormKitEventListener,\n  FormKitEvent,\n  FormKitEventEmitter,\n} from './events'\n\n/**\n * Export errors emitters.\n */\nexport {\n  FormKitHandlerPayload,\n  errorHandler,\n  warningHandler,\n  warn,\n  error,\n} from './errors'\n\n/**\n * Export all schema features.\n */\nexport {\n  FormKitAttributeValue,\n  FormKitExtendableSchemaRoot,\n  FormKitListStatement,\n  FormKitListValue,\n  FormKitSchemaAttributes,\n  FormKitSchemaAttributesCondition,\n  FormKitSchemaComponent,\n  FormKitSchemaComposable,\n  FormKitSchemaCondition,\n  FormKitSchemaContext,\n  FormKitSchemaDOMNode,\n  FormKitSchemaFormKit,\n  FormKitSchemaMeta,\n  FormKitSchemaNode,\n  FormKitSchemaProps,\n  FormKitSchemaTextNode,\n  FormKitSchemaDefinition,\n  FormKitSectionsSchema,\n  isComponent,\n  isConditional,\n  isDOM,\n  isSugar,\n  sugar,\n} from './schema'\n\n/**\n * Export the FormKit logic compiler.\n */\nexport {\n  compile,\n  FormKitCompilerOutput,\n  FormKitCompilerProvider,\n} from './compiler'\n\n/**\n * Export classes.\n */\nexport * from './classes'\n\n/**\n * Export the global registry.\n */\nexport * from './registry'\n\n/**\n * The root configuration creator.\n */\nexport { createConfig, FormKitRootConfig } from './config'\n\n/**\n * Sets error store messages on inputs.\n */\nexport * from './setErrors'\n\n/**\n * Programmatically submits a form by the id.\n */\nexport { submitForm } from './submitForm'\n\n/**\n * Programmatically reset an input.\n */\nexport { reset } from './reset'\n", "/**\n * FormKit Observer is a utility to wrap a FormKitNode in a dependency tracking observer proxy.\n *\n * @packageDocumentation\n */\n\nimport { has } from '@formkit/utils'\nimport {\n  FormKitNode,\n  isNode,\n  FormKitEventListener,\n  FormKitProps,\n  FormKitLedger,\n} from '@formkit/core'\n\n/**\n * An API-compatible FormKitNode that is able to determine the full dependency\n * tree of nodes and their values.\n * @public\n */\nexport interface FormKitObservedNode extends FormKitNode {\n  _node: FormKitNode\n  deps: FormKitDependencies\n  kill: () => undefined\n  observe: () => void\n  receipts: FormKitObserverReceipts\n  stopObserve: () => FormKitDependencies\n  watch: <T extends FormKitWatchable>(\n    block: T,\n    after?: (value: ReturnType<T>) => void,\n    pos?: 'push' | 'unshift'\n  ) => void\n}\n\n/**\n * The dependent nodes and the events that are required to watch for changes.\n *\n * @public\n */\nexport type FormKitDependencies = Map<FormKitNode, Set<string>> & {\n  active?: boolean\n}\n\n/**\n * A Map of nodes with the values being Maps of eventsName: receipt\n *\n * @public\n */\nexport type FormKitObserverReceipts = Map<\n  FormKitNode,\n  { [index: string]: string[] }\n>\n\n/**\n * A callback to watch for nodes.\n * @public\n */\nexport interface FormKitWatchable<T = unknown> {\n  (node: FormKitObservedNode): T\n}\n\n/**\n * A registry of all revoked observers.\n */\nconst revokedObservers = new WeakSet()\n\n/**\n * Creates the observer.\n * @param node - The {@link @formkit/core#FormKitNode | FormKitNode} to observe.\n * @param dependencies - The dependent nodes and the events that are required to\n * watch for changes.\n * @returns Returns a {@link @formkit/observer#FormKitObservedNode | FormKitObservedNode}.\n * @public\n */\nexport function createObserver(\n  node: FormKitNode,\n  dependencies?: FormKitDependencies\n): FormKitObservedNode {\n  // The dependencies touched during tracking\n  const deps: FormKitDependencies =\n    dependencies || Object.assign(new Map(), { active: false })\n  // A registry of event receipts returned by the event system\n  const receipts: FormKitObserverReceipts = new Map()\n\n  /**\n   * Simple function to add a dependency to the deps map.\n   * @param event - The name of the event type (like commit/input etc)\n   */\n  const addDependency = function (event: string) {\n    if (!deps.active) return\n    if (!deps.has(node)) deps.set(node, new Set())\n    deps.get(node)?.add(event)\n  }\n\n  /**\n   * Proxies the props of a node so we know which ones were messed with, could\n   * potentially be more generalized in the future if we want to support\n   * more sub-objects.\n   * @param props - The props object from a node\n   * @returns\n   */\n  const observeProps = function (props: FormKitProps) {\n    return new Proxy(props, {\n      get(...args) {\n        typeof args[1] === 'string' && addDependency(`prop:${args[1]}`)\n        return Reflect.get(...args)\n      },\n    })\n  }\n\n  /**\n   * Observes the FormKit ledger \"value\".\n   * @param ledger - A formkit ledger counter.\n   */\n  const observeLedger = function (ledger: FormKitLedger) {\n    return new Proxy(ledger, {\n      get(...args) {\n        if (args[1] === 'value') {\n          return (key: string) => {\n            addDependency(`count:${key}`)\n            return ledger.value(key)\n          }\n        }\n        return Reflect.get(...args)\n      },\n    })\n  }\n\n  /**\n   * Return values from our observer proxy first pass through this function\n   * which gives us a chance to listen sub-dependencies and properties.\n   */\n  const observe = function (value: any, property: string | symbol) {\n    if (isNode(value)) {\n      return createObserver(value, deps)\n    }\n    if (property === 'value') addDependency('commit')\n    if (property === '_value') addDependency('input')\n    if (property === 'props') return observeProps(value)\n    if (property === 'ledger') return observeLedger(value)\n    if (property === 'children') {\n      addDependency('child')\n      addDependency('childRemoved')\n    }\n    return value\n  }\n\n  /**\n   * The actual proxy object of the original node.\n   */\n  const {\n    proxy: observed,\n    revoke,\n  }: { proxy: FormKitNode; revoke: () => void } = Proxy.revocable(node, {\n    get(...args) {\n      switch (args[1]) {\n        case '_node':\n          return node\n        case 'deps':\n          return deps\n        case 'watch':\n          return <T extends FormKitWatchable>(\n            block: T,\n            after?: (value: unknown) => void,\n            pos?: 'push' | 'unshift'\n          ) => watch(observed as FormKitObservedNode, block, after, pos)\n        case 'observe':\n          return () => {\n            const old = new Map(deps)\n            deps.clear()\n            deps.active = true\n            return old\n          }\n        case 'stopObserve':\n          return () => {\n            const newDeps = new Map(deps)\n            deps.active = false\n            return newDeps\n          }\n        case 'receipts':\n          return receipts\n        case 'kill':\n          return (): undefined => {\n            removeListeners(receipts)\n            revokedObservers.add(args[2])\n            revoke()\n            return undefined\n          }\n      }\n      const value = Reflect.get(...args)\n      // If we're dealing with a function, we need to sub-call the function\n      // get that return value, and pass it through the same logic.\n      if (typeof value === 'function') {\n        return (...subArgs: any[]) => {\n          const subValue = value(...subArgs)\n          return observe(subValue, args[1])\n        }\n      }\n      return observe(value, args[1])\n    },\n  })\n  return observed as unknown as FormKitObservedNode\n}\n\n/**\n * Given two maps (`toAdd` and `toRemove`), apply the dependencies as event\n * listeners on the underlying nodes.\n * @param node - The node to apply dependencies to.\n * @param deps - A tuple of toAdd and toRemove FormKitDependencies maps.\n * @param callback - The callback to add or remove.\n * @internal\n */\nexport function applyListeners(\n  node: FormKitObservedNode,\n  [toAdd, toRemove]: [FormKitDependencies, FormKitDependencies],\n  callback: FormKitEventListener,\n  pos?: 'unshift' | 'push'\n): void {\n  toAdd.forEach((events, depNode) => {\n    events.forEach((event) => {\n      node.receipts.has(depNode) || node.receipts.set(depNode, {})\n      const events = node.receipts.get(depNode) ?? {}\n      events[event] = events[event] ?? []\n      events[event].push(depNode.on(event, callback, pos))\n      node.receipts.set(depNode, events)\n    })\n  })\n  toRemove.forEach((events, depNode) => {\n    events.forEach((event) => {\n      if (node.receipts.has(depNode)) {\n        const nodeReceipts = node.receipts.get(depNode)\n        if (nodeReceipts && has(nodeReceipts, event)) {\n          nodeReceipts[event].map(depNode.off)\n          delete nodeReceipts[event]\n          node.receipts.set(depNode, nodeReceipts)\n        }\n      }\n    })\n  })\n}\n\n/**\n * Remove all the receipts from the observed node and subtree.\n * @param receipts - The FormKit observer receipts to remove.\n * @public\n */\nexport function removeListeners(receipts: FormKitObserverReceipts): void {\n  receipts.forEach((events, node) => {\n    for (const event in events) {\n      events[event].map(node.off)\n    }\n  })\n  receipts.clear()\n}\n\n/**\n * Observes a chunk of code to dependencies, and then re-calls that chunk of\n * code when those dependencies are manipulated.\n * @param node - The node to observer\n * @param block - The block of code to observe\n * @param after - A function to call after a effect has been run.\n * @public\n */\nfunction watch<T extends FormKitWatchable>(\n  node: FormKitObservedNode,\n  block: T,\n  after?: (value: unknown) => void,\n  pos?: 'push' | 'unshift'\n): void {\n  const doAfterObservation = (res: unknown) => {\n    const newDeps = node.stopObserve()\n    applyListeners(\n      node,\n      diffDeps(oldDeps, newDeps),\n      () => watch(node, block, after, pos),\n      pos\n    )\n    if (after) after(res)\n  }\n  const oldDeps = new Map(node.deps)\n  node.observe()\n  const res = block(node)\n  if (res instanceof Promise) res.then((val) => doAfterObservation(val))\n  else doAfterObservation(res)\n}\n\n/**\n * Determines which nodes should be added as dependencies and which should be\n * removed.\n * @param previous - The previous watcher dependencies.\n * @param current - The new/current watcher dependencies.\n * @returns A tuple of maps: `toAdd` and `toRemove`.\n * @public\n */\nexport function diffDeps(\n  previous: FormKitDependencies,\n  current: FormKitDependencies\n): [FormKitDependencies, FormKitDependencies] {\n  const toAdd: FormKitDependencies = new Map()\n  const toRemove: FormKitDependencies = new Map()\n  current.forEach((events, node) => {\n    if (!previous.has(node)) {\n      toAdd.set(node, events)\n    } else {\n      const eventsToAdd = new Set<string>()\n      const previousEvents = previous.get(node)\n      events.forEach(\n        (event) => !previousEvents?.has(event) && eventsToAdd.add(event)\n      )\n      toAdd.set(node, eventsToAdd)\n    }\n  })\n  previous.forEach((events, node) => {\n    if (!current.has(node)) {\n      toRemove.set(node, events)\n    } else {\n      const eventsToRemove = new Set<string>()\n      const newEvents = current.get(node)\n      events.forEach(\n        (event) => !newEvents?.has(event) && eventsToRemove.add(event)\n      )\n      toRemove.set(node, eventsToRemove)\n    }\n  })\n  return [toAdd, toRemove]\n}\n\n/**\n * Checks if the given node is revoked.\n * @param node - Any observed node to check.\n * @returns A `boolean` indicating if the node is revoked.\n * @public\n */\nexport function isKilled(node: FormKitNode | FormKitObservedNode): boolean {\n  return revokedObservers.has(node)\n}\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value was should be considered \"accepted\".\n * @param context - The FormKitValidationContext\n * @public\n */\nconst accepted: FormKitValidationRule = function accepted({ value }) {\n  return ['yes', 'on', '1', 1, true, 'true'].includes(value as string)\n}\n\naccepted.skipEmpty = false\n\nexport default accepted\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value is after a given date.\n * Defaults to current time.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst date_after: FormKitValidationRule = function (\n  { value },\n  compare = false\n) {\n  const timestamp = Date.parse(compare || new Date())\n  const fieldValue = Date.parse(String(value))\n  return isNaN(fieldValue) ? false : fieldValue > timestamp\n}\n\nexport default date_after\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value is after or equal to a given date.\n * Defaults to current time.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst date_after_or_equal: FormKitValidationRule = function (\n  { value },\n  compare = false\n) {\n  const timestamp = Date.parse(compare || new Date())\n  const fieldValue = Date.parse(String(value))\n  return isNaN(fieldValue) ? false : fieldValue > timestamp || fieldValue === timestamp\n}\n\nexport default date_after_or_equal\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value is after a given date.\n * Defaults to current time.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst date_after_node: FormKitValidationRule = function (\n  node,\n  address: string\n) {\n  if (!address) return false\n\n  const fieldValue = Date.parse(String(node.value))\n  const foreignValue = Date.parse(String(node.at(address)?.value))\n\n  if (isNaN(foreignValue)) return true\n\n  return isNaN(fieldValue) ? false : fieldValue > foreignValue\n}\n\nexport default date_after_node\n", "import { has } from '@formkit/utils'\nimport { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value contains only alpha characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst alpha: FormKitValidationRule = function ({ value }, set = 'default') {\n  const sets = {\n    default: /^\\p{L}+$/u,\n    latin: /^[a-z]+$/i,\n  }\n  const selectedSet: 'default' | 'latin' = has(sets, set) ? set : 'default'\n  return sets[selectedSet].test(String(value))\n}\n\nexport default alpha\n", "import { has } from '@formkit/utils'\nimport { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value contains only alpha characters or space.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst alpha_spaces: FormKitValidationRule = function (\n  { value },\n  set = 'default'\n) {\n  const sets = {\n    default: /^[\\p{L} ]+$/u,\n    latin: /^[a-z ]+$/i,\n  }\n  const selectedSet: 'default' | 'latin' = has(sets, set) ? set : 'default'\n  return sets[selectedSet].test(String(value))\n}\n\nexport default alpha_spaces\n", "import { has } from '@formkit/utils'\nimport { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value contains only alpha or numeric characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst alphanumeric: FormKitValidationRule = function (\n  { value },\n  set = 'default'\n) {\n  const sets = {\n    default: /^[0-9\\p{L}]+$/u,\n    latin: /^[0-9a-z]+$/i,\n  }\n  const selectedSet: 'default' | 'latin' = has(sets, set) ? set : 'default'\n  return sets[selectedSet].test(String(value))\n}\n\nexport default alphanumeric\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value is before a given date.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst date_before: FormKitValidationRule = function (\n  { value },\n  compare = false\n) {\n  const timestamp = Date.parse(compare || new Date())\n  const fieldValue = Date.parse(String(value))\n  return isNaN(fieldValue) ? false : fieldValue < timestamp\n}\n\nexport default date_before\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value is before a given date.\n * Defaults to current time.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst date_before_node: FormKitValidationRule = function (\n  node,\n  address: string\n) {\n  if (!address) return false\n\n  const fieldValue = Date.parse(String(node.value))\n  const foreignValue = Date.parse(String(node.at(address)?.value))\n\n  if (isNaN(foreignValue)) return true\n\n  return isNaN(fieldValue) ? false : fieldValue < foreignValue\n}\n\nexport default date_before_node\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value is before or equal to a given date.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst date_before_or_equal: FormKitValidationRule = function (\n  { value },\n  compare = false\n) {\n  const timestamp = Date.parse(compare || new Date())\n  const fieldValue = Date.parse(String(value))\n  return isNaN(fieldValue) ? false : fieldValue < timestamp || fieldValue === timestamp\n}\n\nexport default date_before_or_equal\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value is between two other values.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst between: FormKitValidationRule = function between(\n  { value },\n  from: any,\n  to: any\n) {\n  if (!isNaN(value as number) && !isNaN(from) && !isNaN(to)) {\n    const val = 1 * (value as number)\n    from = Number(from)\n    to = Number(to)\n    const [a, b] = from <= to ? [from, to] : [to, from]\n    return val >= 1 * a && val <= 1 * b\n  }\n  return false\n}\n\nexport default between\n", "import { FormKitValidationRule } from '@formkit/validation'\n\nconst hasConfirm = /(_confirm(?:ed)?)$/\n\n/**\n * Determine if the given input's value matches another input's value.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst confirm: FormKitValidationRule = function confirm(\n  node,\n  address?,\n  comparison = 'loose'\n) {\n  if (!address) {\n    address = hasConfirm.test(node.name)\n      ? node.name.replace(hasConfirm, '')\n      : `${node.name}_confirm`\n  }\n  const foreignValue = node.at(address)?.value\n  return comparison === 'strict'\n    ? node.value === foreignValue\n    : node.value == foreignValue\n}\n\nexport default confirm\n", "import { has } from '@formkit/utils'\nimport { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value contains alpha characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst contains_alpha: FormKitValidationRule = function (\n  { value },\n  set = 'default'\n) {\n  const sets = {\n    default: /\\p{L}/u,\n    latin: /[a-z]/i,\n  }\n  const selectedSet: 'default' | 'latin' = has(sets, set) ? set : 'default'\n  return sets[selectedSet].test(String(value))\n}\n\nexport default contains_alpha\n", "import { has } from '@formkit/utils'\nimport { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value contains alpha characters or space.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst contains_alpha_spaces: FormKitValidationRule = function (\n  { value },\n  set = 'default'\n) {\n  const sets = {\n    default: /[\\p{L} ]/u,\n    latin: /[a-z ]/i,\n  }\n  const selectedSet: 'default' | 'latin' = has(sets, set) ? set : 'default'\n  return sets[selectedSet].test(String(value))\n}\n\nexport default contains_alpha_spaces\n", "import { has } from '@formkit/utils'\nimport { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value contains alpha or numeric characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst contains_alphanumeric: FormKitValidationRule = function (\n  { value },\n  set = 'default'\n) {\n  const sets = {\n    default: /[0-9\\p{L}]/u,\n    latin: /[0-9a-z]/i,\n  }\n  const selectedSet: 'default' | 'latin' = has(sets, set) ? set : 'default'\n  return sets[selectedSet].test(String(value))\n}\n\nexport default contains_alphanumeric\n", "import { has } from '@formkit/utils'\nimport { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value contains lowercase characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst contains_lowercase: FormKitValidationRule = function (\n  { value },\n  set = 'default'\n) {\n  const sets = {\n    default: /\\p{Ll}/u,\n    latin: /[a-z]/,\n  }\n  const selectedSet: 'default' | 'latin' = has(sets, set) ? set : 'default'\n  return sets[selectedSet].test(String(value))\n}\n\nexport default contains_lowercase\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value contains numeric characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst contains_numeric: FormKitValidationRule = function number({ value }) {\n  return /[0-9]/.test(String(value))\n}\n\nexport default contains_numeric\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value contains symbol characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst contains_symbol: FormKitValidationRule = function ({ value }) {\n  return /[!-/:-@[-`{-~]/.test(String(value))\n}\n\nexport default contains_symbol\n", "import { has } from '@formkit/utils'\nimport { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value contains uppercase characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst contains_uppercase: FormKitValidationRule = function (\n  { value },\n  set = 'default'\n) {\n  const sets = {\n    default: /\\p{Lu}/u,\n    latin: /[A-Z]/,\n  }\n  const selectedSet: 'default' | 'latin' = has(sets, set) ? set : 'default'\n  return sets[selectedSet].test(String(value))\n}\n\nexport default contains_uppercase\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value is between two other dates.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst date_between: FormKitValidationRule = function date_between(\n  { value },\n  dateA,\n  dateB\n) {\n  dateA = dateA instanceof Date ? dateA.getTime() : Date.parse(dateA)\n  dateB = dateB instanceof Date ? dateB.getTime() : Date.parse(dateB)\n  const compareTo =\n    value instanceof Date ? value.getTime() : Date.parse(String(value))\n  if (dateA && !dateB) {\n    dateB = dateA\n    dateA = Date.now()\n  } else if (!dateA || !compareTo) {\n    return false\n  }\n  return compareTo >= dateA && compareTo <= dateB\n}\n\nexport default date_between\n", "import { regexForFormat } from '@formkit/utils'\nimport { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value matches a specified date format.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst date_format: FormKitValidationRule = function date(\n  { value },\n  format?: string\n) {\n  if (format && typeof format === 'string') {\n    return regexForFormat(format).test(String(value))\n  }\n  return !isNaN(Date.parse(String(value)))\n}\n\nexport default date_format\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value is a plausible email address.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst email: FormKitValidationRule = function email({ value }) {\n  const isEmail = /^(([^<>()\\[\\]\\.,;:\\s@\\\"]+(\\.[^<>()\\[\\]\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@(([^<>()[\\]\\.,;:\\s@\\\"]+\\.)+[^<>()[\\]\\.,;:\\s@\\\"]{2,})$/i\n  return isEmail.test(String(value))\n}\n\nexport default email\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value ends with a given string.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst ends_with: FormKitValidationRule = function ends_with(\n  { value },\n  ...stack: string[]\n) {\n  if (typeof value === 'string' && stack.length) {\n    return stack.some((item) => {\n      return value.endsWith(item)\n    })\n  } else if (typeof value === 'string' && stack.length === 0) {\n    return true\n  }\n  return false\n}\n\nexport default ends_with\n", "import { eq } from '@formkit/utils'\nimport { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value is in a set of possible values.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst is: FormKitValidationRule = function is({ value }, ...stack: any[]) {\n  return stack.some((item) => {\n    if (typeof item === 'object') {\n      return eq(item, value)\n    }\n    return item == value\n  })\n}\n\nexport default is\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value length is full width.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst length: FormKitValidationRule = function length(\n  { value },\n  first = 0,\n  second = Infinity\n) {\n  first = parseInt(first)\n  second = isNaN(parseInt(second)) ? Infinity : parseInt(second)\n  const min = first <= second ? first : second\n  const max = second >= first ? second : first\n  if (typeof value === 'string' || Array.isArray(value)) {\n    return value.length >= min && value.length <= max\n  } else if (value && typeof value === 'object') {\n    const length = Object.keys(value).length\n    return length >= min && length <= max\n  }\n  return false\n}\n\nexport default length\n", "import { has } from '@formkit/utils'\nimport { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value contains only lowercase characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst lowercase: FormKitValidationRule = function ({ value }, set = 'default') {\n  const sets = {\n    default: /^\\p{Ll}+$/u,\n    allow_non_alpha: /^[0-9\\p{Ll}!-/:-@[-`{-~]+$/u,\n    allow_numeric: /^[0-9\\p{Ll}]+$/u,\n    allow_numeric_dashes: /^[0-9\\p{Ll}-]+$/u,\n    latin: /^[a-z]+$/,\n  }\n  const selectedSet: 'default' | 'allow_non_alpha' | 'allow_numeric' | 'allow_numeric_dashes' | 'latin' = has(sets, set) ? set : 'default'\n  return sets[selectedSet].test(String(value))\n}\n\nexport default lowercase\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value matches one or more values or regular expressions.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst matches: FormKitValidationRule = function matches({ value }, ...stack) {\n  return stack.some((pattern) => {\n    if (\n      typeof pattern === 'string' &&\n      pattern.substr(0, 1) === '/' &&\n      pattern.substr(-1) === '/'\n    ) {\n      pattern = new RegExp(pattern.substr(1, pattern.length - 2))\n    }\n    if (pattern instanceof RegExp) {\n      return pattern.test(String(value))\n    }\n    return pattern === value\n  })\n}\n\nexport default matches\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value is less than or equal to the maximum.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst max: FormKitValidationRule = function max({ value }, maximum = 10) {\n  if (Array.isArray(value)) {\n    return value.length <= maximum\n  }\n  return Number(value) <= Number(maximum)\n}\n\nexport default max\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value is greater than or equal to the minimum.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst min: FormKitValidationRule = function min({ value }, minimum = 1) {\n  if (Array.isArray(value)) {\n    return value.length >= minimum\n  }\n  return Number(value) >= Number(minimum)\n}\n\nexport default min\n", "import { FormKitValidationRule } from '@formkit/validation'\nimport { eq } from '@formkit/utils'\n\n/**\n * Determine if the given input's value is not in a given stack.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst not: FormKitValidationRule = function not({ value }, ...stack) {\n  return !stack.some((item) => {\n    if (typeof item === 'object') {\n      return eq(item, value)\n    }\n    return item === value\n  })\n}\n\nexport default not\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value is numeric.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst number: FormKitValidationRule = function number({ value }) {\n  return !isNaN(value as number)\n}\n\nexport default number\n", "import { empty } from '@formkit/utils'\nimport { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if any of the given inputs have a value.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst require_one: FormKitValidationRule = function (\n  node,\n  ...inputNames: string[]\n) {\n  if (!empty(node.value)) return true\n\n  const values = inputNames.map(name => node.at(name)?.value)\n  return values.some(value => !empty(value))\n}\n\nrequire_one.skipEmpty = false\n\nexport default require_one\n", "import { empty } from '@formkit/utils'\nimport { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value is required.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst required: FormKitValidationRule = function required({ value }, action = 'default') {\n  return action === 'trim' && typeof value === 'string'\n    ? !empty(value.trim())\n    : !empty(value)\n}\n\n/**\n * This rules should run even if the inputs is empty (obviously)\n */\nrequired.skipEmpty = false\n\nexport default required\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value starts with a substring.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst starts_with: FormKitValidationRule = function starts_with(\n  { value },\n  ...stack\n) {\n  if (typeof value === 'string' && stack.length) {\n    return stack.some((item) => {\n      return value.startsWith(item)\n    })\n  } else if (typeof value === 'string' && stack.length === 0) {\n    return true\n  }\n  return false\n}\n\nexport default starts_with\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value contains only symbol characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst symbol: FormKitValidationRule = function ({ value }) {\n  return /^[!-/:-@[-`{-~]+$/.test(String(value))\n}\n\nexport default symbol\n", "import { has } from '@formkit/utils'\nimport { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value contains only uppercase characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst uppercase: FormKitValidationRule = function ({ value }, set = 'default') {\n  const sets = {\n    default: /^\\p{Lu}+$/u,\n    latin: /^[A-Z]+$/,\n  }\n  const selectedSet: 'default' | 'latin' = has(sets, set) ? set : 'default'\n  return sets[selectedSet].test(String(value))\n}\n\nexport default uppercase\n", "import { FormKitValidationRule } from '@formkit/validation'\n\n/**\n * Determine if the given input's value is a URL.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst url: FormKitValidationRule = function url({ value }, ...stack) {\n  try {\n    const protocols = stack.length ? stack : ['http:', 'https:']\n    const url = new URL(String(value))\n    return protocols.includes(url.protocol)\n  } catch {\n    return false\n  }\n}\n\nexport default url\n", "import { FormKitNode, FormKitMessage, createMessage } from '@formkit/core'\nimport {\n  FormKitObservedNode,\n  createObserver,\n  applyListeners,\n  diffDeps,\n  removeListeners,\n  FormKitDependencies,\n  isKilled,\n} from '@formkit/observer'\nimport { has, empty, token, clone, cloneAny, eq } from '@formkit/utils'\n\n/**\n * Special validation properties that affect the way validations are applied.\n *\n * @public\n */\nexport interface FormKitValidationHints {\n  /**\n   * If this validation fails, should it block the form from being submitted or\n   * considered \"valid\"? There are some cases where it is acceptable to allow\n   * an incorrect value to still be allowed to submit.\n   */\n  blocking: boolean\n  /**\n   * Only run this rule after this many milliseconds of debounce. This is\n   * particularity helpful for more \"expensive\" async validation rules like\n   * checking if a username is taken from the backend.\n   */\n  debounce: number\n  /**\n   * Normally the first validation rule to fail blocks other rules from running\n   * if this flag is flipped to true, this rule will be run every time even if\n   * a previous rule in the validation stack failed.\n   */\n  force: boolean\n  /**\n   * Most validation rules are not run when the input is empty, but this flag\n   * allows that behavior to be changed.\n   */\n  skipEmpty: boolean\n  /**\n   * The actual name of the validation rule.\n   */\n  name: string\n}\n\n/**\n * Defines what fully parsed validation rules look like.\n * @public\n */\nexport type FormKitValidation = {\n  /**\n   * The actual rule function that will be called\n   */\n  rule: FormKitValidationRule\n  /**\n   * Arguments to be passed to the validation rule\n   */\n  args: any[]\n  /**\n   * The debounce timer for this input.\n   */\n  timer: number\n  /**\n   * The state of a validation, can be true, false, or null which means unknown.\n   */\n  state: boolean | null\n  /**\n   * Determines if the rule should be considered for the next run cycle. This\n   * does not mean the rule will be validated, it just means that it should be\n   * considered.\n   */\n  queued: boolean\n  /**\n   * Dependencies this validation rule is observing.\n   */\n  deps: FormKitDependencies\n  /**\n   * The observed node that is being validated.\n   */\n  observer: FormKitObservedNode\n  /**\n   * An observer that updates validation messages when it’s dependencies change,\n   * for example, the label of the input.\n   */\n  messageObserver?: FormKitObservedNode\n} & FormKitValidationHints\n\n/**\n * Defines what validation rules look like when they are parsed, but have not\n * necessarily had validation rules substituted in yet.\n * @public\n */\nexport type FormKitValidationIntent = [string | FormKitValidationRule, ...any[]]\n\n/**\n * Signature for a generic validation rule. It accepts an input — often a string\n * — but should be able to accept any input type, and returns a boolean\n * indicating whether or not it passed validation.\n * @public\n */\nexport type FormKitValidationRule = {\n  (node: FormKitNode, ...args: any[]): boolean | Promise<boolean>\n  ruleName?: string\n} & Partial<FormKitValidationHints>\n\n/**\n * A validation rule result.\n * @public\n */\nexport interface FormKitValidationRuleResult {\n  result: boolean\n  validation: FormKitValidation\n}\n\n/**\n * FormKit validation rules are structured as on object of key/function pairs\n * where the key of the object is the validation rule name.\n * @public\n */\nexport interface FormKitValidationRules {\n  [index: string]: FormKitValidationRule\n}\n\n/**\n * The interface for the localized validation message function.\n * @public\n */\nexport interface FormKitValidationMessage {\n  (...args: FormKitValidationI18NArgs): string\n}\n\n/**\n * The interface for the localized validation message registry.\n * @public\n */\nexport interface FormKitValidationMessages {\n  [index: string]: string | FormKitValidationMessage\n}\n\n/**\n * Determines the validation nonce.\n * @public\n */\ninterface FormKitValidationState {\n  input: string | null\n  rerun: number | null\n  isPassing: boolean\n}\n\n/**\n * The arguments that are passed to the validation messages in the i18n plugin.\n *\n * @public\n */\nexport type FormKitValidationI18NArgs = [\n  {\n    node: FormKitNode\n    name: string\n    args: any[]\n    message?: string\n  }\n]\n\n/**\n * Message that gets set when the node is awaiting validation.\n */\nconst validatingMessage = /* #__PURE__ */ createMessage({\n  type: 'state',\n  blocking: true,\n  visible: false,\n  value: true,\n  key: 'validating',\n})\n\n/**\n * The actual validation plugin function. Everything must be bootstrapped here.\n *\n * @param baseRules - Base validation rules to include in the plugin. By default,\n * FormKit makes all rules in the \\@formkit/rules package available via the\n * defaultConfig.\n *\n * @public\n */\nexport function createValidationPlugin(baseRules: FormKitValidationRules = {}) {\n  return function validationPlugin(node: FormKitNode): void {\n    let propRules = cloneAny(node.props.validationRules || {})\n    let availableRules = { ...baseRules, ...propRules }\n    // create an observed node\n    const state = { input: token(), rerun: null, isPassing: true }\n    let validation = cloneAny(node.props.validation)\n    // If the node's validation props change, reboot:\n    node.on('prop:validation', ({ payload }) => reboot(payload, propRules))\n    node.on('prop:validationRules', ({ payload }) =>\n      reboot(validation, payload)\n    )\n    /**\n     * Reboots the validation using new rules or declarations/intents.\n     * @param newValidation - New validation declaration to use\n     * @param newRules - New validation rules to use\n     * @returns\n     */\n    function reboot(\n      newValidation: undefined | string | FormKitValidationIntent[],\n      newRules: FormKitValidationRules\n    ) {\n      if (\n        eq(Object.keys(propRules || {}), Object.keys(newRules || {})) &&\n        eq(validation, newValidation)\n      )\n        return\n      propRules = cloneAny(newRules)\n      validation = cloneAny(newValidation)\n      availableRules = { ...baseRules, ...propRules }\n      // Destroy all observers that may re-trigger validation on an old stack\n      // Clear existing message observers\n      node.props.parsedRules?.forEach((validation: FormKitValidation) => {\n        removeMessage(validation)\n        removeListeners(validation.observer.receipts)\n        validation.observer.kill()\n      })\n      // Remove all existing messages before re-validating\n      node.store.filter(() => false, 'validation')\n      node.props.parsedRules = parseRules(newValidation, availableRules, node)\n      state.isPassing = true\n      validate(node, node.props.parsedRules, state)\n    }\n\n    // Validate the field when this plugin is initialized\n    node.props.parsedRules = parseRules(validation, availableRules, node)\n    validate(node, node.props.parsedRules, state)\n  }\n}\n\n/**\n * Given parsed validations, a value and a node, run the validations and set\n * the appropriate store messages on the node.\n * @param value - The value being validated\n * @param node - The Node this value belongs to\n * @param rules - The rules\n */\nfunction validate(\n  node: FormKitNode | FormKitObservedNode,\n  validations: FormKitValidation[],\n  state: FormKitValidationState\n) {\n  if (isKilled(node)) return\n  state.input = token()\n  node.store.set(\n    /* #__PURE__ */ createMessage({\n      key: 'failing',\n      value: !state.isPassing,\n      visible: false,\n    })\n  )\n  state.isPassing = true\n  node.store.filter((message) => !message.meta.removeImmediately, 'validation')\n  validations.forEach(\n    (validation) => validation.debounce && clearTimeout(validation.timer)\n  )\n  if (validations.length) {\n    node.store.set(validatingMessage)\n    run(0, validations, state, false, () => {\n      node.store.remove(validatingMessage.key)\n      node.store.set(\n        /* #__PURE__ */ createMessage({\n          key: 'failing',\n          value: !state.isPassing,\n          visible: false,\n        })\n      )\n    })\n  }\n}\n\n/**\n * Runs validation rules recursively while collecting dependencies allowing for\n * cross-node validation rules that automatically re-trigger when a foreign\n * value is changed.\n * @param current - The index of the current validation rule\n * @param validations - The remaining validation rule stack to run\n * @param node - An observed node, the owner of this validation stack\n * @param state - An object of state information about this run\n * @param removeImmediately - Should messages created during this call be removed immediately when a new commit takes place?\n * @returns\n */\nfunction run(\n  current: number,\n  validations: FormKitValidation[],\n  state: FormKitValidationState,\n  removeImmediately: boolean,\n  complete: () => void\n): void {\n  const validation = validations[current]\n  if (!validation) return complete()\n  const node = validation.observer\n  if (isKilled(node)) return\n  const currentRun = state.input\n  validation.state = null\n\n  function next(async: boolean, result: boolean | null): void {\n    if (state.input !== currentRun) return\n    state.isPassing = state.isPassing && !!result\n    validation.queued = false\n    const newDeps = node.stopObserve()\n    const diff = diffDeps(validation.deps, newDeps)\n    applyListeners(\n      node,\n      diff,\n      function revalidate() {\n        // Event callback for when the deps change:\n        try {\n          node.store.set(validatingMessage)\n        } catch (e) {}\n        validation.queued = true\n        if (state.rerun) clearTimeout(state.rerun)\n        state.rerun = setTimeout(\n          validate,\n          0,\n          node,\n          validations,\n          state\n        ) as unknown as number\n      },\n      'unshift' // We want these listeners to run before other events are emitted so the 'state.validating' will be reliable.\n    )\n    validation.deps = newDeps\n\n    validation.state = result\n    if (result === false) {\n      createFailedMessage(validation, removeImmediately || async)\n    } else {\n      removeMessage(validation)\n    }\n    if (validations.length > current + 1) {\n      const nextValidation = validations[current + 1]\n      if (\n        (result || nextValidation.force || !nextValidation.skipEmpty) &&\n        nextValidation.state === null\n      ) {\n        // If the next rule was never run then it has not been observed so it could never\n        // run again on its own.\n        nextValidation.queued = true\n      }\n      run(current + 1, validations, state, removeImmediately || async, complete)\n    } else {\n      // The validation has completed\n      complete()\n    }\n  }\n  if (\n    (!empty(node.value) || !validation.skipEmpty) &&\n    (state.isPassing || validation.force)\n  ) {\n    if (validation.queued) {\n      runRule(validation, node, (result: boolean | Promise<boolean>) => {\n        result instanceof Promise\n          ? result.then((r) => next(true, r))\n          : next(false, result)\n      })\n    } else {\n      // In this case our rule is not queued, so literally nothing happened that\n      // would affect it, we just need to move past this rule and make no\n      // modifications to state\n      run(current + 1, validations, state, removeImmediately, complete)\n    }\n  } else if (empty(node.value) && validation.skipEmpty && state.isPassing) {\n    // This rule is not run because it is empty — the previous rule passed so normally we would run this rule\n    // but in this case we cannot because it is empty. The node being empty is the only condition by which\n    // this rule is not run, so the only dep at this point to the the value of the node.\n    node.observe()\n    node.value\n    next(false, state.isPassing)\n  } else {\n    // This rule is not being run because a previous validation rule is failing and this one is not forced\n    // In this case we should call next validation — a `null` result here explicitly means the rule was not run.\n    next(false, null)\n  }\n}\n\n/**\n * Run a validation rule debounced or not.\n * @param validation - A validation to debounce\n */\nfunction runRule(\n  validation: FormKitValidation,\n  node: FormKitObservedNode,\n  after: (result: boolean | Promise<boolean>) => void\n) {\n  if (validation.debounce) {\n    validation.timer = setTimeout(() => {\n      node.observe()\n      after(validation.rule(node, ...validation.args))\n    }, validation.debounce) as unknown as number\n  } else {\n    node.observe()\n    after(validation.rule(node, ...validation.args))\n  }\n}\n\n/**\n * The messages given to this function have already been set on the node, but\n * any other validation messages on the node that are not included in this\n * stack should be removed because they have been resolved.\n * @param node - The node to operate on.\n * @param messages - A new stack of messages\n */\nfunction removeMessage(validation: FormKitValidation) {\n  const key = `rule_${validation.name}`\n  if (validation.messageObserver) {\n    validation.messageObserver = validation.messageObserver.kill()\n  }\n  if (has(validation.observer.store, key)) {\n    validation.observer.store.remove(key)\n  }\n}\n\n/**\n *\n * @param value - The value that is failing\n * @param validation - The validation object\n */\nfunction createFailedMessage(\n  validation: FormKitValidation,\n  removeImmediately: boolean\n): void {\n  const node = validation.observer\n  if (isKilled(node)) return\n\n  if (!validation.messageObserver) {\n    validation.messageObserver = createObserver(node._node)\n  }\n  validation.messageObserver.watch(\n    (node) => {\n      const i18nArgs: FormKitValidationI18NArgs = createI18nArgs(\n        node,\n        validation\n      )\n      return i18nArgs\n    },\n    (i18nArgs) => {\n      const customMessage = createCustomMessage(node, validation, i18nArgs)\n      // Here we short circuit the i18n system to force the output.\n      const message = /* #__PURE__ */ createMessage({\n        blocking: validation.blocking,\n        key: `rule_${validation.name}`,\n        meta: {\n          /**\n           * Use this key instead of the message root key to produce i18n validation\n           * messages.\n           */\n          messageKey: validation.name,\n          /**\n           * For messages that were created *by or after* a debounced or async\n           * validation rule — we make note of it so we can immediately remove them\n           * as soon as the next commit happens.\n           */\n          removeImmediately,\n          /**\n           * Determines if this message should be passed to localization.\n           */\n          localize: !customMessage,\n          /**\n           * The arguments that will be passed to the validation rules\n           */\n          i18nArgs,\n        },\n        type: 'validation',\n        value: customMessage || 'This field is not valid.',\n      })\n      node.store.set(message)\n    }\n  )\n}\n\n/**\n * Returns a custom validation message if applicable.\n * @param node - FormKit Node\n * @param validation - The validation rule being processed.\n */\nfunction createCustomMessage(\n  node: FormKitNode,\n  validation: FormKitValidation,\n  i18nArgs: FormKitValidationI18NArgs\n): string | undefined {\n  const customMessage =\n    node.props.validationMessages &&\n    has(node.props.validationMessages, validation.name)\n      ? node.props.validationMessages[validation.name]\n      : undefined\n  if (typeof customMessage === 'function') {\n    return customMessage(...i18nArgs)\n  }\n  return customMessage\n}\n\n/**\n * Creates the arguments passed to the i18n\n * @param node - The node that performed the validation\n * @param validation - The validation that failed\n */\nfunction createI18nArgs(\n  node: FormKitNode,\n  validation: FormKitValidation\n): FormKitValidationI18NArgs {\n  // If a custom message has been found, short circuit the i18n system.\n  return [\n    {\n      node,\n      name: createMessageName(node),\n      args: validation.args,\n    },\n  ]\n}\n\n/**\n * Given a node, this returns the name that should be used in validation\n * messages. This is either the `validationLabel` prop, the `label` prop, or\n * the name of the input (in that order).\n * @param node - The node to display\n * @returns\n * @public\n */\nexport function createMessageName(node: FormKitNode): string {\n  if (typeof node.props.validationLabel === 'function') {\n    return node.props.validationLabel(node)\n  }\n  return (\n    node.props.validationLabel ||\n    node.props.label ||\n    node.props.name ||\n    String(node.name)\n  )\n}\n\n/**\n * Describes hints, must also be changed in the debounceExtractor.\n */\nconst hintPattern = '(?:[\\\\*+?()0-9]+)'\n\n/**\n * A pattern to describe rule names. Rules names can only contain letters,\n * numbers, and underscores and must start with a letter.\n */\nconst rulePattern = '[a-zA-Z][a-zA-Z0-9_]+'\n\n/**\n * Regular expression for extracting rule data.\n */\nconst ruleExtractor = new RegExp(\n  `^(${hintPattern}?${rulePattern})(?:\\\\:(.*)+)?$`,\n  'i'\n)\n\n/**\n * Validation hints are special characters preceding a validation rule, like\n * !phone\n */\nconst hintExtractor = new RegExp(`^(${hintPattern})(${rulePattern})$`, 'i')\n\n/**\n * Given a hint string like ^(200)? or ^? or (200)?^ extract the hints to\n * matches.\n */\nconst debounceExtractor = /([\\*+?]+)?(\\(\\d+\\))([\\*+?]+)?/\n\n/**\n * Determines if a given string is in the proper debounce format.\n */\nconst hasDebounce = /\\(\\d+\\)/\n\n/**\n * The default values of the available validation hints.\n */\nexport const defaultHints: FormKitValidationHints = {\n  blocking: true,\n  debounce: 0,\n  force: false,\n  skipEmpty: true,\n  name: '',\n}\n\n/**\n * Parse validation intents and strings into validation rule stacks.\n * @param validation - Either a string a validation rules, or proper array of structured rules.\n * @internal\n */\nexport function parseRules(\n  validation: undefined | string | FormKitValidationIntent[],\n  rules: FormKitValidationRules,\n  node: FormKitNode\n): FormKitValidation[] {\n  if (!validation) return []\n  const intents =\n    typeof validation === 'string'\n      ? extractRules(validation)\n      : clone(validation)\n  return intents.reduce((validations, args) => {\n    let rule = args.shift() as string | FormKitValidationRule\n    const hints = {}\n    if (typeof rule === 'string') {\n      const [ruleName, parsedHints] = parseHints(rule)\n      if (has(rules, ruleName)) {\n        rule = rules[ruleName]\n        Object.assign(hints, parsedHints)\n      }\n    }\n    if (typeof rule === 'function') {\n      validations.push({\n        observer: createObserver(node),\n        rule,\n        args,\n        timer: 0,\n        state: null,\n        queued: true,\n        deps: new Map(),\n        ...defaultHints,\n        ...fnHints(hints, rule),\n      })\n    }\n    return validations\n  }, [] as FormKitValidation[])\n}\n\n/**\n * A string of validation rules written in FormKitRule notation.\n * @param validation - The string of rules\n * @internal\n */\nfunction extractRules(validation: string): FormKitValidationIntent[] {\n  return validation.split('|').reduce((rules, rule) => {\n    const parsedRule = parseRule(rule)\n    if (parsedRule) {\n      rules.push(parsedRule)\n    }\n    return rules\n  }, [] as FormKitValidationIntent[])\n}\n\n/**\n * Given a rule like confirm:password_confirm produce a FormKitValidationIntent\n * @param rule - A string representing a validation rule.\n * @returns\n */\nfunction parseRule(rule: string): FormKitValidationIntent | false {\n  const trimmed = rule.trim()\n  if (trimmed) {\n    const matches = trimmed.match(ruleExtractor)\n    if (matches && typeof matches[1] === 'string') {\n      const ruleName = matches[1].trim()\n      const args =\n        matches[2] && typeof matches[2] === 'string'\n          ? matches[2].split(',').map((s) => s.trim())\n          : []\n      return [ruleName, ...args]\n    }\n  }\n  return false\n}\n\n/**\n * Given a rule name, detect if there are any additional hints like !\n * @param ruleName - string representing a rule name\n * @returns\n */\nfunction parseHints(\n  ruleName: string\n): [string, Partial<FormKitValidationHints>] {\n  const matches = ruleName.match(hintExtractor)\n  if (!matches) {\n    return [ruleName, { name: ruleName }]\n  }\n  const map: { [index: string]: Partial<FormKitValidationHints> } = {\n    '*': { force: true },\n    '+': { skipEmpty: false },\n    '?': { blocking: false },\n  }\n  const [, hints, rule] = matches\n  const hintGroups = hasDebounce.test(hints)\n    ? hints.match(debounceExtractor) || []\n    : [, hints]\n  return [\n    rule,\n    [hintGroups[1], hintGroups[2], hintGroups[3]].reduce(\n      (hints: Partial<FormKitValidationHints>, group: string | undefined) => {\n        if (!group) return hints\n        if (hasDebounce.test(group)) {\n          hints.debounce = parseInt(group.substr(1, group.length - 1))\n        } else {\n          group\n            .split('')\n            .forEach(\n              (hint) => has(map, hint) && Object.assign(hints, map[hint])\n            )\n        }\n        return hints\n      },\n      { name: rule } as Partial<FormKitValidationHints>\n    ),\n  ]\n}\n\n/**\n * Extracts hint properties from the validation rule function itself and applies\n * them if they are not already in the set of validation hints extracted from\n * strings.\n * @param existingHints - An existing set of hints already parsed\n * @param rule - The actual rule function, which can contain hint properties\n * @returns\n */\nfunction fnHints(\n  existingHints: Partial<FormKitValidationHints>,\n  rule: FormKitValidationRule\n) {\n  if (!existingHints.name) {\n    existingHints.name = rule.ruleName || rule.name\n  }\n  return ['skipEmpty', 'force', 'debounce', 'blocking'].reduce(\n    (hints: Partial<FormKitValidationHints>, hint: string) => {\n      if (has(rule, hint) && !has(hints, hint)) {\n        Object.assign(hints, {\n          [hint]: rule[hint as keyof FormKitValidationHints],\n        })\n      }\n      return hints\n    },\n    existingHints\n  )\n}\n\n/**\n * Extracts all validation messages from the given node and all its descendants.\n * This is not reactive and must be re-called each time the messages change.\n * @param node - The FormKit node to extract validation rules from — as well as its descendants.\n * @public\n */\nexport function getValidationMessages(\n  node: FormKitNode\n): Map<FormKitNode, FormKitMessage[]> {\n  const messages: Map<FormKitNode, FormKitMessage[]> = new Map()\n  const extract = (n: FormKitNode) => {\n    const nodeMessages = []\n    for (const key in n.store) {\n      const message = n.store[key]\n      if (\n        message.type === 'validation' &&\n        message.visible &&\n        typeof message.value === 'string'\n      ) {\n        nodeMessages.push(message)\n      }\n    }\n    if (nodeMessages.length) {\n      messages.set(n, nodeMessages)\n    }\n    return n\n  }\n  extract(node).walk(extract)\n  return messages\n}\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on buttons for adding new items.\n   */\n  add: 'إضافة',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'إزالة',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'إزالة الكل',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'عذرا، لم يتم تعبئة جميع الحقول بشكل صحيح.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'إرسال',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'لا يوجد ملف مختار',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'تحرك لأعلى',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'انتقل لأسفل',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'يتم الآن التحميل...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'تحميل المزيد',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: 'التالي',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: 'السابق',\n  /**\n   * Shown when transferring items between lists.\n   */\n  addAllValues: 'أضف جميع القيم',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'إضافة قيم محددة',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'قم بإزالة جميع القيم',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'إزالة القيم المحددة',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'اختر التاريخ',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'تاريخ التغيير',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'أغلق',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'افتح',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `الرجاء قبول ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `يجب أن يكون ${s(name)} بعد ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `يجب أن يكون ${s(name)} في المستقبل.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `يمكن أن يحتوي ${s(name)} على أحرف أبجدية فقط.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `يمكن أن يحتوي ${s(name)} على أحرف وأرقام فقط.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `يمكن أن تحتوي ${s(name)} على أحرف ومسافات فقط.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `يجب أن يحتوي ${s(name)} على أحرف أبجدية.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `يجب أن يحتوي ${s(name)} على أحرف أو أرقام.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `يجب أن يحتوي ${s(name)} على أحرف أو مسافات.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `يجب أن يحتوي ${s(name)} على رمز.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `يجب أن يحتوي ${s(name)} على أحرف كبيرة.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `يجب أن يحتوي ${s(name)} على أحرف صغيرة.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `يجب أن يحتوي ${s(name)} على أرقام.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `يجب أن يكون ${s(name)} رمزًا.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `يمكن أن يحتوي ${s(name)} على أحرف كبيرة فقط.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `يمكن أن يحتوي ${s(name)} على أحرف صغيرة فقط.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `يجب أن يكون ${s(name)} قبل ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `يجب أن يكون ${s(name)} في الماضي.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `تمت تهيئة هذا الحقل بشكل غير صحيح ولا يمكن إرساله.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `يجب أن يكون ${s(name)} ما بين ${a} و ${b}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} غير متطابق.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} ليس تاريخًا صالحًا ، يرجى استخدام التنسيق ${args[0]}`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'تمت تهيئة هذا الحقل بشكل غير صحيح ولا يمكن إرساله'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `يجب أن يكون ${s(name)} بين ${date(args[0])} و ${date(args[1])}`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'الرجاء أدخال بريد إليكتروني صالح.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `لا ينتهي ${s(name)} بـ ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} ليست قيمة مسموح بها.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `يجب أن يكون ${s(name)} حرفًا واحدًا على الأقل.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `يجب أن يكون ${s(name)} أقل من أو يساوي ${max} حرفًا.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `يجب أن يتكون ${s(name)} من الأحرف ${max}.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `يجب أن يكون ${s(name)} أكبر من أو يساوي ${min} حرفًا.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `يجب أن يكون ${s(name)} بين ${min} و ${max} حرفًا.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} ليست قيمة مسموح بها.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `لا يمكن أن يكون أكثر من ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `يجب أن يكون ${s(name)} أقل من أو يساوي ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'لا يسمح بتنسيقات الملفات.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `يجب أن يكون ${s(name)} من النوع: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `لا يمكن أن يكون أقل من ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `يجب أن يكون ${s(name)} على الأقل ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}” ليس ${name} مسموحًا به.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} يجب ان يكون رقماً`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' أو ')} مطلوب.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} مطلوب.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `لا يبدأ ${s(name)} بـ ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `يرجى إدخال عنوان URL صالح.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'التاريخ المحدد غير صالح.',\n}\n\nexport const ar = { ui, validation }\n", "/**\n * Given a string, convert it to sentence case.\n *\n * @param str - The string to sentence case.\n *\n * @returns `string`\n *\n * @public\n */\nexport function sentence(str: string): string {\n  return str[0].toUpperCase() + str.substr(1)\n}\n\n/**\n * Creates an oxford-comma separated list of items.\n *\n * @param items - the items to list out.\n * @param conjunction - in the list \"x, y, and z\", \"and\" is the conjunction.\n * Defaults to \"or\".\n *\n * @returns `string`\n *\n * @public\n */\nexport function list(items: string[], conjunction = 'or'): string {\n  return items.reduce((oxford, item, index) => {\n    oxford += item\n    if (index <= items.length - 2 && items.length > 2) {\n      oxford += ', '\n    }\n    if (index === items.length - 2) {\n      oxford += `${items.length === 2 ? ' ' : ''}${conjunction} `\n    }\n    return oxford\n  }, '')\n}\n\n/**\n * Given a string or a date, return a nice human-readable version.\n *\n * @param date - A string or a date.\n *\n * @returns `string`\n *\n * @public\n */\nexport function date(date: string | Date): string {\n  const dateTime = typeof date === 'string' ? new Date(Date.parse(date)) : date\n  if (!(dateTime instanceof Date)) {\n    return '(unknown)'\n  }\n  return new Intl.DateTimeFormat(undefined, {\n    dateStyle: 'medium',\n    timeZone: 'UTC'\n  } as any).format(dateTime)\n}\n\n/**\n * Orders two variables from smallest to largest.\n *\n * @param first - The first number or string.\n * @param second - The second number or string.\n *\n * @returns `[smaller: number | string, larger: number | string]`\n *\n * @public\n */\nexport function order(\n  first: string | number,\n  second: string | number\n): [smaller: number | string, larger: number | string] {\n  return Number(first) >= Number(second) ? [second, first] : [first, second]\n}\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on a button for adding additional items.\n   */\n  add: 'əlavə edin',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'çıxarmaq',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Hamısını silin',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Üzr istəyirik, bütün sahələr düzgün doldurulmayıb.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Təqdim et',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Heç bir fayl seçilməyib',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'yuxarı hərəkət',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Aşağı hərəkət',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Yükləmə...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Daha çox yüklə',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: 'Növbəti',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: 'Əvvəlki',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Bütün dəyərləri əlavə edin',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Seçilmiş dəyərləri əlavə edin',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Bütün dəyərləri sil',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Seçilmiş dəyərləri sil',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Tarixi seçin',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Tarixi dəyişdirin',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'Bağlayın',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Açıq',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `${name} qəbul edin.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} ${date(args[0])} sonra olmalıdır.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} gələcəkdə olmalıdır.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} yalnız əlifba sırası simvollarından ibarət ola bilər.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} yalnız hərf və rəqəmlərdən ibarət ola bilər.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} yalnız hərflərdən və boşluqlardan ibarət ola bilər.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} əlifba sırası simvolları ehtiva etməlidir.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} hərfləri və ya nömrələri ehtiva etməlidir.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} hərfləri və ya boşluqları ehtiva etməlidir.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} simvolu ehtiva etməlidir.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} böyük olmalıdır.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} kiçik olmalıdır.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} nömrələri ehtiva etməlidir.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} simvol olmalıdır.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} yalnız böyük hərfləri ehtiva edə bilər.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} yalnız kiçik hərfləri ehtiva edə bilər.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} ${date(args[0])} əvvəl olmalıdır.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} keçmişdə olmalıdır.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Bu sahə səhv konfiqurasiya edilib və onu təqdim etmək mümkün deyil.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} ${a} və ${b} arasında olmalıdır.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} uyğun gəlmir.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} etibarlı tarix deyil, ${\n        args[0]\n      } formatından istifadə edin`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'Bu sahə səhv konfiqurasiya edilib və onu təqdim etmək mümkün deyil'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} ${date(args[0])} və ${date(args[1])} arasında olmalıdır`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Etibarlı e-poçt ünvanı daxil edin.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} ${list(args)} ilə bitmir.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} icazə verilən dəyər deyil.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} ən azı bir simvol olmalıdır.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} ${max} simvoldan kiçik və ya ona bərabər olmalıdır.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} ${max} simvol uzunluğunda olmalıdır.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} ${min} simvoldan böyük və ya ona bərabər olmalıdır.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)} ${min} və ${max} simvol arasında olmalıdır.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} icazə verilən dəyər deyil.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `${args[0]} ${name}-dən çox ola bilməz.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} ${args[0]} dəyərindən kiçik və ya ona bərabər olmalıdır.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Fayl formatlarına icazə verilmir.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} aşağıdakı tipdə olmalıdır: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `${args[0]} ${name}-dən az ola bilməz.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)} ən azı ${args[0]} olmalıdır.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}” icazə verilən ${name} deyil.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} rəqəm olmalıdır.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' və ya ')} tələb olunur.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} tələb olunur.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} ${list(args)} ilə başlamır.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Xahiş edirik, düzgün URL daxil edin.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'Seçilmiş tarix etibarsızdır.',\n}\n\nexport const az = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on a button for adding additional items.\n   */\n  add: 'Добави',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Премахни',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Премахни всички',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Извинете, не всички полета са попълнени правилно.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Изпрати',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Няма избран файл',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Преместване нагоре',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Преместете се надолу',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Зареждане...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Заредете повече',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: 'Следващ',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: 'Предишен',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Добавете всички стойности',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Добавяне на избрани стойности',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Премахнете всички стойности',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Премахване на избраните стойности',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Избери дата',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Промяна на датата',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'Затвори',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Отворете',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Моля приемете ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} трябва да е след ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} трябва да бъде в бъдещето.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} може да съдържа само букви.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} може да съдържа само букви и цифри.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} може да съдържа само букви и интервали.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} трябва да съдържа азбучни знаци.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} трябва да съдържа букви или цифри.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} трябва да съдържа букви или интервали.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} трябва да съдържа символ.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} трябва да съдържа главни букви.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} трябва да съдържа малки букви.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} трябва да съдържа числа.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} трябва да бъде символ.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} може да съдържа само главни букви.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} може да съдържа само малки букви.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} трябва да е преди ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} трябва да бъде в миналото.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Това поле е конфигурирано неправилно и не може да бъде изпратено`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} трябва да бъде между ${a} и ${b}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} не съвпада.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} е невалидна дата. Моля, използвайте формата ${args[0]}`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'Това поле е конфигурирано неправилно и не може да бъде изпратено'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} трябва да бъде между ${date(args[0])} и ${date(\n      args[1]\n    )}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Моля, въведете валиден имейл адрес.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} не завършва на ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} е неразрешена стойност.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} трябва да има поне един символ.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} трябва да бъде по-малко или равно на ${max} символа.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} трябва да бъде ${max} символи дълго.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} трябва да бъде по-голямо или равно на ${min} символа.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)} трябва да бъде между ${min} и ${max} символа.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} е неразрешена стойност.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `Не може да има повече от ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} трябва да бъде по-малко или равно на ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Не са разрешени никакви файлови формати.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} трябва да бъде от тип: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `Не може да има по-малко от ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)} трябва да бъде поне ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}” е неразрешен ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} трябва да бъде число.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' или ')} изисква се.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} е задължително.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} не започва с ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Моля, въведете валиден URL адрес.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'Избраната дата е невалидна.',\n}\n\nexport const bg = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on a button for adding additional items.\n   */\n  add: 'Dodaj',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Ukloni',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Ukloni sve',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Nažalost, nisu sva polja ispravno popunjena.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Pošalji',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Nije odabran nijedan fajl',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Pomjeri gore',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Pomjeri dole',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Učitavanje...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Učitaj više',\n  /**\n   * Show on buttons that navigate state forward\n   */\n  next: 'Sljedeći',\n  /**\n   * Show on buttons that navigate state backward\n   */\n  prev: 'Prethodni',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Dodajte sve vrijednosti',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Dodajte odabrane vrijednosti',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Uklonite sve vrijednosti',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Uklonite odabrane vrijednosti',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Odaberite datum',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Promjenite datum',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'Zatvori',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Otvoreno',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Molimo prihvatite ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} mora biti poslije ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} mora biti u budućnosti.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} može sadržavati samo abecedne karaktere.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} može sadržavati samo slova i brojeve.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} može sadržavati samo slova i razmake.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} mora sadržavati abecedne karaktere.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} mora sadržavati slova ili brojeve.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} mora sadržavati slova ili razmake.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} mora sadržavati simbol.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} mora sadržavati veliko slovo.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} mora sadržavati malo slovo.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} mora sadržavati brojeve.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} mora biti simbol.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} može sadržavati samo velika slova.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} može sadržavati samo mala slova.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} mora biti prije ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} mora biti u prošlosti.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Ovo polje je pogrešno konfigurirano i ne može se poslati.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} mora biti između ${a} i ${b}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} ne podudara se.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} nije ispravan datum, molimo koristite format ${\n        args[0]\n      }`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'Ovo polje je pogrešno konfigurirano i ne može se poslati'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} mora biti između ${date(args[0])} i ${date(args[1])}`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Molimo Vas da unesete validnu email adresu.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} ne završava sa ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} nije dozvoljena vrijednost.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} mora biti najmanje jedan karakter.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} mora biti manje od ili jednako ${max} karaktera.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} treba imati ${max} karaktera.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} mora biti veći od ili jednak ${min} karaktera.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)} mora biti između ${min} i ${max} karaktera.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} nije dozvoljena vrijednost.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `Ne može imati više od ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} mora biti manji ili jednak ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Nisu dozvoljeni formati datoteka.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} mora biti tipa: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `Ne može imati manje od ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `Mora biti barem ${args[0]} ${name} .`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}” nije dozvoljeno ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} mora biti broj.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' ili ')} je obavezno.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} je obavezno.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} ne počinje sa ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Unesite važeći link.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'Odabrani datum je nevažeći.',\n}\n\nexport const bs = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on a button for adding additional items.\n   */\n  add: 'Afegir',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Eliminar',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Eliminar tot',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Disculpi, no tots els camps estan omplerts correctament.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Enviar',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Cap fitxer triat',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Moure amunt',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Moure avall',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Carregant...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Carregar més',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: 'Següent',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: 'Anterior',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Afegir tots els valors',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Afegeix els valors seleccionats',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Eliminar tots els valors',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Elimina els valors seleccionats',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Trieu la data',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Canviar data',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'Tancar',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Obert',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Si us plau accepti ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} ha de ser posterior a ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} ha de succeïr al futur.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} només pot contenir caràcters alfabètics.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} només pot contenir lletres i números.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} només pot contenir lletres i espais.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} ha de contenir caràcters alfabètics.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} ha de contenir lletres o números.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} ha de contenir lletres o espais.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} ha de contenir símbol.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} ha de contenir majúscules.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} ha de contenir minúscules.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} ha de contenir números.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} ha de ser un símbol.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} només pot contenir lletres majúscules.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} només pot contenir lletres minúscules.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} ha de ser anterior a ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} ha d'estar al passat.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://docs.formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Aquest camp està configurat incorrectament i no pot ésser enviat.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} ha d'estar entre ${a} i ${b}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} no concorda.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} no és una data vàlida, si us plau empri el format ${\n        args[0]\n      }`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'Aquest camp està configurat incorrectament i no pot ésser enviat'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} ha d'estar entre ${date(args[0])} i ${date(args[1])}`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://docs.formkit.com/essentials/validation#email}\n   */\n  email: `Si us plau, entri una adreça d'e-mail vàlida.`,\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} no acaba amb ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://docs.formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} no és un valor acceptat.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://docs.formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} ha de tenir com a mínim un caràcter.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} ha de ser inferior o igual a ${max} caràcters.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} ha de tenir una longitud de ${max} caràcters.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} ha de ser major que o igual a ${min} caràcters.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)} ha d'estar entre ${min} i ${max} caràcters.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://docs.formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} no és un valor permès.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://docs.formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `No pot tenir més de ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} ha de ser menys que o igual a ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://docs.formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'No hi ha cap format de fitxer acceptat.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} ha de ser del tipus: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://docs.formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `No pot tenir menys de ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)} ha de ser com a mínim ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://docs.formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}” no s'accepta com a ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://docs.formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} ha de ser un número.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' o ')} es requereix.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://docs.formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} és obligatori.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} no comença amb ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://docs.formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Si us plau inclogui una url vàlida.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'La data seleccionada no és vàlida.',\n}\n\nexport const ca = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on buttons for adding new items.\n   */\n  add: 'Přidat',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Odebrat',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Odebrat vše',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Pardon, ale ne všechna pole jsou vyplněna správně.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Odeslat',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Žádný soubor nebyl vybrán',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Pohyb nahoru',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Posunout dolů',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Načítání...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Načíst více',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: 'Další',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: 'Předchozí',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Přidat všechny hodnoty',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Přidání vybraných hodnot',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Odstraňte všechny hodnoty',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Odstranění vybraných hodnot',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Zvolte datum',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Změnit datum',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'Zavřít',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Otevřeno',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Prosím, zaškrtněte ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} musí být po ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} musí být v budoucnosti.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} může obsahovat pouze písmena.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} může obsahovat pouze písmena a čísla.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} musí obsahovat abecední znaky.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} musí obsahovat písmena nebo číslice.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} musí obsahovat písmena nebo mezery.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} musí obsahovat symbol.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} musí obsahovat velká písmena.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} musí obsahovat malá písmena.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} musí obsahovat čísla.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} musí být symbol.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} může obsahovat pouze velká písmena.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} může obsahovat pouze malá písmena.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} musí být před ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} musí být v minulosti.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Toto pole bylo špatně nakonfigurováno a nemůže být odesláno.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} musí být mezi ${a} a ${b}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} nejsou shodná.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} není platné datum, prosím, použijte formát ${args[0]}`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'Toto pole bylo špatně nakonfigurováno a nemůže být odesláno.'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} musí být mezi ${date(args[0])} a ${date(args[1])}`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Prosím, zadejte platnou e-mailovou adresu.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} nekončí na ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} není povolená hodnota.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} musí mít nejméně jeden znak.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} může mít maximálně ${max} znaků.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} by mělo být ${max} znaků dlouhé.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} musí obsahovat minimálně ${min} znaků.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)} musí být dlouhé ${min} až ${max} znaků.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} není povolená hodnota.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `Nelze použít více než ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} musí mít menší nebo rovno než ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Nejsou nakonfigurovány povolené typy souborů.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} musí být typu: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `Nelze mít méně než ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)} musí být minimálně ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}” není dovolená hodnota pro ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} musí být číslo.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' nebo ')} je vyžadován.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} je povinné.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} nezačíná na ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Zadejte prosím platnou adresu URL.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'Vybrané datum je neplatné.',\n}\n\nexport const cs = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on buttons for adding new items.\n   */\n  add: 'Tilføj',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Fjern',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Fjern alle',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Alle felter er ikke korrekt udfyldt.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Send',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Ingen filer valgt',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Flyt op',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Flyt ned',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Indlæser...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Indlæs mere',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: 'Næste',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: 'Forrige',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Tilføj alle værdier',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Tilføj valgte værdier',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Fjern alle værdier',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Fjern valgte værdier',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Vælg dato',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Skift dato',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'Luk',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Åbn',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Accepter venligst ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} skal være senere end ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} skal være i fremtiden.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} kan kun indeholde bogstaver.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} kan kun indeholde bogstaver og tal.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} kan kun indeholde bogstaver og mellemrum.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} skal indeholde alfabetiske tegn.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} skal indeholde bogstaver eller tal.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} skal indeholde bogstaver eller mellemrum.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} skal indeholde symbol.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} skal indeholde store bogstaver.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} skal indeholde små bogstaver.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} skal indeholde tal.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} skal være et symbol.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} kan kun indeholde store bogstaver.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} kan kun indeholde små bogstaver.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} skal være før ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} skal være før i dag.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Dette felt er ikke konfigureret korrekt og kan derfor ikke blive sendt.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} skal være mellem ${a} og ${b}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} matcher ikke.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} er ikke gyldig, brug venligst formatet ${args[0]}`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'Dette felt er ikke konfigureret korrekt og kan derfor ikke blive sendt.'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} skal være mellem ${date(args[0])} og ${date(args[1])}`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Indtast venligst en gyldig email-adresse.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} slutter ikke med ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} er ikke en gyldig værdi.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} skal være på mindst ét tegn.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} skal være på højst ${max} tegn.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} skal være ${max} tegn lange.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} skal være på mindst ${min} tegn.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)} skal være på mindst ${min} og højst ${max} tegn.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} er ikke en gyldig værdi.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `Kan ikke have flere end ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} skal være mindre eller lig med ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Ingen filformater tilladt.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} skal være af filtypen: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `Kan ikke have mindre end ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)} skal være mindst ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}” er ikke en tilladt ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} skal være et tal.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' eller ')} er påkrævet.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} er påkrævet.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} starter ikke med ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Indtast en gyldig URL.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'Den valgte dato er ugyldig.',\n}\n\nexport const da = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on buttons for adding new items.\n   */\n  add: 'Hinzufügen',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Entfernen',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Alles entfernen',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Entschuldigung, nicht alle Felder wurden korrekt ausgefüllt.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Senden',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Keine Datei ausgewählt',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Gehe nach oben',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Gehen Sie nach unten',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Wird geladen...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Mehr laden',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: 'Weiter',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: 'Zurück',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Alle Werte hinzufügen',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Ausgewählte Werte hinzufügen',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Alle Werte entfernen',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Ausgewählte Werte entfernen',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Datum wählen',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Datum ändern',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'Schliessen',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Offen',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Bitte ${name} akzeptieren.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} muss nach dem ${date(args[0])} liegen.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} muss in der Zukunft liegen.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} darf nur Buchstaben enthalten.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} darf nur Buchstaben und Zahlen enthalten.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} dürfen nur Buchstaben und Leerzeichen enthalten.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} muss alphabetische Zeichen enthalten.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} muss Buchstaben oder Zahlen enthalten.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} muss Buchstaben oder Leerzeichen enthalten.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} muss ein Symbol enthalten.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} muss Großbuchstaben enthalten.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} muss Kleinbuchstaben enthalten.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} muss Zahlen enthalten.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} muss ein Symbol sein.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} kann nur Großbuchstaben enthalten.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} kann nur Kleinbuchstaben enthalten.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} muss vor dem ${date(args[0])} liegen.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} muss in der Vergangenheit liegen.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Dieses Feld wurde falsch konfiguriert und kann nicht übermittelt werden.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} muss zwischen ${args[0]} und ${args[1]} sein.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} stimmt nicht überein.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} ist kein gültiges Datum im Format ${args[0]}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'Dieses Feld wurde falsch konfiguriert und kann nicht übermittelt werden.'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} muss zwischen ${date(args[0])} und ${date(\n      args[1]\n    )} liegen.`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'E-Mail Adresse ist ungültig.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} endet nicht mit ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} enthält einen ungültigen Wert.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = first <= second ? first : second\n    const max = second >= first ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} muss mindestens ein Zeichen enthalten.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} darf maximal ${max} Zeichen enthalten.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} sollte ${max} Zeichen lang sein.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} muss mindestens ${min} Zeichen enthalten.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)} muss zwischen ${min} und ${max} Zeichen enthalten.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} enthält einen ungültigen Wert.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `Darf maximal ${args[0]} ${name} haben.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} darf maximal ${args[0]} sein.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Keine Dateiformate konfiguriert.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} muss vom Typ ${args[0]} sein.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `Mindestens ${args[0]} ${name} erforderlich.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)} muss mindestens ${args[0]} sein.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}” ist kein gültiger Wert für ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} muss eine Zahl sein.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' oder ')} ist erforderlich.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} ist erforderlich.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} beginnt nicht mit ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Bitte geben Sie eine gültige URL ein.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'Das gewählte Datum ist ungültig.',\n}\n\nexport const de = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on a button for adding additional items.\n   */\n  add: 'Προσθήκη',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Αφαίρεση',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Αφαίρεση όλων',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Λυπούμαστε, υπάρχουν πεδία που δεν έχουν συμπληρωθεί σωστά.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Υποβολή',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Κανένα αρχείο δεν έχει επιλεγεί',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Προς τα επάνω',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Προς τα κάτω',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Φορτώνει...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Φόρτωση περισσότερων',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: 'Επόμενη',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: 'Προηγούμενο',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Προσθήκη όλων των τιμών',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Προσθήκη επιλεγμένων τιμών',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Κατάργηση όλων των τιμών',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Αφαίρεση επιλεγμένων τιμών',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Επιλέξτε ημερομηνία',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Αλλαγή ημερομηνίας',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'Κλείσιμο',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Ανοιχτό',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Παρακαλώ αποδεχτείτε το ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} πρέπει να είναι μετά της ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} πρέπει να είναι στο μέλλον.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} μπορεί να περιέχει μόνο αλφαβητικούς χαρακτήρες.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} μπορεί να περιέχει μόνο γράμματα και αριθμούς.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} μπορεί να περιέχει μόνο γράμματα και κενά.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `Το ${s(name)} πρέπει να περιέχει αλφαβητικούς χαρακτήρες.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `Το ${s(name)} πρέπει να περιέχει γράμματα ή αριθμούς.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} πρέπει να περιέχει γράμματα ή κενά.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `Το ${s(name)} πρέπει να περιέχει το σύμβολο.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `Το ${s(name)} πρέπει να περιέχει κεφαλαία γράμματα.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `Το ${s(name)} πρέπει να περιέχει πεζά γράμματα.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `Το ${s(name)} πρέπει να περιέχει αριθμούς.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `Το ${s(name)} πρέπει να είναι ένα σύμβολο.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `Το ${s(name)} μπορεί να περιέχει μόνο κεφαλαία γράμματα.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `Το ${s(name)} μπορεί να περιέχει μόνο πεζά γράμματα.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} πρέπει να είναι πριν της ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} πρέπει να είναι στο παρελθόν.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Αυτό το πεδίο έχει ρυθμιστεί λανθασμένα και δεν μπορεί να υποβληθεί.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} πρέπει να είναι μεταξύ ${a} και ${b}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} δεν ταιριάζει.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(\n        name\n      )} δεν είναι έγυρη ημερομηνία, παρακαλώ ακολουθήστε την διαμόρφωση ${\n        args[0]\n      }`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'Αυτό το πεδίο έχει ρυθμιστεί λανθασμένα και δεν μπορεί να υποβληθεί'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} πρέπει να είναι μεταξύ ${date(args[0])} και ${date(\n      args[1]\n    )}`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Παρακαλώ πληκτρολογήστε μια έγκυρη email διεύθυνση. ',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} δεν καταλήγει με ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} δεν είναι μια επιτρεπτή τιμή.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} πρέπει να είναι τουλάχιστον ενός χαρακτήρα.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} πρέπει να είναι λιγότεροι ή ίσοι με ${max} χαρακτήρες.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `Το ${s(name)} θα πρέπει να έχει μήκος ${max} χαρακτήρες.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(\n        name\n      )} πρέπει να είναι περισσότεροι ή ίσοι με ${min} χαρακτήρες.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)} πρέπει να είναι μεταξύ ${min} και ${max} χαρακτήρες.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} δεν είναι μια επιτρεπτή τιμή.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `Δεν μπορεί να έχει παραπάνω από ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} πρέπει αν είναι λιγότερο ή ίσο με το ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Δεν επιτρέπονται αρχεία.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} πρέπει να είναι τύπου: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `Δεν μπορεί να είναι λιγότερο από ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)} πρέπει να είναι τουλάχιστον ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}” δεν είναι μια επιτρεπτή ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} πρέπει να είναι αριθμός.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' ή ')} απαιτείται.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} είναι υποχρεωτικό.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} δεν αρχίζει με ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Παρακαλώ εισάγετε ένα έγκυρο URL.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'Η επιλεγμένη ημερομηνία δεν είναι έγκυρη.',\n}\n\nexport const el = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on a button for adding additional items.\n   */\n  add: 'Add',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Remove',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Remove all',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Sorry, not all fields are filled out correctly.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Submit',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'No file chosen',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Move up',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Move down',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Loading...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Load more',\n  /**\n   * Show on buttons that navigate state forward\n   */\n  next: 'Next',\n  /**\n   * Show on buttons that navigate state backward\n   */\n  prev: 'Previous',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Add all values',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Add selected values',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Remove all values',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Remove selected values',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Choose date',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Change date',\n  /**\n   * Shown above error summaries when someone attempts to submit a form with\n   * errors and the developer has implemented `<FormKitSummary />`.\n   */\n  summaryHeader: 'There were errors in your form.',\n  /*\n   * Shown when there is something to close\n   */\n  close: 'Close',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Open',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Please accept the ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} must be after ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} must be in the future.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} can only contain alphabetical characters.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} can only contain letters and numbers.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} can only contain letters and spaces.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} must contain alphabetical characters.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} must contain letters or numbers.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} must contain letters or spaces.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} must contain a symbol.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} must contain an uppercase letter.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} must contain a lowercase letter.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} must contain numbers.`\n    /* </i18n> */\n  },\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} must be a symbol.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} can only contain uppercase letters.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name, args }) {\n    let postfix = ''\n    if (Array.isArray(args) && args.length) {\n      if (args[0] === 'allow_non_alpha') postfix = ', numbers and symbols'\n      if (args[0] === 'allow_numeric') postfix = ' and numbers'\n      if (args[0] === 'allow_numeric_dashes') postfix = ', numbers and dashes'\n    }\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} can only contain lowercase letters${postfix}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} must be before ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} must be in the past.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `This field was configured incorrectly and can’t be submitted.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} must be between ${a} and ${b}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} does not match.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} is not a valid date, please use the format ${args[0]}`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'This field was configured incorrectly and can’t be submitted'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} must be between ${date(args[0])} and ${date(args[1])}`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Please enter a valid email address.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} doesn’t end with ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} is not an allowed value.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} must be at least one character.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} must be less than or equal to ${max} characters.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} should be ${max} characters long.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} must be greater than or equal to ${min} characters.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)} must be between ${min} and ${max} characters.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} is not an allowed value.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `Cannot have more than ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} must be no more than ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'No file formats allowed.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} must be of the type: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `Cannot have fewer than ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)} must be at least ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}” is not an allowed ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} must be a number.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' or ')} is required.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} is required.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} doesn’t start with ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Please enter a valid URL.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'The selected date is invalid.',\n}\n\nexport const en = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on buttons for adding new items.\n   */\n  add: 'Añadir',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Quitar',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Quitar todos',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Discúlpe, los campos no fueron completados correctamente.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Enviar',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Archivo no seleccionado',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Moverse hacia arriba',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Moverse hacia abajo',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Cargando...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Cargar más',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: 'Próximo',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: 'Anterior',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Añadir todos los valores',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Añadir valores seleccionados',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Eliminar todos los valores',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Eliminar los valores seleccionados',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Elige fecha',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Cambiar fecha',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'Cerrar',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Abrir',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Acepte el ${name} por favor.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} debe ser posterior a ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} debe ser una fecha futura.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} debe contener solo caractéres alfabéticos.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} debe ser alfanumérico.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} espacios alfa solo pueden contener letras y espacios.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} debe contener caracteres alfabéticos.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} debe contener letras o números.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} debe contener letras o espacios.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} debe contener un símbolo.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} debe estar en mayúsculas.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} debe contener minúsculas.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} debe contener números.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} debe ser un símbolo.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} solo puede contener letras mayúsculas.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} solo puede contener letras minúsculas.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} debe ser anterior a ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} debe ser una fecha pasada.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `El campo no fue completado correctamente y no puede ser enviado.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} debe estar entre ${a} y ${b}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} no coincide.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} no es una fecha válida, por favor utilice el formato ${\n        args[0]\n      }`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'El campo no fue completado correctamente y no puede ser enviado.'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} debe estar entre ${date(args[0])} y ${date(args[1])}`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Ingrese una dirección de correo electrónico válida por favor.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} no termina con ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} no es un valor permitido.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} debe tener al menos una letra.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} debe tener como máximo ${max} caractéres.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} debe tener ${max} caracteres.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} debe tener como mínimo ${min} caractéres.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)} debe tener entre ${min} y ${max} caractéres.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} no es un valor permitido.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `No puede tener más de ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} debe ser menor o igual a ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'No existen formatos de archivos permitidos.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} debe ser del tipo: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `No puede tener menos de ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)} debe ser de al menos ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}” no es un valor permitido de ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} debe ser un número.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' o ')} se requiere estar.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} es requerido.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} debe comenzar con ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Introduce una URL válida.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'La fecha seleccionada no es válida.',\n}\n\nexport const es = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on buttons for adding new items.\n   */\n  add: 'افزودن',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'حذف',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'همه را حذف کنید',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'همه فیلدها به‌درستی پر نشده‌اند',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'ثبت',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'هیچ فایلی انتخاب نشده است',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'حرکت به بالا',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'حرکت به پایین',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'در حال بارگذاری...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'بارگذاری بیشتر',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: 'بعدی',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: 'قبلی',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'تمام مقادیر را اضافه کنید',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'مقادیر انتخاب شده را اضافه کنید',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'تمام مقادیر را حذف کنید',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'حذف مقادیر انتخاب شده',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'تاریخ را انتخاب کنید',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'تغییر تاریخ',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'بستن',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'باز کردن',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `لطفاً ${name} را بپذیرید.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} باید بعد از تاریخ ${date(args[0])} باشد.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} باید مربوط به آینده باشد.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} فقط میتواند شامل حروف الفبا باشد.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} فقط میتواند شامل حروف و اعداد باشد.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} فقط می تواند شامل حروف و فاصله باشد.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} باید حاوی حروف الفبا باشد.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} باید حاوی حروف یا اعداد باشد.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} باید حاوی حروف یا فاصله باشد.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} باید حاوی نماد باشد.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} باید دارای حروف بزرگ باشد.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} باید حاوی حروف کوچک باشد.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} باید حاوی اعداد باشد.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} باید یک نماد باشد.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} تنها می‌تواند شامل حروف بزرگ باشد.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} تنها می‌تواند شامل حروف کوچک باشد.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} باید قبل از تاریخ ${date(args[0])} باشد.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} باید مربوط به گذشته باشد.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `این فیلد به اشتباه پیکربندی شده است و قابل ارسال نیست`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} باید بین ${args[0]} و ${args[1]} باشد.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} مطابقت ندارد.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} تاریخ معتبری نیست، لطفاً از قالب ${\n        args[0]\n      } استفاده کنید\n`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'این فیلد به اشتباه پیکربندی شده است و قابل ارسال نیست'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} باید بین ${date(args[0])} و ${date(args[1])} باشد.`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'لطفا آدرس ایمیل معتبر وارد کنید.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} باید به ${list(args)} ختم شود.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} مجاز نیست.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = first <= second ? first : second\n    const max = second >= first ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} باید حداقل یک کاراکتر باشد.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} باید کمتر یا برابر با ${max} کاراکتر باشد.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} باید ${max} کاراکتر طولانی باشد.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} باید بزرگتر یا برابر با ${min} کاراکتر باشد.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)} باید بین ${min} و ${max} کاراکتر باشد.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} مجاز نیست.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `${name} نمی تواند بیش از ${args[0]} باشد.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} باید کمتر یا برابر با ${args[0]} باشد.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'فرمت فایل مجاز نیست.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} باید از این نوع باشد: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `${name} نمی تواند کمتر از ${args[0]} باشد.\n`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)} باید حداقل ${args[0]} باشد.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `\"${value}\" یک ${name} مجاز نیست.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} باید عدد باشد.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' یا ')} مورد نیاز است.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `پر کردن ${s(name)} اجباری است.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} باید با ${list(args)} شروع شود.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `لطفا یک URL معتبر وارد کنید.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'تاریخ انتخاب شده نامعتبر است',\n}\n\nexport const fa = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on buttons for adding new items.\n   */\n  add: 'Lisää',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Poista',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Poista kaikki',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Kaikkia kenttiä ei ole täytetty oikein.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Tallenna',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Ei valittuja tiedostoja',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Siirrä ylös',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Siirrä alas',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Ladataan...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Lataa lisää',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: 'Seuraava',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: 'Edellinen',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Lisää kaikki arvot',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Lisää valitut arvot',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Poista kaikki arvot',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Poista valitut arvot',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Valitse päivämäärä',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Vaihda päivämäärä',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'Sulje',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Avoinna',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Ole hyvä ja hyväksy ${name}`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} tulee olla ${date(args[0])} jälkeen.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} on oltava tulevaisuudessa.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} saa sisältää vain kirjaimia.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} saa sisältää vain kirjaimia ja numeroita.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} voivat sisältää vain kirjaimia ja välilyöntejä.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} on sisällettävä aakkoselliset merkit.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} täytyy sisältää kirjaimia tai numeroita.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} täytyy sisältää kirjaimia tai välilyöntejä.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} täytyy sisältää symboli.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} täytyy sisältää isoja kirjaimia.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} täytyy sisältää pieniä kirjaimia.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} täytyy sisältää numeroita.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} on oltava symboli.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} voi sisältää vain isoja kirjaimia.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} voi sisältää vain pieniä kirjaimia.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} tulee olla ennen: ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} on oltava menneisyydessä.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Tämä kenttä on täytetty virheellisesti joten sitä ei voitu lähettää.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} on oltava välillä ${a} - ${b} `\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} ei täsmää.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(\n        name\n      )} ei ole validi päivämäärä, ole hyvä ja syötä muodossa: ${args[0]}`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'Tämä kenttä on täytetty virheellisesti joten sitä ei voitu lähettää.'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} on oltava välillä ${date(args[0])} - ${date(args[1])}`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Syötä validi sähköpostiosoite.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} tulee päättyä ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} ei ole sallittu vaihtoehto.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} on oltava vähintään yksi merkki.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} on oltava ${max} tai alle merkkiä.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} pitäisi olla ${max} merkkiä pitkä.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} on oltava vähintään ${min} merkkiä.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)} on oltava vähintään ${min}, enintään ${max} merkkiä.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} ei ole sallittu arvo.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `Valitse enintään ${args[0]} ${name} vaihtoehtoa.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} on oltava ${args[0]} tai alle.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Tiedostoja ei sallita.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} tulee olla ${args[0]}-tiedostotyyppiä.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `Valitse vähintään ${args[0]} ${name} vaihtoehtoa.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)} tulee olla ${args[0]} tai suurempi.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}” ei ole sallittu ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `Kentän ${s(name)} tulee olla numero.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' tai ')} vaaditaan.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} vaaditaan.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} on alettava ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Anna kelvollinen URL-osoite.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'Valittu päivämäärä on virheellinen.',\n}\n\nexport const fi = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on buttons for adding new items.\n   */\n  add: 'Ajouter',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Supprimer',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Enlever tout',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Désolé, tous les champs ne sont pas remplis correctement.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Valider',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Aucun fichier choisi',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Déplacez-vous',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Déplacez-vous',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Chargement...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Chargez plus',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: 'Suivant',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: 'Précédent',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Ajouter toutes les valeurs',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Ajouter les valeurs sélectionnées',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Supprimer toutes les valeurs',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Supprimer les valeurs sélectionnées',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Choisissez la date',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Modifier la date',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'Fermer',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Ouvrir',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Veuillez accepter le ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} doit être postérieure au ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} doit être dans le futur.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} ne peut contenir que des caractères alphabétiques.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} ne peut contenir que des lettres et des chiffres.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} ne peuvent contenir que des lettres et des espaces.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} doit contenir des caractères alphabétiques.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} doit contenir au moins un lettre ou nombre.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} doit contenir des lettres ou des espaces.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} doit contenir un symbole.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} doit contenir au moins une majuscule.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} doit contenir au moins une minuscule.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} doit contenir des chiffres.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} doit être un symbole.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} ne peuvent contenir que des majuscules.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} ne peut contenir que des lettres minuscules.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} doit être antérieure au ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} doit être dans le passé.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Ce champ a été configuré de manière incorrecte et ne peut pas être soumis.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} doit être comprise entre ${a} et ${b}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} ne correspond pas.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(\n        name\n      )} n'est pas une date valide, veuillez utiliser le format ${args[0]}`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'Ce champ a été configuré de manière incorrecte et ne peut pas être soumis.'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} doit être comprise entre ${date(args[0])} et ${date(\n      args[1]\n    )}`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Veuillez saisir une adresse email valide.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} ne se termine pas par ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} n'est pas une valeur autorisée.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} doit comporter au moins un caractère.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} doit être inférieur ou égal à ${max} caractères.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} doit contenir ${max} caractères.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} doit être supérieur ou égal à ${min} caractères.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)} doit être comprise entre ${min} et ${max} caractères.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} n'est pas une valeur autorisée.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `Ne peut pas avoir plus de ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} doit être inférieur ou égal à ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Aucun format de fichier n’est autorisé'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} doit être du type: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `Ne peut pas avoir moins de ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)} doit être au moins de ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}” n'est pas un ${name} autorisé.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} doit être un nombre.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' ou ')} est requis.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} est requis.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} ne commence pas par ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Entrez une URL valide.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: `La date sélectionnée n'est pas valide.`,\n}\n\nexport const fr = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on a button for adding additional items.\n   */\n  add: 'Foeg ta',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Ferwider',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Ferwider alles',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Sorry, net alle fjilden binne korrekt ynfolle.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Ferstjoere',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Gjin bestân keazen',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Gean omheech',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Nei ûnderen',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Lade…',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Mear lade',\n  /**\n   * Show on buttons that navigate state forward\n   */\n  next: 'Folgende',\n  /**\n   * Show on buttons that navigate state backward\n   */\n  prev: 'Foarige',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Foegje alle wearden ta',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Foegje selektearre wearden ta',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Fuortsmite alle wearden',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Fuortsmite selektearre wearden',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Kies datum',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Feroarje datum',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Akseptearje de ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} moat nei ${date(args[0])} wêze.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} moat yn de takomst lizze.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} mei allinne alfabetyske tekens befetsje.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} mei allinne letters en sifers befetsje.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} mei allinne letters en spaasjes befetsje.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} must contain alphabetical characters.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} must contain letters and numbers.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} must contain letters and spaces.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} must contain symbol.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} must contain uppercase.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} must contain lowercase.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} must contain number.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} can only contain symbol.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} can only contain uppercase.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} can only contain lowercase.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} moat foar ${date(args[0])} falle.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} moat yn it ferline wêze.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Dit fjild is ferkeard konfigurearre en kin net ferstjoerd wurde.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} moat tusken ${a} en ${b} lizze.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} komt net oerien.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} is gjin jildige datum, brûk de notaasje ${args[0]}`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'Dit fjild is ferkeard konfigurearre en kin net ferstjoerd wurde'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} moat tusken ${date(args[0])} en ${date(args[1])} lizze`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Folje in jildich e-mailadres yn.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} einiget net mei ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} is gjin tastiene wearde.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} moat minimaal ien teken wêze.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} moat lytser wêze as of gelyk wêze oan ${max} tekens.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} moat ${max} tekens lang wêze.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} moat grutter wêze as of gelyk wêze oan ${min} tekens.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)} moat tusken de ${min} en ${max} tekens befetsje.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} is gjin tastiene wearde.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `Mei net mear as ${args[0]} ${name} hawwe.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} moat lytser wêze as of gelyk wêze oan ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Gjin bestânsnotaasjes tastien.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} moat fan it type: ${args[0]} wêze`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `Mei net minder as ${args[0]} ${name} hawwe.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)} moat minimaal ${args[0]} wêze.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `\"${value}\" is gjin tastiene ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} moat in getal wêze.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' of ')} is ferplichte.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} is ferplicht.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} begjint net mei ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Doch der in jildige url by.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'De selektearre datum is ûnjildich.',\n}\n\nexport const fy = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on a button for adding additional items.\n   */\n  add: 'הוסף',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'מחק',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'מחק הכל',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'שים לב, לא כל השדות מלאים כראוי.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'שלח',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'לא נבחר קובץ..',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'הזז למעלה',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'הזז למטה',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'טוען...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'טען יותר',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: 'הבא',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: 'הקודם',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'הוסף את כל הערכים',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'הוספת ערכים נבחרים',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'הסר את כל הערכים',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'הסר ערכים נבחרים',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'בחר תאריך',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'שינוי תאריך',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'סגור',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'פתוח',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `אנא אשר את ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} חייב להיות אחרי ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} חייב להיות בעתיד.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} חייב להכיל אותיות אלפבת.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} יכול להכיל רק מספרים ואותיות.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} יכול להכיל רק אותיות ורווחים.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} חייב להכיל תווים אלפביתיים.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} חייב להכיל אותיות או מספרים.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} חייב להכיל אותיות או רווחים.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} חייב להכיל סמל.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} חייב להכיל אותיות רישיות.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} חייב להכיל אותיות קטנות.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} חייב להכיל מספרים.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} חייב להיות סמל.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} יכול להכיל אותיות רישיות בלבד.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} יכול להכיל רק אותיות קטנות.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} חייב להיות לפני ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} חייב להיות בעבר`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `שדה זה לא הוגדר כראוי ולא יכול להישלח.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} חייב להיות בין ${a} ו- ${b}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} לא מתאים.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} הוא לא תאריך תקין, אנא השתמש בפורמט ${args[0]}`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'שדה זה לא הוגדר כראוי ולא יכול להישלח.'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} חייב להיות בין ${date(args[0])} ו- ${date(args[1])}`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'אנא הקלד אימייל תקין.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} לא מסתיים ב- ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} הוא לא ערך מורשה.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} חייב להיות לפחות תו אחד.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} חייב להיות פחות או שווה ל- ${max} תווים.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} צריך להיות ${max} תווים ארוכים.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} חייב להיות גדול או שווה ל- ${min} תווים.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)} חייב להיות בין ${min} ו- ${max} תווים.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} הוא לא ערך תקין.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `${name} לא יכול להיות עם יותר מ- ${args[0]}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} חייב להיות פחות או שווה ל- ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'פורמט הקובץ לא מורשה.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} חייב להיות מסוג: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `${name} לא יכול להיות עם פחות מ- ${args[0]}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)} חייב להיות לפחות ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}” לא מתאים ל- ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} חייב להיות מספר.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' או ')} נדרש.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} הינו חובה.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} לא מתחיל ב- ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `הזן כתובת URL חוקית.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'התאריך שנבחר אינו חוקי.',\n}\n\nexport const he = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on buttons for adding new items.\n   */\n  add: 'Dodaj',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Ukloni',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Pojedina polja nisu ispravno ispunjena.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Predaj',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Pomaknite se gore',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Pomakni se dolje',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Učitavanje...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Učitaj više',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: 'Sljedeći',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: 'prijašnji',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Dodajte sve vrijednosti',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Dodavanje odabranih vrijednosti',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Ukloni sve vrijednosti',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Ukloni odabrane vrijednosti',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Odaberite datum',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Promijeni datum',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'Zatvoriti',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Otvori',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Potrebno je potvrditi ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} mora biti u periodu poslije ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} mora biti u budućnosti.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} mora sadržavati samo slova.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} mora sadržavati slova i brojeve.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} mogu sadržavati samo slova i razmake..`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} mora sadržavati abecedne znakove.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} mora sadržavati slova ili brojeve.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} mora sadržavati slova ili razmake.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} mora sadržavati simbol.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} mora sadržavati velika slova.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} mora sadržavati mala slova.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} mora sadržavati brojeve.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} mora biti simbol.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} može sadržavati samo velika slova.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} može sadržavati samo mala slova.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} mora biti prije ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} mora biti u prošlosti.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Format sadržaja nije ispravan i ne može biti predan.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} mora biti između ${args[0]} i ${args[1]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} ne odgovara zadanoj vrijednosti.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(\n        name\n      )} nije ispravan format datuma. Molimo koristite sljedeći format: ${\n        args[0]\n      }`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'Ovo polje nije ispravno postavljeno i ne može biti predano.'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} mora biti vrijednost između ${date(args[0])} i ${date(\n      args[1]\n    )}`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Molimo upišite ispravnu email adresu.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} ne završava s ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} nije dopuštena vrijednost.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = first <= second ? first : second\n    const max = second >= first ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} mora sadržavati barem jedan znak.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} mora imati ${max} ili manje znakova.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} trebao bi biti dugačak ${max} znakova.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} mora imati barem ${min} znakova.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `Broj znakova za polje ${s(name)} mora biti između ${min} i ${max}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} nije dozvoljena vrijednost.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `Ne smije imati više od ${args[0]} ${name} polja.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} mora imati vrijednost manju ili jednaku ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Format datoteke nije dozvoljen.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `Format datoteke na polju ${s(name)} mora odgovarati: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `Broj upisanih vrijednosti na polju ${name} mora biti barem ${args[0]}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)} mora biti barem ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}” nije dozvoljena vrijednost na polju ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} mora biti broj.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' ili ')} je potreban.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} je obavezno.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} ne počinje s ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Unesite valjanu URL adresu.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'Odabrani datum je nevažeći.',\n}\n\nexport const hr = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on a button for adding additional items.\n   */\n  add: 'Hozzáadás',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Eltávolítás',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Összes eltávolítása',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Sajnáljuk, nem minden mező lett helyesen kitöltve.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Beküldés',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Nincs fájl kiválasztva',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Mozgás felfelé',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Mozgás lefelé',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Betöltés...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Töltsön be többet',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: 'Következő',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: 'Előző',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Adja hozzá az összes értéket',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Kiválasztott értékek hozzáadása',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Távolítsa el az összes értéket',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'A kiválasztott értékek eltávolítása',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Válassza ki a dátumot',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Dátum módosítása',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'Bezárás',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Nyitott',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Fogadja el a ${name} mezőt.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} mezőnek ${date(args[0])} után kell lennie.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} mezőnek a jövőben kell lennie.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} csak alfanumerikus karaktereket tartalmazhat.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} csak betűket és számokat tartalmazhat.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} csak betűket és szóközöket tartalmazhat.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `A ${s(name)} betűrendes karaktereket kell tartalmaznia.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `A ${s(name)} betűket vagy számokat kell tartalmaznia.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `A ${s(name)} betűket vagy szóközöket kell tartalmaznia.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `A ${s(name)} szimbólumot kell tartalmaznia.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `A ${s(name)} nagybetűt kell tartalmaznia.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `A ${s(name)} kisbetűt kell tartalmaznia.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `A ${s(name)} számot kell tartalmaznia.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `A ${s(name)} szimbólumnak kell lennie.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `A ${s(name)} csak nagybetűket tartalmazhat.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `A ${s(name)} csak kisbetűket tartalmazhat.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} mezőnek ${date(args[0])} előtt kell lennie.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} mezőnek a múltban kell lennie.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Ez a mező hibásan lett konfigurálva, így nem lehet beküldeni.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `A ${s(name)} mezőnek ${a} és ${b} között kell lennie.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} nem egyezik.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} nem érvényes dátum, ${args[0]} formátumot használj`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'Ez a mező hibásan lett konfigurálva, így nem lehet beküldeni.'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} mezőnek ${date(args[0])} és ${\n      args[1]\n    } között kell lennie`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Kérjük, érvényes email címet adjon meg.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} mező nem a kijelölt (${list(args)}) módon ér véget.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} nem engedélyezett érték.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} mezőnek legalább egy karakteresnek kell lennie.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} mezőnek maximum ${max} karakteresnek kell lennie.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} ${max} karakter hosszúnak kell lennie.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} mezőnek minimum ${min} karakteresnek kell lennie.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)} mezőnek ${min} és ${max} karakter között kell lennie.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} nem engedélyezett érték.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `Nem lehet több mint ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} nem lehet nagyobb, mint ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Nincsenek támogatott fájlformátumok.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)}-nak/nek a következőnek kell lennie: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `Nem lehet kevesebb, mint ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)}-nak/nek minimum ${args[0]}-nak/nek kell lennie.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `\"${value}\" nem engedélyezett ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} mezőnek számnak kell lennie.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' vagy ')} szükséges.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} mező kötelező.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} nem a következővel kezdődik: ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Kérjük, adjon meg egy érvényes URL-t.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'A kiválasztott dátum érvénytelen.',\n}\n\nexport const hu = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on buttons for adding new items.\n   */\n  add: 'Tambah',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Hapus',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Hapus semua',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Maaf, tidak semua bidang formulir terisi dengan benar',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Kirim',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Tidak ada file yang dipilih',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Pindah ke atas',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Pindah ke bawah',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Memuat...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Muat lebih',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: 'Berikutnya',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: 'Sebelumnya',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Tambahkan semua nilai',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Tambahkan nilai yang dipilih',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Hapus semua nilai',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Hapus nilai yang dipilih',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Pilih tanggal',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Ubah tanggal',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'Tutup',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Buka',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Tolong terima kolom ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} nilainya harus lebih dari waktu ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} harus berisi waktu di masa depan.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} hanya bisa diisi huruf alfabet.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} hanya bisa diisi huruf dan angka.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} hanya boleh berisi huruf dan spasi..`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} harus berisi karakter abjad.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} harus mengandung huruf atau angka.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} harus berisi huruf atau spasi.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} harus berisi simbol.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} harus berisi huruf besar.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} harus berisi huruf kecil.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} harus berisi angka.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} harus berupa simbol.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} hanya dapat berisi huruf besar.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} hanya dapat berisi huruf kecil.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} nilainya harus kurang dari waktu ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} harus berisi waktu yang sudah lampau.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Kolom ini tidak diisi dengan benar sehingga tidak bisa dikirim`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} harus bernilai diantara ${a} dan ${b}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} nilainya tidak cocok.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} waktu tidak cocok, mohon gunakan format waktu ${\n        args[0]\n      }`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'Kolom ini tidak diisi dengan benar sehingga tidak bisa dikirim'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} harus diantara waktu ${date(args[0])} dan waktu ${date(\n      args[1]\n    )}`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Tolong tulis alamat email yang benar.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} nilainya tidak berakhiran dengan ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} adalah nilai yang tidak diizinkan.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} nilainya setidaknya berisi satu karakter.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(\n        name\n      )} jumlah karakternya harus kurang dari atau sama dengan ${max} karakter.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} harus ${max} karakter panjang.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(\n        name\n      )} jumlah karakternya harus lebih dari atau sama dengan ${min} karakter.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(\n      name\n    )} jumlah karakternya hanya bisa antara ${min} dan ${max} karakter.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} nilainya tidak diizinkan.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `Tidak bisa memiliki lebih dari ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} harus lebih kecil atau sama dengan ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Format file tidak diizinkan'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} hanya bisa bertipe: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `Tidak boleh kurang dari ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)} setidaknya harus berisi ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}” adalah nilai yang tidak diperbolehkan untuk ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} harus berupa angka.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' atau ')} diperlukan`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} harus diisi.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} tidak dimulai dengan ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Harap masukkan URL yang valid.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'Tanggal yang dipilih tidak valid.',\n}\n\nexport const id = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on a button for adding additional items.\n   */\n  add: 'Bæta við',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Fjarlægja',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Fjarlægja allt',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Því miður, það er ekki búið að fylla rétt inn í alla reiti.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Senda',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Engin skrá valin',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Færa upp',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Færa niður',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Hleðsla...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Sækja meira',\n  /**\n   * Show on buttons that navigate state forward\n   */\n  next: 'Áfram',\n  /**\n   * Show on buttons that navigate state backward\n   */\n  prev: 'Til baka',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Bæta við öllum gildum',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Bæta við völdum gildum',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Fjarlægja öll gildi',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Fjarlægja valin gildi',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Velja dagsetningu',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Breyta dagsetningu',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'Loka',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Opið',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Vinsamlegast samþykktu ${name}`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} þarf að vera eftir ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} þarf að vera í framtíðinni.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} má einungis innihalda bókstafi.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} má einungis innihalda bókstafi og tölur.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} má einungis innihalda bókstafi og bil.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} verður að innihalda bókstafi.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} verður að innihalda bókstafi eða tölur.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} verður að innihalda bókstafi eða bil.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} verður að innihalda tákn.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} verður að innihalda hástaf.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} verður að innihalda lágstaf.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} verður að innihalda tölur.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} verður að vera tákn.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} má einungis innihalda hástafi.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} má einungis innihalda lágstafi.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} þarf að vera á undan ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} þarf að vera liðin.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Þessi reitur var ekki rétt stilltur.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} þarf að vera á milli ${a} og ${b}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} passar ekki.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(\n        name\n      )} er ekki gild dagsetning, vinsamlegast hafið dagsetninguna í formi ${\n        args[0]\n      }`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'Þessi reitur var ekki rétt stilltur'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} þarf að vera á milli ${date(args[0])} og ${date(\n      args[1]\n    )}`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Vinsamlegast sláðu inn gilt netfang.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} endar ekki á ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} er ekki leyfilegt gildi.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} þarf að vera að minnsta kosti einn stafur.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} þarf að vera færri en eða nákvæmlega ${max} stafir.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} þarf að vera ${max} stafir að lengd.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} þarf að vera fleiri en eða nákvæmlega ${min} stafir.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)} þarf að vera á milli ${min} og ${max} stafir.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} er ekki leyfilegt gildi.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `Ekki hægt að hafa fleiri en ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} þarf að vera minna en eða nákvæmlega ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Ekki leyfileg tegund skráar.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} þarf að vera af tegundinni: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `Ekki hægt að hafa færri en ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `Þarf að vera að minnsta kosti ${args[0]} ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}” er ekki leyfilegt fyrir ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} þarf að vera tala.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' or ')} is required.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} er skilyrt.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} byrjar ekki á ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Vinsamlegast sláðu inn gilda slóð.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'Valin dagsetning er ógild',\n}\n\nexport const is = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on buttons for adding new items.\n   */\n  add: 'Inserisci',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Rimuovi',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Rimuovi tutti',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Ci dispiace, non tutti i campi sono compilati correttamente.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Invia',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Nessun file selezionato',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Sposta in alto',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Sposta giù',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Caricamento...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Carica altro',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: 'Prossimo',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: 'Precedente',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Aggiungi tutti i valori',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Aggiungi valori selezionati',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Rimuovi tutti i valori',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Rimuovi i valori selezionati',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Scegli la data',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Cambia data',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'Chiudi',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Aperta',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Si prega di accettare ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `la data ${s(name)} deve essere successiva ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `la data ${s(name)} deve essere nel futuro.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} può contenere solo caratteri alfanumerici.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} può contenere solo lettere e numeri.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} può contenere solo lettere e spazi.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} deve contenere caratteri alfabetici.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} deve contenere lettere o numeri.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} deve contenere lettere o spazi.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} deve contenere un simbolo.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} must contain uppercase.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} deve contenere lettere minuscole.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} deve contenere numeri.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} deve essere un simbolo.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} può contenere solo lettere maiuscole.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} può contenere solo lettere minuscole.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `la data ${s(name)} deve essere antecedente ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} deve essere nel passato.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Questo campo è stato configurato male e non può essere inviato.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} deve essere tra ${a} e ${b}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} non corrisponde.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} non è una data valida, per favore usa il formato ${\n        args[0]\n      }`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'Questo campo è stato configurato in modo errato e non può essere inviato.'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} deve essere tra ${date(args[0])} e ${date(args[1])}`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Per favore inserire un indirizzo email valido.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} non termina con ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} non è un valore consentito.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} deve contenere almeno un carattere.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} deve essere minore o uguale a ${max} caratteri.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} deve contenere ${max} caratteri.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} deve essere maggiore o uguale a ${min} caratteri.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)} deve essere tra ${min} e ${max} caratteri.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} non è un valore consentito.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `Non può avere più di ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} deve essere minore o uguale a ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Formato file non consentito.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} deve essere di tipo: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `Non può avere meno di ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)} deve essere almeno ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `\"${value}\" non è un ${name} consentito.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} deve essere un numero.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' o ')} è richiesto.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} è richiesto.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} non inizia con ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Inserisci un URL valido.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'La data selezionata non è valida.',\n}\n\nexport const it = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on buttons for adding new items.\n   */\n  add: '追加',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: '削除',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: '全て削除',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: '項目が正しく入力されていません。',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: '送信',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'ファイルが選択されていません',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: '上に移動',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: '下へ移動',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: '読み込み中...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'さらに読み込む',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: '[次へ]',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: '前へ',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'すべての値を追加',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: '選択した値を追加',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'すべての値を削除',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: '選択した値を削除',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: '日付を選択',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: '日付を変更',\n  /**\n   * Shown when there is something to close\n   */\n  close: '閉じる',\n  /**\n   * Shown when there is something to open.\n   */\n  open: '[開く]',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `${name}の同意が必要です。`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)}は${date(args[0])}より後の日付である必要があります。`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)}は将来の日付でなければなりません。`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)}には英字のみを含めることができます。`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)}には、文字と数字のみを含めることができます。`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)}には、文字とスペースのみを含めることができます。`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} にはアルファベット文字が含まれている必要があります。`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} には文字または数字を含める必要があります。`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} には文字またはスペースを含める必要があります。`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} には記号が含まれている必要があります。`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} には大文字を含める必要があります。`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} には小文字を含める必要があります。`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} には数字が含まれている必要があります。`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} はシンボルでなければなりません。`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} には大文字しか使用できません`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} には小文字しか使用できません。`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)}は${date(args[0])}より前の日付である必要があります。`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)}は過去の日付である必要があります。`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `このフィールドは正しく構成されていないため、送信できません。`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)}は${a}と${b}の間にある必要があります。`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)}が一致しません。`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)}は有効な日付ではありません。${\n        args[0]\n      }の形式を使用してください。`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'このフィールドは正しく構成されておらず、送信できません。'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)}は${date(args[0])}と${date(\n      args[1]\n    )}の間にある必要があります。`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: '有効なメールアドレスを入力してください。',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)}は${list(args)}で終わっていません。`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)}は許可された値ではありません。`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)}は少なくとも1文字である必要があります。`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)}は${max}文字以下である必要があります。`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} の長さは ${max} 文字でなければなりません。`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)}は${min}文字以上である必要があります。`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)}は${min}から${max}文字の間でなければなりません。`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)}は許可された値ではありません。`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `${name}は${args[0]}を超えることはできません。`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)}は${args[0]}以下である必要があります。`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'ファイル形式は許可されていません。'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)}は${args[0]}である必要があります。`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `${name}は${args[0]}未満にすることはできません。`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)}は少なくとも${args[0]}である必要があります。`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}”は許可された${name}ではありません。`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)}は数値でなければなりません。`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join('または')}${labels}が必要です。`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)}は必須です。`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)}は${list(args)}で始まっていません。`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `有効な URL を入力してください。`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: '選択した日付は無効です。',\n}\n\nexport const ja = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on a button for adding additional items.\n   */\n  add: 'қосу',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Жою',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Барлығын жою',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Кешіріңіз, барлық өрістер дұрыс толтырылмаған.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Жіберу',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Ешбір файл таңдалмады',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Жоғары жылжу',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Төмен жылжытыңыз',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Жүктеу...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Көбірек жүктеңіз',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: 'Келесі',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: 'Алдыңғы',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Барлық мәндерді қосыңыз',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Таңдалған мәндерді қосыңыз',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Барлық мәндерді алып тастаңыз',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Таңдалған мәндерді алып тастаңыз',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Күнді таңдаңыз',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Өзгерту күні',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'Жабу',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Ашық',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `қабылдаңыз ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} кейін болуы керек ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} болашақта болуы керек.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} тек алфавиттік таңбаларды қамтуы мүмкін.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} тек әріптер мен сандардан тұруы мүмкін.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} тек әріптер мен бос орындар болуы мүмкін.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} алфавиттік таңбалардан тұруы керек.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} құрамында әріптер немесе сандар болуы керек.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} құрамында әріптер немесе бос орындар болуы керек.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} символы болуы керек.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} құрамында бас әріптер болуы керек.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} кіші әріп болуы керек.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} сандардан тұруы керек.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} символы болуы керек.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} тек бас әріптерден тұруы мүмкін.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} құрамында тек кіші әріптер болуы мүмкін.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} бұрын болуы керек ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} өткенде болуы керек.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Бұл өріс қате конфигурацияланған және оны жіберу мүмкін емес.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} арасында болуы керек ${a} және ${b}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} сәйкес келмейді.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} жарамды күн емес, пішімді пайдаланыңыз ${args[0]}`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'Бұл өріс қате конфигурацияланған және оны жіберу мүмкін емес'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} арасында болуы керек ${date(args[0])} және ${date(\n      args[1]\n    )}`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Өтінеміз қолданыстағы электронды пошта адресін енгізіңіз.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} -мен бітпейді ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} рұқсат етілген мән емес.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} кем дегенде бір таңба болуы керек.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} кем немесе тең болуы керек ${max} кейіпкерлер.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} ${max} таңбалары болуы керек.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} артық немесе тең болуы керек ${min} кейіпкерлер.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)} арасында болуы керек ${min} және ${max} кейіпкерлер.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} рұқсат етілген мән емес.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `артық болуы мүмкін емес ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} кем немесе тең болуы керек ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Файл пішімдері рұқсат етілмейді.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} типте болуы керек: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `кем болуы мүмкін емес ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)} кем дегенде болуы керек ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}” рұқсат етілмейді ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} сан болуы керек.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' не ')} қажет.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} талап етіледі.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} -ден басталмайды ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Жарамды URL мекенжайын енгізіңіз.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'Таңдалған күн жарамсыз.',\n}\n\nexport const kk = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on buttons for adding new items.\n   */\n  add: '추가',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: '제거',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: '모두 제거',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: '모든 값을 채워주세요',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: '제출하기',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: '선택된 파일이 없습니다',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: '위로 이동',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: '아래로 이동',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: '로드 중...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: '더 불러오기',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: '다음',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: '이전',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: '모든 값 추가',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: '선택한 값 추가',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: '모든 값 제거',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: '선택한 값 제거',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: '날짜 선택',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: '날짜 변경',\n  /**\n   * Shown when there is something to close\n   */\n  close: '닫기',\n  /**\n   * Shown when there is something to open.\n   */\n  open: '열기',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `${name} 올바른 값을 선택 해주세요`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} ${date(args[0])} 이후여야 합니다`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} 미래의 날짜여야합니다`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} 알파벳 문자만 포함할 수 있습니다`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} 문자와 숫자만 포함될 수 있습니다`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} 문자와 공백만 포함할 수 있습니다.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} 에는 알파벳 문자가 포함되어야 합니다.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} 에는 문자나 숫자가 포함되어야 합니다.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} 에는 문자나 공백이 포함되어야 합니다.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} 에는 기호를 포함해야 합니다.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} 는 대문자를 포함해야 합니다.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} 는 소문자를 포함해야 합니다.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} 에는 숫자가 포함되어야 합니다.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} 는 기호여야 합니다.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} 는 대문자만 포함할 수 있습니다.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} 는 소문자만 포함할 수 있습니다.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} ${date(args[0])} 이전여야 합니다`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} 과거의 날짜여야합니다`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `잘못된 구성으로 제출할 수 없습니다`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} ${a}와 ${b} 사이여야 합니다`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} 일치하지 않습니다`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} 유효한 날짜가 아닙니다. ${\n        args[0]\n      }과 같은 형식을 사용해주세요`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return '잘못된 구성으로 제출할 수 없습니다'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} ${date(args[0])}에서 ${date(args[1])} 사이여야 합니다`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: '올바른 이메일 주소를 입력해주세요',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} ${list(args)}로 끝나지 않습니다`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} 허용되는 값이 아닙니다`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} 하나 이상의 문자여야 합니다`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} ${max}자 이하여야 합니다`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} 는 ${max} 자 길이여야 합니다.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} ${min} 문자보다 크거나 같아야 합니다`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)} ${min}에서 ${max}자 사이여야 합니다`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} 허용되는 값이 아닙니다`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `${args[0]} ${name} 초과할 수 없습니다`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} ${args[0]}보다 작거나 같아야 합니다`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return '파일 형식이 허용되지 않습니다'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} ${args[0]} 유형이어야 합니다`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `${args[0]} ${name}보다 작을 수 없습니다`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)} ${args[0]} 이상이어야 합니다`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `${value}\" 허용되지 않는 ${name}입니다`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} 숫자여야 합니다`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' 또는 ')}가 필요합니다.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} 필수 값입니다`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} ${list(args)}로 시작하지 않습니다`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `유효한 URL을 입력하십시오.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: '선택한 날짜가 잘못되었습니다.',\n}\n\nexport const ko = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * By the given quantity it returns singular or plural with the correct suffix in Lithuanian\n */\nfunction getByQuantity(\n  quantity: number,\n  vienetas: string,\n  vienetai: string,\n  vienetu: string\n): string {\n  const lastTwoDigits = quantity.toString().slice(-2)\n  const parsedQuantity = parseInt(lastTwoDigits)\n\n  if (\n    (parsedQuantity > 10 && parsedQuantity < 20) ||\n    parsedQuantity % 10 === 0\n  ) {\n    return vienetu\n  }\n\n  if (parsedQuantity === 1 || parsedQuantity % 10 === 1) {\n    return vienetas\n  }\n\n  return vienetai\n}\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on a button for adding additional items.\n   */\n  add: 'Pridėti',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Pašalinti',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Pašalinti visus',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Atsiprašome, ne visi laukai užpildyti teisingai.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Pateikti',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Nepasirinktas joks failas',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Aukštyn',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Žemyn',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Kraunama...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Daugiau',\n  /**\n   * Show on buttons that navigate state forward\n   */\n  next: 'Kitas',\n  /**\n   * Show on buttons that navigate state backward\n   */\n  prev: 'Ankstesnis',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Pridėti visas reikšmes',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Pridėti pasirinktas reikšmes',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Pašalinti visas reikšmes',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Pašalinti pasirinktas reikšmes',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Pasirinkti datą',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Pakeisti datą',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'Uždaryti',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Atidaryti',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Prašome priimti ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} turi būti po ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} turi būti ateityje.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} gali būti tik abėcėlės simboliai.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} gali būti tik raidės ir skaičiai.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} gali būti tik raidės ir tarpai.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} turi būti abėcėlės simbolių.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} turi būti raidžių arba skaičių.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} turi būti raidžių arba tarpų.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} turi būti simbolių.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} turi būti didžioji raidė.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} turi būti mažoji raidė.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} turi būti skaičių.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} turi būti simbolis.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} turi būti tik didžiosios raidės.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} turi būti tik mažosios raidės.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} turi būti prieš ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} turi būti praeityje.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Šis laukas buvo sukonfigūruotas neteisingai ir jo negalima pateikti.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} turi būti tarp ${a} ir ${b}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} nesutampa.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} nėra tinkama data, naudokite formatą ${args[0]}`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'Šis laukas buvo sukonfigūruotas neteisingai ir jo negalima pateikti'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} turi būti tarp ${date(args[0])} ir ${date(args[1])}`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Įveskite teisingą el. pašto adresą.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} nesibaigia su ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} nėra leistina reikšmė.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} turi būti bent vienas simbolis.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} turi būti mažiau arba lygiai ${max} ${getByQuantity(\n        max,\n        'simbolis',\n        'simboliai',\n        'simbolių'\n      )}.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} turi būti iš ${max} ${getByQuantity(\n        max,\n        'simbolio',\n        'simbolių',\n        'simbolių'\n      )}.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} turi būti daugiau arba lygiai ${min} ${getByQuantity(\n        min,\n        'simbolis',\n        'simboliai',\n        'simbolių'\n      )}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)} turi būti tarp ${min} ir ${max} simbolių.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} nėra leistina reikšmė.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `Negali turėti daugiau nei ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} turi būti mažiau arba lygiai ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Neleidžiami jokie failų formatai.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} turi būti tokio tipo: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `Negali turėti mažiau nei ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `Turi būti bent ${args[0]} ${name} .`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}” nėra leidžiamas ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} turi būti skaičius.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' arba ')} yra privaloma.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} yra privaloma.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} neprasideda su ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Įveskite teisingą URL.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'Pasirinkta data yra netinkama.',\n}\n\nexport const lt = { ui, validation }\n", "import { FormKitValidationMessages } from '@formkit/validation'\n\n/**\nHere we can import additional helper functions to assist in formatting our\nlanguage. Feel free to add additional helper methods to libs/formats if it\nassists in creating good validation messages for your locale.\n*/\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on a button for adding additional items.\n   */\n  add: 'Pievienot',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Noņemt',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Noņemt visus',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Piedodiet, visi lauki nav aizpildīti.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Iesniegt',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Nav izvēlēts fails',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Uz augšu',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Uz leju',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Ielādējas...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Ielādēt vēl',\n  /**\n   * Show on buttons that navigate state forward\n   */\n  next: 'Tālāk',\n  /**\n   * Show on buttons that navigate state backward\n   */\n  prev: 'Atpakaļ',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Pievienot visas vērtības',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Pievienojiet izvēlēto vērtību',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Noņemt visas vērtības',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Noņemt izvēlētās vērtības',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Izvēlieties datumu',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Mainīt datumu',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'Aizvērt',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Atvērt',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Lūdzu apstipriniet ${name}`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${name} jābūt pēc ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${name} jābūt pēc šodienas datuma.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${name} var saturēt tikai alfabētiskās rakstzīmes.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${name} var saturēt tikai burtus un ciparus.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${name} var saturēt tikai burtus un atstarpes.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${name} jābūt pirms ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${name} jābūt pirms šodienas datuma.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Šis lauks tika aizpildīts nepareizi un nevar tikt iesniegts.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${name} jābūt starp ${a} un ${b}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${name} nesakrīt.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${name} nav pareizs datums, lūdzu lietojiet formātu ${args[0]}`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'Šis lauks tika aizpildīts nepareizi un nevar tikt iesniegts.'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${name} jābūt starp ${date(args[0])} un ${date(args[1])}`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Lūdzu ierakstiet pareizu e-pasta adresi.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${name} nebeidzas ar ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${name} nav atļauta vērtība.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${name} jābūt vismaz vienam simbolam.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${name} jābūt mazāk par vai ${max} simboliem.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${name} jābūt ${max} simbolu garumā.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${name} jābūt vismaz ${min} simboliem.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${name} jābūt starp ${min} un ${max} simboliem.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${name} nav atļauta vērtība.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `Nevar būt vairāk par ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${name} nevar būt mazāk par ${args[0]} vai ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Atļauti nenoteikti faila formāti.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} faila formāti var būt šādi: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `Nevar būt mazāk par ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `Jābūt vismaz ${args[0]} ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}” nav atļauta vērtība iekš ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${name} jābūt ciparam.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${name} ir obligāti jāaizpilda`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${name} nesākas ar ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Lūdzu pievienojiet pareizu URL.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'Izvēlētais datums ir nepareizs.',\n}\n\nexport const lv = { ui, validation }\n", "import { FormKitValidationMessages } from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on a button for adding additional items.\n   */\n  add: 'Нэмэх',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Хасах',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Бүгдийг хасах',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Уучлраарай, зарим нүдэн дахь өгөгдөл дутуу байна.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Илгээх',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Файл сонгоогүй байна',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Дээшээ',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Доошоо',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Ачааллаж байна...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Нэмж ачааллах',\n  /**\n   * Show on buttons that navigate state forward\n   */\n  next: 'Дараагийн',\n  /**\n   * Show on buttons that navigate state backward\n   */\n  prev: 'Өмнөх',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Бүх утгуудыг нэмэх',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Сонгогдсон утгуудыг нэмэх',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Бүх утгуудыг устгах',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Сонгогдсон утгуудыг хасах',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Огноо сонгох',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Огноо өөрчлөх',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'Хаах',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Нээлттэй',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `${name} утгыг зөвшөөрнө үү.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} нь ${date(args[0])}-ны дараа орох ёстой.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} утга ирээдүйг заах ёстой.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} зөвхөн үсэг агуулах ёстой.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} зөвхөн үсэг болон тоог агуулах ёстой.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} зөвхөн үсэг болон зай агуулах ёстой.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} нь ${date(args[0])}-ны өмнө байх ёстой.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} өнгөрсөн огноо байх ёстой.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Энэ нүдэн дэхь өгөгдөл буруу учраас илгээх боломжгүй.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} нь заавал ${a}, ${b} хоёрын дунд байх ёстой.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} таарахгүй байна.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} нь хүчинтэй огноо биш тул ${\n        args[0]\n      } гэсэн огноог ашиглаарай.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'Энэхүү нүд буруу тул цааш илгээх боломжгүй.'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} нь заавал ${date(args[0])}, ${date(\n      args[1]\n    )} хоёр огноон дунд байх ёстой.`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Та хүчинтэй имейл хаягаа оруулна уу.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} нь ${list(args)} гэсэн утгаар төгсөөгүй байна.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} нь зөвшөөрөгдөх утга биш.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} дээр хаяж нэг үсэг байх ёстой`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)}-н урт нь ${max}-ээс ихгүй байх ёстой.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} нь ${max} урт байвал зүгээр.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)}-н урт нь ${min}-ээс их буюу тэнцүү байж болно.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)}-н урт нь ${min}, ${max} хоёрын дунд байх ёстой.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} нь зөвшөөрөгдөх утга биш.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `${name} нь ${args[0]}-аас их байж болохгүй.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} нь ${args[0]}-тай тэнцүү эсвэл бага байх ёстой.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Файлын формат буруу.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} төрөл нь ${args[0]} байх ёстой.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `${name} нь ${args[0]}-аас их байж болохгүй.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${name} нь дор хаяж ${args[0]}-тай тэнцүү байх ёстой.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}” бол зөвшөөрөгдөх ${name} гэсэн утга биш.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} зөвхөн тоо байх ёстой.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} байх ёстой.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} нь ${list(args)}-ээр эхлээгүй байна.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Хүчннтай URL оруулна уу.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'Сонгосон огноо буруу байна.',\n}\n\nexport const mn = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on a button for adding additional items.\n   */\n  add: 'Legg til',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Fjern',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Fjern alle',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Beklager, noen felter er ikke fylt ut korrekt.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Send inn',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Ingen fil valgt',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Flytt opp',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Flytt ned',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Laster...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Last mer',\n  /**\n   * Show on buttons that navigate state forward\n   */\n  next: 'Neste',\n  /**\n   * Show on buttons that navigate state backward\n   */\n  prev: 'Forrige',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Legg til alle verdier',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Legg til valgte verdier',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Fjern alle verdier',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Fjern valgte verdier',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Velg dato',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Endre dato',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Vennligst aksepter ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} må være senere enn ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} må være i fremtiden.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} kan bare inneholde alfabetiske tegn.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} kan bare inneholde bokstaver og tall.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} kan bare inneholde bokstaver og mellomrom.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} must contain alphabetical characters.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} must contain letters and numbers.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} must contain letters and spaces.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} must contain symbol.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} must contain uppercase.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} must contain lowercase.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} must contain number.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} can only contain symbol.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} can only contain uppercase.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} can only contain lowercase.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} må være tidligere enn ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} må være i fortiden.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Dette feltet er feilkonfigurert og kan ikke innsendes.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} må være mellom ${a} og ${b}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} stemmer ikke overens.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} er ikke en gyldig dato, vennligst bruk formatet ${\n        args[0]\n      }`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'Dette feltet er feilkonfigurert og kan ikke innsendes.'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} må være mellom ${date(args[0])} og ${date(args[1])}`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Vennligst oppgi en gyldig epostadresse.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} slutter ikke med ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} er ikke en tillatt verdi.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} må ha minst ett tegn.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} må ha mindre enn eller nøyaktig ${max} tegn.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} skal være ${max} tegn langt.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} må ha mer enn eller nøyaktig ${min} tegn.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)} må ha mellom ${min} og ${max} tegn.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} er ikke en tillatt verdi.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `Kan ikke ha mer enn ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} må være mindre enn eller nøyaktig ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Ingen tillatte filformater.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} må være av typen: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `Kan ikke ha mindre enn ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)} må være minst ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}” er ikke en tillatt ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} må være et tall.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' eller ')} er nødvendig.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} er påkrevd.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} starter ikke med ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Vennligst inkluder en gyldig url.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'Den valgte datoen er ugyldig.',\n}\n\nexport const nb = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on buttons for adding new items.\n   */\n  add: 'Toevoegen',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Verwijderen',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Alles verwijderen',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Sorry, niet alle velden zijn correct ingevuld.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Versturen',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Geen bestand gekozen',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Naar boven gaan',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Naar beneden verplaatsen',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Aan het laden...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Meer laden',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: 'Vervolgens',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: 'Voorgaand',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Alle waarden toevoegen',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Geselecteerde waarden toevoegen',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Alle waarden verwijderen',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Geselecteerde waarden verwijderen',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Kies een datum',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Datum wijzigen',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'Sluiten',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Open',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Accepteer de ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} moet na ${date(args[0])} zijn.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} moet in de toekomst liggen.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} mag alleen alfabetische tekens bevatten.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} mag alleen letters en cijfers bevatten.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} mag alleen letters en spaties bevatten.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} moet alfabetische tekens bevatten.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} moet letters of cijfers bevatten.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} moet letters of spaties bevatten.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} moet een symbool bevatten.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} moet hoofdletters bevatten.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} moet kleine letters bevatten.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} moet cijfers bevatten.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} moet een symbool zijn.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} mag alleen hoofdletters bevatten.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} mag alleen kleine letters bevatten.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} moet vóór ${date(args[0])} vallen.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} moet in het verleden liggen.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Dit veld is onjuist geconfigureerd en kan niet worden verzonden.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} moet tussen ${a} en ${b} liggen.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} komt niet overeen.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} is geen geldige datum, gebruik de notatie ${args[0]}`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'Dit veld is onjuist geconfigureerd en kan niet worden verzonden'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} moet tussen ${date(args[0])} en ${date(args[1])} liggen`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Vul een geldig e-mailadres in.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} eindigt niet met ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} is geen toegestane waarde.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} moet minimaal één teken zijn.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} mag maximaal ${max} tekens lang zijn.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} moet ${max} tekens lang zijn.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} moet minimaal ${min} tekens lang zijn.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)} moet tussen de ${min} en ${max} tekens zijn.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} is geen toegestane waarde.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `Mag niet meer dan ${args[0]} ${name} hebben.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} moet kleiner zijn dan of gelijk zijn aan ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Geen bestandsformaten toegestaan.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} moet van het type: ${args[0]} zijn`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `Mag niet minder dan ${args[0]} ${name} hebben.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)} moet minimaal ${args[0]} zijn.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `\"${value}\" is geen toegestane ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} moet een getal zijn.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' of ')} is vereist.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} is verplicht.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} begint niet met ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Voer een geldige URL in.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'De geselecteerde datum is ongeldig.',\n}\n\nexport const nl = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on buttons for adding new items.\n   */\n  add: 'Dodaj',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Usuń',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Usuń wszystko',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Nie wszystkie pola zostały wypełnione poprawnie.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Wyślij',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Nie wybrano pliku',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Przesuń w górę',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Przesuń w dół',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Ładowanie...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Załaduj więcej',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: 'Kolejny',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: 'Poprzednia',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Dodaj wszystkie wartości',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Dodaj wybrane wartości',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Usuń wszystkie wartości',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Usuń wybrane wartości',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Wybierz datę',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Zmień datę',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'Zamknij',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Otwórz',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Proszę zaakceptować ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} musi być po ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} musi być w przyszłości.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `Pole ${s(name)} może zawierać tylko znaki alfabetyczne.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `Pole ${s(name)} może zawierać tylko znaki alfanumeryczne.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `Pole ${s(name)} mogą zawierać tylko litery i spacje.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} musi zawierać znaki alfabetyczne.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} musi zawierać litery lub cyfry.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} musi zawierać litery lub spacje.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} musi zawierać symbol.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} musi zawierać wielkie litery.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} musi zawierać małe litery.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} musi zawierać liczby.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} musi być symbolem.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} może zawierać tylko wielkie litery.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} może zawierać tylko małe litery.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} musi być przed ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} musi być w przeszłości.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Pole zostało wypełnione niepoprawnie i nie może zostać wysłane.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `Wartość pola ${s(name)} musi być pomiędzy ${a} i ${b}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} nie pokrywa się.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `Wartość pola ${s(\n        name\n      )} nie jest poprawną datą, proszę użyć formatu ${args[0]}`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'To pole zostało wypełnione niepoprawnie i nie może zostać wysłane'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `Data w polu ${s(name)} musi być pomiędzy ${date(args[0])} i ${date(\n      args[1]\n    )}`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Proszę wpisać poprawny adres email.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `Pole ${s(name)} nie kończy się na ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `Pole ${s(name)} nie jest dozwoloną wartością.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `Pole ${s(name)} musi posiadać minimum jeden znak.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `Pole ${s(name)} musi zawierać ${max} lub mniej znaków.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `Pole ${s(name)} musi zawierać ${min} lub więcej znaków.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `Pole ${s(name)} musi mieć ${min} znaków.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `Pole ${s(name)} musi mieć ${min}-${max} znaków.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `Pole ${s(name)} zawiera niedozwolone znaki.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `Nie można mieć więcej niż ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `Wartość pola ${s(name)} musi być mniejsza lub równa ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Nie podano dozwolonych typów plików.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} musi być typem: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `Musisz podać więcej niż ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return ` Musisz podać conajmniej ${args[0]} ${s(name)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `Wartość pola ${name} jest niedozwolona.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} musi być numerem.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' lub ')} wymagany jest.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `Pole ${s(name)} jest wymagane.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `Wartośc pola ${s(name)} nie zaczyna się od ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Wprowadź prawidłowy adres URL.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'Wybrana data jest nieprawidłowa.',\n}\n\nexport const pl = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on buttons for adding new items.\n   */\n  add: 'Incluir',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Remover',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Remover todos',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Desculpe, alguns campos não foram preenchidos corretamente.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Enviar',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Nenhum arquivo selecionado.',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Mover para cima',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Mover para baixo',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Carregando...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Carregar mais',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: 'Próximo',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: 'Anterior',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Adicione todos os valores',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Adicionar valores selecionados',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Remover todos os valores',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Remover valores selecionados',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Escolha a data',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Data da alteração',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'Fechar',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Aberto',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Por favor aceite o ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} precisa ser depois de ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} precisa ser no futuro.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} precisa conter apenas letras.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} pode conter apenas letras e números.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} pode conter apenas números e espaços.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} deve conter caracteres alfabéticos.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} deve conter letras ou números.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} deve conter letras ou espaços.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} deve conter um símbolo.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} deve conter letras maiúsculas.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} deve conter letras minúsculas.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} deve conter números.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} deve ser um símbolo.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} só pode conter letras maiúsculas.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} só pode conter letras minúsculas.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} precisa ser antes de ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} precisa ser no passado.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Este campo não foi configurado corretamente e não pode ser submetido.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} precisa ser entre ${a} e ${b}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} não é igual.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} não é uma data válida, por favor use este formato ${\n        args[0]\n      }`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'Este campo não foi configurado corretamente e não pode ser submetido.'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} precisa ser entre ${date(args[0])} e ${date(args[1])}`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Por favor, insira um endereço de email válido.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} não termina com ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} não é um valor permitido.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = first <= second ? first : second\n    const max = second >= first ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} precisa conter ao menos um caractere.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} precisa ser menor ou igual a ${max} caracteres.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} precisa conter ${max} caracteres.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} precisa ser maior ou igual a ${min} caracteres.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)} precisa ter entre ${min} e ${max} caracteres.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} não é um valor permitido.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `Não pode ter mais de ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} precisa ser menor ou igual a ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Não há formatos de arquivos permitidos.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} precisa ser do tipo: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `Não pode ter menos de ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)} precisa ser pelo menos ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}” não é um(a) ${name} permitido(a).`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} precisa ser um número.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' ou ')} é necessário.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} é obrigatório.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} não começa com ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Por favor, insira uma url válida.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'A data selecionada é inválida.',\n}\n\nexport const pt = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on buttons for adding new items.\n   */\n  add: 'Adăugare',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Elimină',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Elimină tot',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Pare rău, unele câmpuri nu sunt corect completate.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Trimite',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Nu este selectat nici un fișier',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Mutare în sus',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Mutare în jos',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Se încarcă...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Încărcați mai mult',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: 'Urmatorul',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: 'Precedent',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Adăugați toate valorile',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Adăugarea valorilor selectate',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Eliminați toate valorile',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Eliminați valorile selectate',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Alege data',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Modificați data',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'Închide',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Deschis',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Te rog acceptă ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} trebuie să fie după ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} trebuie sa fie în viitor.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} poate conține doar caractere alafetice.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} poate conține doar litere și numere.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} poate conține doar litere și spații.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} trebuie să conțină caractere alfabetice.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} trebuie să conțină litere sau numere.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} trebuie să conțină litere sau spații.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} trebuie să conțină simbol.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} trebuie să conțină majuscule.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} trebuie să conțină litere mici.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} trebuie să conțină numere.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} trebuie să fie un simbol.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} poate conține doar litere mari.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} poate conține doar litere mici.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} trebuie să preceadă ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} trebuie să fie în trecut.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Câmpul a fost configurat incorect și nu poate fi trimis.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} trebuie să fie între ${a} și ${b}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} nu se potrivește.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} nu este validă, te rog foloște formatul ${args[0]}`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'Câmpul a fost incorect configurat și nu poate fi trimis.'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} trebuie să fie între ${date(args[0])} și ${date(\n      args[1]\n    )}`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Te rog folosește o adresă de email validă.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} nu se termină cu ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} nu este o valoare acceptată.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} trebuie sa conțină cel puțin un caracter.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} trebuie sa aibă cel mult ${max} caractere.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} ar trebui să aibă ${max} caractere lungi.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} trebuie să aibă cel puțin ${min} caractere.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)} trebuie să aibă între ${min} și ${max} caractere.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} nu este o valoare acceptată.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `Nu poate avea mai mult decat ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} trebuie să fie cel mult egal cu ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Tipul de fișier neacceptat.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} trebuie să fie de tipul: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `Nu poate avea mai puțin decât ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)} trebuie să fie cel puțin ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}” nu este o valoare acceptă pentru ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} trebuie să fie un număr.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' sau ')} este necesar.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} este necesar.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} nu începe cu ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Introduceți o adresă URL validă.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'Data selectată este nevalidă.',\n}\n\nexport const ro = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on buttons for adding new items.\n   */\n  add: 'Добавить',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Удалить',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Убрать все',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Извините, не все поля заполнены верно.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Отправить',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Файл не выбран',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Переместить вверх',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Переместить вниз',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Загрузка...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Загрузить больше',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: 'Следующий',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: 'Предыдущий',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Добавить все значения',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Добавить выбранные значения',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Удалить все значения',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Удалить выбранные значения',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Выберите дату',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Изменить дату',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'Закрыть',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Открыть',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Пожалуйста, примите ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `Дата ${s(name)} должна быть позже ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `Дата ${s(name)} должна быть в будущем.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `Поле ${s(name)} может содержать только буквы.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `Поле ${s(name)} может содержать только буквы и цифры.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} могут содержать только буквы и пробелы.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} должен содержать алфавитные символы.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} должен содержать буквы или цифры.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} должно содержать буквы или пробелы.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} должен содержать символ.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} должно содержать прописные буквы.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} должно содержать строчные буквы.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} должен содержать числа.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} должен быть символом.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} может содержать только прописные буквы.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} может содержать только буквы нижнего регистра.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `Дата ${s(name)} должна быть раньше ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `Дата ${s(name)} должна быть в прошлом.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Это поле заполнено неверно и не может быть отправлено.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `Поле ${s(name)} должно быть между ${a} и ${b}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `Поле ${s(name)} не совпадает.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `Поле ${s(\n        name\n      )} имеет неверную дату. Пожалуйста, используйте формат ${args[0]}`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'Это поле заполнено неверно и не может быть отправлено.'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `Дата ${s(name)} должна быть между ${date(args[0])} и ${date(\n      args[1]\n    )}`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Пожалуйста, введите действительный электронный адрес.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `Поле ${s(name)} не должно заканчиваться на ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `Поле ${s(name)} имеет неподустимое значение.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `Поле ${s(name)} должно содержать минимум один символ.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `Длина поля ${s(\n        name\n      )} должна быть меньше или равна ${max} символам.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `Длина ${s(name)} должна составлять ${max} символов.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `Длина поля ${s(\n        name\n      )} должна быть больше или равна ${min} символам.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `Длина поля ${s(name)} должна быть между ${min} и ${max} символами.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `Поле ${s(name)} имеет недопустимое значение.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `Не может быть выбрано больше, чем ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `Поле ${s(name)} должно быть меньше или равно ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Не указаны поддержиавемые форматы файла.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `Формат файла в поле ${s(name)} должен быть: ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `Не может быть выбрано меньше, чем ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `Поле ${s(name)} должно быть не менее, чем ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}” не поддерживается в поле ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `Поле ${s(name)} должно быть числом.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' или ')} требуется.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `Поле ${s(name)} обязательно для заполнения.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `Поле ${s(name)} должно начинаться с ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Пожалуйста, введите действительный URL-адрес.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'Выбранная дата недействительна.',\n}\n\nexport const ru = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on a button for adding additional items.\n   */\n  add: 'Pridať',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Odstrániť',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Odstrániť všetko',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Prepáčte, ale nie všetky polia sú vyplnené správne.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Odoslať',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Nebol vybraný žiadny súbor',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Posunúť hore',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Posunúť dole',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Načítavanie...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Načítať viac',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: 'Ďalšie',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: 'Predošlý',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Pridajte všetky hodnoty',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Pridajte vybrané hodnoty',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Odstrániť všetky hodnoty',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Odstrániť vybrané hodnoty',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Vyberte dátum',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Zmena dátumu',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'Zavrieť',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Otvorené',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Prosím zaškrtnite ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} musí byť za ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} musí byť v budúcnosti.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} môže obsahovať iba písmená.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} môže obsahovať iba písmená a čísla.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} môže obsahovať iba písmená a medzery.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} musí obsahovať abecedné znaky.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} musí obsahovať písmená alebo číslice.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} musí obsahovať písmená alebo medzery.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} musí obsahovať symbol.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} musí obsahovať veľké písmená.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} musí obsahovať malé písmená.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} musí obsahovať čísla.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} musí byť symbol.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} môže obsahovať iba veľké písmená.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} môže obsahovať len malé písmená.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} musí byť pred ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} musí byť v minulosti.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Toto pole bolo nesprávne nakonfigurované a nemôže byť odoslané.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} musí byť medzi ${a} and ${b}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} does not match.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} nie je platným dátumom, prosím, použite formát ${\n        args[0]\n      }`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'Toto pole bolo nesprávne nakonfigurované a nemôže byť odoslané.'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} musí byť medzi ${date(args[0])} a ${date(args[1])}`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Prosím, zadajte platnú emailovú adresu.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} nekončí na ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} nie je povolená hodnota.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} musí mať najmenej jeden znak.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} musí byť menšie alebo rovné ako ${max} znakov.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} by mala mať dĺžku ${max} znakov.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} musí byť väčšie alebo rovné ako ${min} znakov.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)} musí byť medzi ${min} až ${max} znakov.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} nie je povolená hodnota.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `Nie je možné použiť viac než ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} musí byť menšie alebo rovné ako ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Nie sú povolené formáty súborov.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} musí byť typu: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `Nemôže byť menej než ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)} musí byť minimálne ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}” nie je povolené hodnota pre ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} musí byť číslo.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' alebo ')} je potrebný.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} je povinné.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} nezačíná s ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Zadajte platnú adresu URL.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'Vybraný dátum je neplatný.',\n}\n\nexport const sk = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on buttons for adding new items.\n   */\n  add: 'Dodaj',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Odstrani',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Odstrani vse',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Nekatera polja niso pravilno izpolnjena.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Pošlji',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Nobena datoteka ni izbrana',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Premakni se navzgor',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Premakni se navzdol',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Nalaganje...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Naloži več',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: 'Naslednji',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: 'Prejšnji',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Dodajte vse vrednosti',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Dodajanje izbranih vrednosti',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Odstranite vse vrednosti',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Odstrani izbrane vrednosti',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Izberite datum',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Spremeni datum',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'Zapri',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Odpri',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Prosimo popravite ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} mora biti po ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} mora biti v prihodnosti.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} lahko vsebuje samo znake abecede.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} lahko vsebuje samo črke in številke.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} lahko vsebuje samo črke in presledke.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} mora vsebovati abecedne znake.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} mora vsebovati črke ali številke.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} mora vsebovati črke ali presledke.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} mora vsebovati simbol.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} mora vsebovati velike črke.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} mora vsebovati male črke.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} mora vsebovati številke.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} mora biti simbol.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} lahko vsebuje le velike črke.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} lahko vsebuje le male črke.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} mora biti pred ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} mora biti v preteklosti.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `To polje je narobe nastavljeno in ne mora biti izpolnjeno.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} mora biti med ${a} in ${b}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} se ne ujema.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} ni pravilen datum, prosimo uporabite format ${args[0]}`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'To polje je narobe nastavljeno in ne mora biti izpolnjeno.'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} mora biti med ${date(args[0])} in ${date(args[1])}`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Vnesite veljaven e-poštni naslov.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} se mora kočati z ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} ni dovoljena vrednost.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} mora vsebovati vsaj en znak.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} mora vsebovati največ ${max} znakov.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} mora biti dolg ${max} znakov.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} mora vsebovati vsaj ${min} znakov.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)} mora vsebovati med ${min} in ${max} znakov.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} ni dovoljena vrednost.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `Največ je ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} je lahko največ ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Nobena vrsta datoteke ni dovoljena.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} mora biti tipa: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `Najmanj ${args[0]} ${name} je dovoljenih.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)} mora biti vsaj ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}” ni dovoljen(a/o) ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} mora biti številka.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' ali ')} zahtevan je.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} je zahtevan(o/a).`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} se mora začeti z ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Vnesite veljaven URL.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'Izbrani datum je neveljaven.',\n}\n\nexport const sl = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on a button for adding additional items.\n   */\n  add: 'Dodaj',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Ukloni',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Ukloni sve',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Pojedina polja nisu ispravno ispunjena.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Pošalji',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Fajl nije odabran',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Pomerite se gore',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Pomeri se dole',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Učitavanje...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Učitaj više',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: 'Sledeća',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: 'Prethodna',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Dodajte sve vrednosti',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Dodajte izabrane vrednosti',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Uklonite sve vrednosti',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Uklonite izabrane vrednosti',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Izaberite datum',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Promenite datum',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'Zatvori',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Otvori',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Molimo prihvatite ${name}`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} mora biti posle ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} mora biti u budućnosti.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} može da sadrži samo abecedne znakove.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} može da sadrži samo slova i brojeve.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} može da sadrži samo slova i razmake.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} mora da sadrži abecedne znakove.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} mora da sadrži slova ili brojeve.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} mora da sadrži slova ili razmake.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} mora da sadrži simbol.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} mora da sadrži velika slova.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} mora da sadrži mala slova.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} mora da sadrži brojeve.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} mora biti simbol.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} može da sadrži samo velika slova.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} može da sadrži samo mala slova.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} mora biti pre ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} mora biti u prošlosti.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Ovo polje je pogrešno konfigurisano i ne može se poslati.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} mora biti između ${a} i ${b}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} se ne podudara.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} nije važeći datum, molimo Vas koristite format ${\n        args[0]\n      }`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'Ovo polje je pogrešno konfigurisano i ne može se poslati'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} mora biti između ${date(args[0])} i ${date(args[1])}`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Unesite ispravnu e-mail adresu.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} se ne završava sa ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} nije dozvoljena vrednost`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} mora biti najmanje jedan karakter.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} mora biti manji ili jednaki od ${max} karaktera.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} treba da bude ${max} znakova dugačak.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} mora biti veći ili jednaki od ${min} karaktera.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)} mora biti između ${min} i ${max} karaktera.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} nije dozvoljena vrednost.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `Ne može imati više od ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} mora biti manji ili jednaki od ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Nisu dozvoljeni formati datoteka.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} mora biti tipa: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `Ne može imati manje od ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)} mora da ima najmanje ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}” nije dozvoljeno ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} mora biti broj.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' или ')} потребан је.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} je obavezno polje.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} ne počinje sa ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Unesite važeću URL adresu.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'Izabrani datum je nevažeći.',\n}\n\nexport const sr = { ui, validation }\n", "// Please copy and paste the file your just downloaded here\nimport {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Ta bort',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Ta bort alla',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Tyvärr är inte alla fält korrekt ifyllda',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Skicka',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Ingen fil vald',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Flytta upp',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Flytta ner',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Laddar...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Ladda mer',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: 'Nästa',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: 'Föregående',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Lägg till alla värden',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Lägg till valda värden',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Ta bort alla värden',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Ta bort valda värden',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Välj datum',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Ändra datum',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'Stäng',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Öppna',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Var god acceptera ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} måste vara efter ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} måste vara framåt i tiden.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} kan enbart innehålla bokstäver i alfabetet.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} kan bara innehålla bokstäver och siffror.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} kan bara innehålla bokstäver och blanksteg.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} måste innehålla alfabetiska tecken.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} måste innehålla bokstäver eller siffror.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} måste innehålla bokstäver eller mellanslag.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} måste innehålla symbol.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} måste innehålla versaler.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} måste innehålla gemener.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} måste innehålla siffror.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} måste vara en symbol.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} kan bara innehålla versaler.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} kan bara innehålla små bokstäver.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} måste vara före ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} måste vara bakåt i tiden.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Det här fältet ställdes inte in korrekt och kan inte användas.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} måste vara mellan ${a} och ${b}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} matchar inte.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} är inte ett giltigt datum, var god använd formatet ${\n        args[0]\n      }`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'Det här fältet ställdes inte in korrekt och kan inte användas'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} måste vara mellan ${date(args[0])} och ${date(args[1])}`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Var god fyll i en giltig e-postadress.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} slutar inte med ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} är inte ett godkänt värde.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} måste ha minst ett tecken.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} måste vara ${max} tecken eller färre.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} bör vara ${max} tecken långa.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} måste vara ${min} tecken eller fler.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)} måste vara mellan ${min} och ${max} tecken.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} är inte ett godkänt värde.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `Kan inte ha mer än ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} måste vara ${args[0]} eller mindre.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Inga filtyper tillåtna.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} måste vara av filtypen: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `Kan inte ha mindre än ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)} måste vara minst ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}” är inte ett godkänt ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} måste vara en siffra.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' eller ')} krävs.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} är obligatoriskt.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} börjar inte med ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Ange en giltig URL.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'Det valda datumet är ogiltigt.',\n}\n\nexport const sv = { ui, validation }\n", "import { FormKitValidationMessages } from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on a button for adding additional items.\n   */\n  add: 'Aumenta',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Hasai',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Hasai Hotu',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Deskulpa, iha informasaun neebe sala iha formuláriu',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Submete',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Seidauk hili file',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Muda ba leten',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Muda ba kotuk',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Hein lai...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Foti tan',\n  /**\n   * Show on buttons that navigate state forward\n   */\n  next: 'Ba oin',\n  /**\n   * Show on buttons that navigate state backward\n   */\n  prev: 'Ba kotuk',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Aumenta hotu',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Aumenta buat neebe hili ona',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Hasai hotu',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Hasai buat neebe hili ona',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Hili data',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Troka data',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Favor ida simu ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} tenki depoid ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} tenki iha futuru.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} bele uza letra deit.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} bele uza letra ka numeru deit.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} bele uza letra ka numeru deit.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} tenki antes ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} tenki antes ohin loron.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Informasaun nee la loos no la bele submete.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} tenki iha klaran entre ${a} no ${b}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} la hanesan.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} la loos, favor ida hakerek tuir ${args[0]}`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'Informasaun nee la loos no la bele submete.'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} tenki iha ${date(args[0])} no ${date(\n      args[1]\n    )} nia klaran`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Favor hakerek endresu email neebe loos.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} la remata ho ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `la bele uza ${s(name)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} tenki iha letra ida ka liu.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} tenki badak liu ${max} letra.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} tenki iha letra ${max}.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} tenki iha letra ${min} ka liu.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)} tenki iha letra ${min} too ${max}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `la bele uza ${s(name)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `La bele iha ${args[0]} ka liu ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} tenki kiik liu ka hanesan ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return `La bele simu 'format' ida.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} tenki iha tipo: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `Presiza ${args[0]} ${name} ka liu.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${name} tenki ${args[0]} ka liu.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `La bele uza “${value}” ba ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} tenki numeru.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `Presiza ${s(name)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} la komesa ho ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Favor hakerek URL neebe loos.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'Data la loos.',\n}\n\nexport const tet = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on a button for adding additional items.\n   */\n  add: 'Илова кардан',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Хориҷ кардан',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Ҳамаро хориҷ кунед',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Бубахшед, на ҳама майдонҳо дуруст пур карда шудаанд.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Пешниҳод кунед',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Ягон файл интихоб нашудааст',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Ба боло ҳаракат кунед',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Ба поён ҳаракат кунед',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Дар ҳоли боргузорӣ',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Бештар бор кунед',\n  /**\n   * Show on buttons that navigate state forward\n   */\n  next: 'Баъдӣ',\n  /**\n   * Show on buttons that navigate state backward\n   */\n  prev: 'Гузашта',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Ҳама арзишҳоро илова кунед',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Илова кардани арзишҳои интихобшуда',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Ҳама арзишҳоро хориҷ кунед',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Арзишҳои интихобшударо хориҷ кунед',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Сана интихоб кунед',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Тағйир додани сана',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Лутфан ${name}-ро қабул кунед`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} бояд пас аз ${date(args[0])} бошад.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} бояд дар оянда бошад.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} метавонад танҳо аломатҳои алифборо дар бар гирад.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} метавонад танҳо ҳарфҳо ва рақамҳоро дар бар гирад.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} метавонад танҳо ҳарфҳо ва фосилаҳоро дар бар гирад.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} must contain alphabetical characters.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} must contain letters and numbers.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} must contain letters and spaces.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} must contain symbol.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} must contain uppercase.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} must contain lowercase.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} must contain number.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} can only contain symbol.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} can only contain uppercase.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} can only contain lowercase.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} бояд пеш аз ${date(args[0])} бошад.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} бояд дар гузашта бошад.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Ин майдон нодуруст танзим шудааст ва онро пешниҳод кардан ғайриимкон аст.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} бояд дар байни ${a} ва ${b} бошад.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} мувофиқат намекунад.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} санаи дуруст нест, лутфан формати ${\n        args[0]\n      }-ро истифода баред`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'Ин майдон нодуруст танзим шудааст ва онро пешниҳод кардан ғайриимкон аст'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} бояд дар байни ${date(args[0])} ва ${date(\n      args[1]\n    )} бошад`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Лутфан нишонаи имейли амалкунандаро ворид намоед.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} бо ${list(args)} ба охир намерасад.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} арзиши иҷозатдодашуда нест.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} бояд ҳадди аққал як аломат бошад.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} бояд аз ${max} аломат камтар ё баробар бошад.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} бояд ${max} аломат бошад.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} бояд аз ${min} аломат зиёд ё баробар бошад.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)} бояд дар байни ${min} ва ${max} аломат бошад.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} арзиши иҷозатдодашуда нест.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `Зиёда аз ${args[0]} ${name} дошта наметавонад.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} бояд аз ${args[0]} камтар ё баробар бошад.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Ягон формати файл иҷозат дода намешавад.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} бояд чунин намуд бошад: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `Камтар аз ${args[0]} ${name} дошта наметавонад.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)} бояд ҳадди аққал ${args[0]} бошад.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `\"${value}\" ${name} иҷозат дода намешавад.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} бояд рақам бошад.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' ё ')} зарур а`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} лозим аст.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} бо ${list(args)} оғоз намешавад.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Лутфан URL-и дурустро дохил кунед.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'Санаи интихобшуда нодуруст аст.',\n}\n\nexport const tg = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on buttons for adding new items.\n   */\n  add: 'เพิ่ม',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'เอาออก',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'เอาออกทั้งหมด',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'ขออภัย ข้อมูลบางช่องที่กรอกไม่ถูกต้อง',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'ส่ง',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'ยังไม่ได้เลือกไฟล์',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'เลื่อนขึ้น',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'เลื่อนลง',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'กำลังโหลด...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'โหลดเพิ่มเติม',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: 'ถัดไป',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: 'ก่อนหน้า',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'เพิ่มค่าทั้งหมด',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'เพิ่มค่าที่เลือก',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'ลบค่าทั้งหมด',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'ลบค่าที่เลือก',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'เลือกวันที่',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'เปลี่ยนวันที่',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'ปิด',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'เปิด',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `กรุณายอมรับ ${name}`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} จะต้องเป็นวันที่หลังจาก ${date(args[0])}`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} จะต้องเป็นวันที่ที่ยังไม่มาถึง`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} สามารถเป็นได้แค่ตัวอักษรเท่านั้น`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} สามารถเป็นได้แค่ตัวอักษรและตัวเลขเท่านั้น`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} สามารถเป็นได้แค่ตัวอักษรและเว้นวรรคเท่านั้น`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} ต้องมีตัวอักษรตัวอักษร`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} ต้องมีตัวอักษรหรือตัวเลข`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} ต้องมีตัวอักษรหรือช่องว่าง`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} ต้องมีสัญลักษณ์`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} ต้องมีตัวพิมพ์ใหญ่`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} ต้องมีตัวพิมพ์เล็ก`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} ต้องมีตัวเลข`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} จะต้องเป็นสัญลักษณ์`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} เท่านั้นที่สามารถมีตัวอักษรตัวพิมพ์ใหญ่`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} เท่านั้นที่สามารถมีตัวอักษรตัวพิมพ์เล็ก`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} จะต้องเป็นวันที่ที่มาก่อน ${date(args[0])}`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} จะต้องเป็นวันที่ที่ผ่านมาแล้ว`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `ช่องนี้ถูกตั้งค่าอย่างไม่ถูกต้อง และจะไม่สามารถส่งข้อมูลได้`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} จะต้องเป็นค่าระหว่าง ${a} และ ${b}`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} ไม่ตรงกัน`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} ไม่อยู่ในรูปแบบวันที่ที่ถูกต้อง กรุณากรอกตามรูปแบบ ${\n        args[0]\n      }`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'ช่องนี้ถูกตั้งค่าอย่างไม่ถูกต้อง และจะไม่สามารถส่งข้อมูลได้'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} จะต้องเป็นวันที่ระหว่าง ${date(args[0])} และ ${date(\n      args[1]\n    )}`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'กรุณากรอกที่อยู่อีเมลทีถูกต้อง',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} จะต้องลงท้ายด้วย ${list(args)}`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} ไม่ใช่ค่าที่อนุญาตให้กรอก`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} จะต้องมีความยาวอย่างน้อยหนึ่งตัวอักษร`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} จะต้องมีความยาวไม่เกิน ${max} ตัวอักษร`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} ควรจะเป็น ${max} ตัวอักษรยาว`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} จะต้องมีความยาว ${min} ตัวอักษรขึ้นไป`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)} จะต้องมีความยาวระหว่าง ${min} และ ${max} ตัวอักษร`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} ไม่ใช่ค่าที่อนุญาตให้กรอก`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `ไม่สามารถเลือกมากกว่า ${args[0]} ${name} ได้`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} จะต้องมีค่าไม่เกิน ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'ไม่มีประเภทของไฟล์ที่อนุญาต'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} จะต้องเป็นไฟล์ประเภท ${args[0]} เท่านั้น`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `ไม่สามารถเลือกน้อยกว่า ${args[0]} ${name} ได้`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)} จะต้องมีค่าอย่างน้อย ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}” ไม่ใช่ค่า ${name} ที่อนุญาตให้กรอก`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} จะต้องเป็นตัวเลขเท่านั้น`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' หรือ ')} ต้องการ.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `กรุณากรอก ${s(name)}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} จะต้องเริ่มต้นด้วย ${list(args)}`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `กรุณาระบุที่อยู่ลิงก์ให้ถูกต้อง`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'วันที่ที่เลือกไม่ถูกต้อง',\n}\n\nexport const th = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on buttons for adding new items.\n   */\n  add: 'Ekle',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Kaldır',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Hepsini kaldır',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Maalesef, tüm alanlar doğru doldurulmadı.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Gönder',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Dosya yok',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Yukarı Taşı',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Aşağı taşı',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Yükleniyor...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Daha fazla yükle',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: 'Sonraki',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: 'Önceki',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Tüm değerleri ekle',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Seçili değerleri ekle',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Tüm değerleri kaldır',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Seçili değerleri kaldır',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Tarih seçin',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Tarihi değiştir',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'Kapat',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Açık',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Lütfen ${name}'yi kabul edin.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} ${date(args[0])}'den sonra olmalıdır.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} gelecekte bir zaman olmalıdır.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} sadece alfabetik karakterler içerebilir.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} sadece alfabetik karakterler ve sayı içerebilir.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} yalnızca harf ve boşluk içerebilir.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} alfabetik karakterler içermelidir.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} harf veya rakamı içermelidir.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} harf veya boşluk içermelidir.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} sembol içermelidir.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} büyük harf içermelidir.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} küçük harf içermelidir.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} sayı içermelidir.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} bir sembol olmalıdır.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} yalnızca büyük harfler içerebilir.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} yalnızca küçük harfler içerebilir.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} ${date(args[0])} tarihinden önce olmalı.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} geçmişte olmalı.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Alan yanlış yapılandırılmış ve gönderilemez.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} ${a} ve ${b} aralığında olmalı.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} eşleşmiyor.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} geçerli bir tarih değil, lütfen ${\n        args[0]\n      } biçimini kullanın.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'Alan yanlış yapılandırılmış ve gönderilemez.'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)}, ${date(args[0])} ve ${date(args[1])} aralığında olmalı.`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Lütfen geçerli bir e-mail adresi girin.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} ${list(args)} ile bitmiyor.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} izin verilen bir değer değil.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} en azından bir karakter uzunluğunda olmalı.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} ${max}'e eşit veya daha küçük olmalı.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} ${max} karakter uzunluğunda olmalıdır.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} ${min}'e eşit veya daha büyük olmalı.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)}, ${min} ve ${max} karakter uzunluğu aralığında olmalı.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} izin verilen bir değer değil.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `${name}'in uzunluğu ${args[0]}'dan daha uzun olamaz.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} en azından ${args[0]} uzunluğunda veya ona eşit olmalı.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Hiçbir dosya türüne izin verilmez.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} şu tiplerden biri olmalı: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `${name}'in uzunluğu ${args[0]}'dan daha kısa olamaz.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)} en azından ${args[0]} uzunluğunda olmalı.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}” ${name} olamaz.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} sayı olmalı.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' veya ')} gereklidir.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} gerekli.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} ${list(args)} ile başlamıyor.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Lütfen geçerli bir URL girin.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'Seçilen tarih geçersiz.',\n}\n\nexport const tr = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on a button for adding additional items.\n   */\n  add: 'Додати',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Видалити',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Видалити все',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Вибачте, не всі поля заповнені правильно.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Відправити',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Файл не вибрано',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Рухатися вгору',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Пересунути вниз',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Завантаження...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Завантажте більше',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: 'Наступний',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: 'Попередній',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Додати всі значення',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Додати вибрані значення',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Вилучити всі значення',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Вилучити вибрані значення',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Виберіть дату',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Змінити дату',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'Закрити',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Відкрити',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Будь ласка, прийміть ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `Дата ${s(name)} повинна бути пізніше за ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `Дата ${s(name)} має бути в майбутньому.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `Поле ${s(name)} може містити лише літери.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `Поле ${s(name)} може містити лише літери та цифри.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `Поле ${s(name)} може містити лише літери та пробіли.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} повинен містити алфавітні символи.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} повинен містити букви або цифри.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} повинен містити літери або пробіли.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} повинен містити символ.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} повинен містити великі регістри.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} повинен містити малі регістри.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} повинен містити цифри.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} має бути символом.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} може містити лише великі літери.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} може містити лише малі літери.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `Дата ${s(name)} повинна бути раніше за ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `Дата ${s(name)} повинна бути в минулому.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Це поле заповнено неправильно і не може бути надіслано.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `Поле ${s(name)} повинно бути між ${a} та ${b}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `Поле ${s(name)} не збігається.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `Поле ${s(\n        name\n      )} має неправильну дату. Будь ласка, використовуйте формат ${args[0]}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'Це поле заповнено неправильно і не може бути надіслано.'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `Дата ${s(name)} повинна бути між ${date(args[0])} та ${date(\n      args[1]\n    )}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Будь ласка, введіть дійсну електронну адресу.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `Поле ${s(name)} не повинно закінчуватися на ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `Поле ${s(name)} має неприпустиме значення.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `Поле ${s(name)} має містити щонайменше один символ.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `Довжина поля ${s(\n        name\n      )} повинна бути меншою або дорівнювати ${max} символам.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} має бути довжиною ${max} символів.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `Довжина поля ${s(\n        name\n      )} повинна бути більшою або дорівнювати ${min} символам.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `Довжина поля ${s(\n      name\n    )} повинна бути між ${min} та ${max} символами.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `Поле ${s(name)} має неприпустиме значення.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `Не може бути вибрано більше ніж ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `Поле ${s(name)} має бути менше або дорівнювати ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Не вказано дозволені типи файлів.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `Тип файлу в полі ${s(name)} має бути: ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `Не може бути вибрано менше ніж ${args[0]} ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `Поле ${s(name)} має бути не менше ніж ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}” не дозволено в полі ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `Поле ${s(name)} має бути числом.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' або ')} потрібно.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `Поле ${s(name)} є обов'язковим.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `Поле ${s(name)} має починатися з ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Будь ласка, введіть коректну URL-адресу.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'Вибрана дата недійсна.',\n}\n\nexport const uk = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on a button for adding additional items.\n   */\n  add: \"Qo'shish\",\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: \"O'chirish\",\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: \"Hammasini o'chirish\",\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: \"Kechirasiz, barcha maydonlar to'g'ri to'ldirilmagan.\",\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Yuborish',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Hech qanday fayl tanlanmagan',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Yuqoriga ko’taring',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Pastga siljish',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Yuklanmoqda...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Ko’proq yuklang',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: 'Keyingi',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: 'Oldingi',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: `Barcha qiymatlarni qo'shish`,\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: `Tanlangan qiymatlarni qoʻshish`,\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Barcha qiymatlarni olib tashlang',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Tanlangan qiymatlarni olib tashlash',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Sanani tanlang',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: `O'zgartirish sanasi`,\n  /**\n   * Shown when there is something to close\n   */\n  close: 'Yopish',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Ochiq',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `${name} ni qabul qiling.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} ${date(args[0])} dan keyin bo'lishi kerak.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} kelajakda bo'lishi kerak.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(\n      name\n    )} faqat alifbo tartibidagi belgilardan iborat bo'lishi mumkin.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} faqat harflar va raqamlardan iborat bo'lishi mumkin.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} faqat harf va bo'shliqlardan iborat bo'lishi mumkin.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} alfavit belgilarini o'z ichiga olishi kerak.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} harflar yoki raqamlarni o'z ichiga olishi kerak.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} harflar yoki bo'shliqlar bo'lishi kerak.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} belgisi bo'lishi kerak.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} katta harfni o'z ichiga olishi kerak.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} kichik harflarni o'z ichiga olishi kerak.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} raqamlarini o'z ichiga olishi kerak.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} belgisi bo'lishi kerak.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} faqat katta harflarni o'z ichiga olishi mumkin.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} faqat kichik harflarni o'z ichiga olishi mumkin.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} ${date(args[0])} dan oldin bo'lishi kerak`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} o'tmishda bo'lishi kerak.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Bu maydon noto'g'ri sozlangan va uni yuborib bo'lmaydi.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} ${a} va ${b} orasida bo'lishi kerak.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} mos emas.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} haqiqiy sana emas, iltimos ${\n        args[0]\n      } formatidan foydalaning`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return \"Bu maydon noto'g'ri sozlangan va uni yuborib bo'lmaydi\"\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} ${date(args[0])} va ${date(\n      args[1]\n    )} oralig'ida bo'lishi kerak`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Iltimos amaldagi e-mail manzilingizni kiriting.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} ${list(args)} bilan tugamaydi.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} ruxsat etilgan qiymat emas.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} kamida bitta belgidan iborat bo'lishi kerak.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} ${max} ta belgidan kam yoki teng bo'lishi kerak.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} bo'lishi kerak ${max} belgilar uzun.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} ${min} ta belgidan ko'p yoki teng bo'lishi kerak.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(\n      name\n    )} ${min} va ${max} gacha belgilardan iborat bo'lishi kerak.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} ruxsat etilgan qiymat emas.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `${args[0]} ${name} dan ortiq bo'lishi mumkin emas.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} ${args[0]} dan kichik yoki teng bo'lishi kerak.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Fayl formatlariga ruxsat berilmagan.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} quyidagi turdagi bo'lishi kerak: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `${args[0]} ${name} dan kam bo'lmasligi kerak.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)} kamida ${args[0]} bo'lishi kerak.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `\"${value}\" ruxsat berilmagan ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} raqam bo'lishi kerak.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' yoki ')} kerak.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} talab qilinadi.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} ${list(args)} bilan boshlanmaydi.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Iltimos, tegishli URL manzilini kiriting.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'Tanlangan sana yaroqsiz.',\n}\n\nexport const uz = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on buttons for adding new items.\n   */\n  add: 'Thêm',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: 'Xoá',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: 'Xoá tất cả',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: 'Xin lỗi, không phải tất cả các trường đều được nhập đúng.',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: 'Gửi',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: 'Chưa chọn file',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: 'Di chuyển lên',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: 'Di chuyển xuống',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: 'Đang tải...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: 'Tải thêm',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: 'Tiếp',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: 'Trước',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: 'Thêm tất cả các giá trị',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: 'Thêm các giá trị đã chọn',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: 'Loại bỏ tất cả các giá trị',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: 'Loại bỏ các giá trị đã chọn',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: 'Chọn ngày',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: 'Thay đổi ngày',\n  /**\n   * Shown when there is something to close\n   */\n  close: 'Đóng',\n  /**\n   * Shown when there is something to open.\n   */\n  open: 'Mở',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `Hãy đồng ý với ${name}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} phải sau ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} phải trong tương lai.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} có thể chỉ bao gồm các chữ cái alphabet.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} có thể chỉ bao gồm các chữ cái và chữ số.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} chỉ có thể chứa các chữ cái và khoảng trắng.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} phải chứa các ký tự chữ cái.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} phải chứa chữ cái hoặc số.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} phải chứa chữ cái hoặc dấu cách.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} phải chứa ký hiệu.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} phải chứa chữ hoa.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} phải chứa chữ thường.`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} phải chứa số.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} phải là một ký hiệu.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} chỉ có thể chứa chữ hoa.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} chỉ có thể chứa chữ thường.`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} phải trước ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} phải trong quá khứ.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `Trường này đã được thiết lập sai và không thể gửi.`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} phải ở giữa ${a} và ${b}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} không khớp.`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} không phải ngày hợp lệ, hãy sử dụng định dạng ${\n        args[0]\n      }`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return 'Trường này đã được thiết lập sai và không thể gửi.'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} phải ở giữa khoảng từ ${date(args[0])} đến ${date(\n      args[1]\n    )}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: 'Hãy nhập một địa chỉ email hợp lệ.',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} không kết thúc với ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} không phải một giá trị được cho phép.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} phải có độ dài tối thiểu một ký tự.`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} phải có độ dài tối đa ${max} ký tự.`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} nên dài ${max} ký tự.`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} phải có độ dài tối thiểu ${min} ký tự.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(\n      name\n    )} phải có độ dài tối đa trong khoảng từ ${min} đến ${max} ký tự.`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} không phải một giá trị được cho phép.`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `${name} không thể lớn hơn ${args[0]}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} phải tối đa bằng ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return 'Định dạng tệp tin này không được phép.'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} phải là một trong các dạng: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `${name} không thể nhỏ hơn ${args[0]}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)} phải tối thiểu bằng ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `\"${value}\" không phải giá trị ${name} được phép.`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} phải là một số.`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join(' hoặc ')} cần có.`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} là bắt buộc.`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} không bắt đầu với ${list(args)}.`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `Vui lòng nhập một URL hợp lệ.`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: 'Ngày đã chọn không hợp lệ.',\n}\n\nexport const vi = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on a button for adding additional items.\n   */\n  add: '添加',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: '移除',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: '移除全部',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: '抱歉，部分字段未被正确填写。',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: '提交',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: '未选择文件',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: '上移',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: '下移',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: '加载中...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: '加载更多',\n  /**\n   * Shown on buttons that navigate state forward\n   */\n  next: '下一步',\n  /**\n   * Shown on buttons that navigate state backward\n   */\n  prev: '上一步',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: '添加所有值',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: '添加所选值',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: '移除所有值',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: '移除所选值',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: '选择日期',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: '更改日期',\n  /**\n   * Shown when there is something to close\n   */\n  close: '关闭',\n  /**\n   * Shown when there is something to open.\n   */\n  open: '打开',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `请接受${name}。`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)}必须晚于${date(args[0])}。`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)}必须是未来的日期。`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)}只能包含英文字母。`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)}只能包含字母和数字。`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)}只能包含字母和空格。`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter.\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha}\n   */\n  contains_alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical characters.\"> */\n    return `${s(name)} 必须包含字母字符`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#contains_alphanumeric}\n   */\n  contains_alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphanumeric characters.\"> */\n    return `${s(name)} 必须包含字母或数字。`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#contains_alpha-spaces}\n   */\n  contains_alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical and non-space characters.\"> */\n    return `${s(name)} 必须包含字母或空格。`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no symbol\n   * @see {@link https://formkit.com/essentials/validation#contains_symbol}\n   */\n  contains_symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only alphanumeric and space characters.\"> */\n    return `${s(name)} 必须包含符号。`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no uppercase\n   * @see {@link https://formkit.com/essentials/validation#contains_uppercase}\n   */\n  contains_uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} 必须包含大写字母。`\n    /* </i18n> */\n  },\n\n  /**\n   * The value have no lowercase\n   * @see {@link https://formkit.com/essentials/validation#contains_lowercase}\n   */\n  contains_lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains only non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} 必须包含小写字母。`\n    /* </i18n> */\n  },\n\n  /**\n   *  The value have no numeric\n   * @see {@link https://formkit.com/essentials/validation#contains_numeric}\n   */\n  contains_numeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value have no numeric.\"> */\n    return `${s(name)} 必须包含数字。`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not symbol\n   * @see {@link https://formkit.com/essentials/validation#symbol}\n   */\n  symbol({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains alphanumeric and space characters.\"> */\n    return `${s(name)} 必须是符号。`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not uppercase\n   * @see {@link https://formkit.com/essentials/validation#uppercase}\n   */\n  uppercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-uppercase characters.\"> */\n    return `${s(name)} 只能包含大写字母。`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not lowercase\n   * @see {@link https://formkit.com/essentials/validation#lowercase}\n   */\n  lowercase({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical-lowercase characters.\"> */\n    return `${s(name)} 只能包含小写字母。`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)}必须早于${date(args[0])}。`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)}必须是过去的日期。`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `该字段未被正确设置而无法提交。`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)}必须在${a}和${b}之间。`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)}不匹配。`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)}不是合法日期，请使用 ${args[0]} 格式`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return '该字段未被正确设置而无法提交'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)}必须在${date(args[0])}和${date(args[1])}之间`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: '请输入合法的电子邮件地址。',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)}必须以${list(args)}结尾。`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)}是不允许的。`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)}至少要有一个字符。`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)}必须少于或等于${max}个字符。`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)}必须包含${max}个字符。`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)}必须多于或等于${min}个字符。`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)}必须介于${min}和${max}个字符之间。`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)}是不允许的。`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `${name}不得多于${args[0]}个值。`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${name}不得大于${args[0]}。`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return '没有允许的文件格式。'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)}的类型必须为：${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `${name}不得少于${args[0]}个值。`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${s(name)}不得小于${args[0]}。`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `\"${value}\"不是一个合法的${name}。`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)}必须为数字。`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join('或')}${labels}需要。`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)}不得留空。`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)}必须以${list(args)}开头。`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `请输入有效的 URL。`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: '所选日期无效。',\n}\n\nexport const zh = { ui, validation }\n", "import {\n  FormKitValidationMessages,\n  createMessageName,\n} from '@formkit/validation'\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\nimport { sentence as s, list, date, order } from '../formatters'\nimport { FormKitLocaleMessages } from '../i18n'\n\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui: FormKitLocaleMessages = {\n  /**\n   * Shown on a button for adding additional items.\n   */\n  add: '新增',\n  /**\n   * Shown when a button to remove items is visible.\n   */\n  remove: '移除',\n  /**\n   * Shown when there are multiple items to remove at the same time.\n   */\n  removeAll: '移除全部',\n  /**\n   * Shown when all fields are not filled out correctly.\n   */\n  incomplete: '很抱歉，部分欄位填寫錯誤',\n  /**\n   * Shown in a button inside a form to submit the form.\n   */\n  submit: '提交',\n  /**\n   * Shown when no files are selected.\n   */\n  noFiles: '尚未選取檔案',\n  /**\n   * Shown on buttons that move fields up in a list.\n   */\n  moveUp: '上移',\n  /**\n   * Shown on buttons that move fields down in a list.\n   */\n  moveDown: '下移',\n  /**\n   * Shown when something is actively loading.\n   */\n  isLoading: '載入中...',\n  /**\n   * Shown when there is more to load.\n   */\n  loadMore: '載入更多',\n  /**\n   * Show on buttons that navigate state forward\n   */\n  next: '下一個',\n  /**\n   * Show on buttons that navigate state backward\n   */\n  prev: '上一個',\n  /**\n   * Shown when adding all values.\n   */\n  addAllValues: '加入全部的值',\n  /**\n   * Shown when adding selected values.\n   */\n  addSelectedValues: '加入選取的值',\n  /**\n   * Shown when removing all values.\n   */\n  removeAllValues: '移除全部的值',\n  /**\n   * Shown when removing selected values.\n   */\n  removeSelectedValues: '移除選取的值',\n  /**\n   * Shown when there is a date to choose.\n   */\n  chooseDate: '選擇日期',\n  /**\n   * Shown when there is a date to change.\n   */\n  changeDate: '變更日期',\n  /**\n   * Shown when there is something to close\n   */\n  close: '關閉',\n  /**\n   * Shown when there is something to open.\n   */\n  open: '開放',\n}\n\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation: FormKitValidationMessages = {\n  /**\n   * The value is not an accepted value.\n   * @see {@link https://formkit.com/essentials/validation#accepted}\n   */\n  accepted({ name }): string {\n    /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n    return `請接受 ${name}`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not after\n   * @see {@link https://formkit.com/essentials/validation#date-after}\n   */\n  date_after({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n      return `${s(name)} 必須晚於 ${date(args[0])}`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} 必須晚於今日`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a letter.\n   * @see {@link https://formkit.com/essentials/validation#alpha}\n   */\n  alpha({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n    return `${s(name)} 欄位儘能填寫英文字母`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not alphanumeric\n   * @see {@link https://formkit.com/essentials/validation#alphanumeric}\n   */\n  alphanumeric({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n    return `${s(name)} 欄位僅能填寫英文字母與數字`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not letter and/or spaces\n   * @see {@link https://formkit.com/essentials/validation#alpha-spaces}\n   */\n  alpha_spaces({ name }) {\n    /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n    return `${s(name)} 欄位儘能填寫英文字母與空白`\n    /* </i18n> */\n  },\n\n  /**\n   * The date is not before\n   * @see {@link https://formkit.com/essentials/validation#date-before}\n   */\n  date_before({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n      return `${s(name)} 必須早於 ${date(args[0])}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n    return `${s(name)} 必須早於今日`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not between two numbers\n   * @see {@link https://formkit.com/essentials/validation#between}\n   */\n  between({ name, args }) {\n    if (isNaN(args[0]) || isNaN(args[1])) {\n      /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n      return `欄位值錯誤，無法提交`\n      /* </i18n> */\n    }\n    const [a, b] = order(args[0], args[1])\n    /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n    return `${s(name)} 必須介於 ${a} 和 ${b}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The confirmation field does not match\n   * @see {@link https://formkit.com/essentials/validation#confirm}\n   */\n  confirm({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n    return `${s(name)} 與目標不一致`\n    /* </i18n> */\n  },\n\n  /**\n   * The value is not a valid date\n   * @see {@link https://formkit.com/essentials/validation#date-format}\n   */\n  date_format({ name, args }) {\n    if (Array.isArray(args) && args.length) {\n      /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n      return `${s(name)} 不是有效的日期，請使用 ${args[0]} 格式`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n    return '欄位值錯誤，無法提交'\n    /* </i18n> */\n  },\n\n  /**\n   * Is not within expected date range\n   * @see {@link https://formkit.com/essentials/validation#date-between}\n   */\n  date_between({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n    return `${s(name)} 必須介於 ${date(args[0])} 和 ${date(args[1])}`\n    /* </i18n> */\n  },\n\n  /**\n   * Shown when the user-provided value is not a valid email address.\n   * @see {@link https://formkit.com/essentials/validation#email}\n   */\n  email: '請輸入有效的 email',\n\n  /**\n   * Does not end with the specified value\n   * @see {@link https://formkit.com/essentials/validation#ends-with}\n   */\n  ends_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n    return `${s(name)} 的結尾必須是 ${list(args)}`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#is}\n   */\n  is({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n    return `${s(name)} 欄位的值不合規則`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not match specified length\n   * @see {@link https://formkit.com/essentials/validation#length}\n   */\n  length({ name, args: [first = 0, second = Infinity] }) {\n    const min = Number(first) <= Number(second) ? first : second\n    const max = Number(second) >= Number(first) ? second : first\n    if (min == 1 && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n      return `${s(name)} 欄位必須至少包含一個字`\n      /* </i18n> */\n    }\n    if (min == 0 && max) {\n      /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n      return `${s(name)} 的字數必須小於等於 ${max}`\n      /* </i18n> */\n    }\n    if (min === max) {\n      /* <i18n case=\"Shown when first and second argument supplied to the rule are the same, and the user-provided value is not any of the arguments supplied to the rule.\"> */\n      return `${s(name)} 的字數必須為 ${max}`\n      /* </i18n> */\n    }\n    if (min && max === Infinity) {\n      /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n      return `${s(name)} 的字數必須大於等於 ${min}`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n    return `${s(name)} 的字數必須介於 ${min} 和 ${max}`\n    /* </i18n> */\n  },\n\n  /**\n   * Value is not a match\n   * @see {@link https://formkit.com/essentials/validation#matches}\n   */\n  matches({ name }) {\n    /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n    return `${s(name)} 欄位的值無效`\n    /* </i18n> */\n  },\n\n  /**\n   * Exceeds maximum allowed value\n   * @see {@link https://formkit.com/essentials/validation#max}\n   */\n  max({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n      return `不能超過 ${args[0]} 個 ${name}.`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n    return `${s(name)} 必須小於等於 ${args[0]}.`\n    /* </i18n> */\n  },\n\n  /**\n   * The (field-level) value does not match specified mime type\n   * @see {@link https://formkit.com/essentials/validation#mime}\n   */\n  mime({ name, args }) {\n    if (!args[0]) {\n      /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n      return '非有效的檔案格式'\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n    return `${s(name)} 可接受的檔案格式為: ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not fulfill minimum allowed value\n   * @see {@link https://formkit.com/essentials/validation#min}\n   */\n  min({ name, node: { value }, args }) {\n    if (Array.isArray(value)) {\n      /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n      return `不可少於 ${args[0]} 個 ${name}`\n      /* </i18n> */\n    }\n    /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n    return `${name} 必須大於等於 ${args[0]}`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not an allowed value\n   * @see {@link https://formkit.com/essentials/validation#not}\n   */\n  not({ name, node: { value } }) {\n    /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n    return `“${value}” 不是 ${name} 欄位可接受的值`\n    /* </i18n> */\n  },\n\n  /**\n   *  Is not a number\n   * @see {@link https://formkit.com/essentials/validation#number}\n   */\n  number({ name }) {\n    /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n    return `${s(name)} 欄位必須是數字`\n    /* </i18n> */\n  },\n\n  /**\n   * Require one field.\n   * @see {@link https://formkit.com/essentials/validation#require-one}\n   */\n  require_one: ({ name, node, args: inputNames }) => {\n    const labels = inputNames\n      .map((name) => {\n        const dependentNode = node.at(name)\n        if (dependentNode) {\n          return createMessageName(dependentNode)\n        }\n        return false\n      })\n      .filter((name) => !!name)\n    labels.unshift(name)\n    /* <i18n case=\"Shown when the user-provided has not provided a value for at least one of the required fields.\"> */\n    return `${labels.join('或')}${labels}需要。`\n    /* </i18n> */\n  },\n\n  /**\n   * Required field.\n   * @see {@link https://formkit.com/essentials/validation#required}\n   */\n  required({ name }) {\n    /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n    return `${s(name)} 是必要欄位`\n    /* </i18n> */\n  },\n\n  /**\n   * Does not start with specified value\n   * @see {@link https://formkit.com/essentials/validation#starts-with}\n   */\n  starts_with({ name, args }) {\n    /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n    return `${s(name)} 的開頭必須是 ${list(args)}`\n    /* </i18n> */\n  },\n\n  /**\n   * Is not a url\n   * @see {@link https://formkit.com/essentials/validation#url}\n   */\n  url() {\n    /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n    return `請輸入有效的 url`\n    /* </i18n> */\n  },\n  /**\n   * Shown when the date is invalid.\n   */\n  invalidDate: '選取的日期無效',\n}\n\nexport const zhTW = { ui, validation }\n", "import { FormKitNode, FormKitPlugin, FormKitTextFragment } from '@formkit/core'\nimport { has } from '@formkit/utils'\n\n/**\n * Note: We are choosing not to implement via Intl.Locale because the support is\n * not yet good enough to be used without polyfill consideration, and that\n * polyfill is 36.3Kb min + gzip — larger than all of FormKit.\n *\n * https://formatjs.io/docs/polyfills/intl-locale/\n *\n * Instead we use a very minimal solution that should provide very good support\n * for all users, and we're happy to expand this package if we see areas where\n * localization is not quite good enough. Also, once support for Intl.Locale\n * becomes better, we would expect this package to switch much of it's\n * underlying locale parsing logic to nose native APIs.\n */\n\n/**\n * A registry of locale messages — this is simply a keyed/value object with\n * string keys (message name) and either string values (for simple returns) or\n * functions that receive a context object.\n *\n * @public\n */\nexport interface FormKitLocaleMessages {\n  [index: string]: string | ((...args: any[]) => string)\n}\n\n/**\n * A locale is just a collection of locale message registries, they are keyed\n * by the type (like a namespace) ex: \"validation\" or \"ui\". Plugin authors\n * can declare their own types too.\n *\n * @public\n */\nexport interface FormKitLocale {\n  ui: FormKitLocaleMessages\n  [index: string]: FormKitLocaleMessages\n}\n\n/**\n * The locale registry is just a key-value pair of locale indexes ('ar', 'en',\n * 'it', etc.) to their respective locales.\n *\n * @public\n */\nexport interface FormKitLocaleRegistry {\n  [index: string]: FormKitLocale\n}\n\n/**\n * A registry of all i18n nodes.\n */\nconst i18nNodes = new Set<FormKitNode>()\n\n/**\n * The currently active locale.\n */\nlet activeLocale: string | null = null\n\n/**\n * Create a new internationalization plugin for FormKit.\n *\n * @param registry - The registry of {@link @formkit/i18n#FormKitLocaleRegistry | FormKitLocales}.\n *\n * @returns {@link @formkit/core#FormKitPlugin | FormKitPlugin}\n *\n * @public\n */\nexport function createI18nPlugin(\n  registry: FormKitLocaleRegistry\n): FormKitPlugin {\n  return function i18nPlugin(node: FormKitNode) {\n    i18nNodes.add(node)\n    if (activeLocale) node.config.locale = activeLocale\n\n    node.on('destroying', () => i18nNodes.delete(node))\n    let localeKey = parseLocale(node.config.locale, registry)\n    let locale = localeKey ? registry[localeKey] : ({} as FormKitLocale)\n    /* If the locale prop changes, update the active locale */\n    node.on('prop:locale', ({ payload: lang }) => {\n      localeKey = parseLocale(lang, registry)\n      locale = localeKey ? registry[localeKey] : ({} as FormKitLocale)\n      // Run through all the messages in the store and update with new locale\n      node.store.touch()\n    })\n    node.on('prop:label', () => node.store.touch())\n    node.on('prop:validationLabel', () => node.store.touch())\n\n    /**\n     * Hook into the core text or t() hook to perform localization on the\n     * output of core functionality.\n     */\n    node.hook.text((fragment: FormKitTextFragment, next) => {\n      const key = fragment.meta?.messageKey || fragment.key\n      if (has(locale, fragment.type) && has(locale[fragment.type], key)) {\n        const t = locale[fragment.type][key]\n        if (typeof t === 'function') {\n          fragment.value = Array.isArray(fragment.meta?.i18nArgs)\n            ? t(...fragment.meta!.i18nArgs) // eslint-disable-line @typescript-eslint/no-non-null-assertion\n            : t(fragment)\n        } else {\n          fragment.value = t\n        }\n      }\n      return next(fragment)\n    })\n  }\n}\n\n/**\n * Parse ISO 639-1 and 639-2 to a valid locale key.\n *\n * @param locale - An ISO 639-1 and (optionally) ISO 639-2 language tag. For these are valid locale keys:\n * zh\n * zh-CN\n * zh-HK\n * en\n * en-GB\n *\n * @param availableLocales - An array of locales that may be valid.\n *\n * @public\n */\nfunction parseLocale(\n  locale: string,\n  availableLocales: FormKitLocaleRegistry\n): string | false {\n  if (has(availableLocales, locale)) {\n    return locale\n  }\n  const [lang] = locale.split('-')\n  if (has(availableLocales, lang)) {\n    return lang\n  }\n  for (const locale in availableLocales) {\n    return locale\n  }\n  return false\n}\n\n/**\n * Change the active locale of all FormKit instances (global).\n * @param locale - The locale to change to\n */\nexport function changeLocale(locale: string) {\n  activeLocale = locale\n  for (const node of i18nNodes) {\n    node.config.locale = locale\n  }\n}\n", "/**\n * The official FormKit internationalization (i18n) plugin. This package\n * contains the locales and the plugin that integrates FormKit with these\n * locales. Read the {@link https://formkit.com/essentials/internationalization\n * | internationalization documentation} for usage instructions.\n *\n * @packageDocumentation\n */\n\nimport { ar } from './locales/ar'\nimport { az } from './locales/az'\nimport { bg } from './locales/bg'\nimport { bs } from './locales/bs'\nimport { ca } from './locales/ca'\nimport { cs } from './locales/cs'\nimport { da } from './locales/da'\nimport { de } from './locales/de'\nimport { el } from './locales/el'\nimport { en } from './locales/en'\nimport { es } from './locales/es'\nimport { fa } from './locales/fa'\nimport { fi } from './locales/fi'\nimport { fr } from './locales/fr'\nimport { fy } from './locales/fy'\nimport { he } from './locales/he'\nimport { hr } from './locales/hr'\nimport { hu } from './locales/hu'\nimport { id } from './locales/id'\nimport { is } from './locales/is'\nimport { it } from './locales/it'\nimport { ja } from './locales/ja'\nimport { kk } from './locales/kk'\nimport { ko } from './locales/ko'\nimport { lt } from './locales/lt'\nimport { lv } from './locales/lv'\nimport { mn } from './locales/mn'\nimport { nb } from './locales/nb'\nimport { nl } from './locales/nl'\nimport { pl } from './locales/pl'\nimport { pt } from './locales/pt'\nimport { ro } from './locales/ro'\nimport { ru } from './locales/ru'\nimport { sk } from './locales/sk'\nimport { sl } from './locales/sl'\nimport { sr } from './locales/sr'\nimport { sv } from './locales/sv'\nimport { tet } from './locales/tet'\nimport { tg } from './locales/tg'\nimport { th } from './locales/th'\nimport { tr } from './locales/tr'\nimport { uk } from './locales/uk'\nimport { uz } from './locales/uz'\nimport { vi } from './locales/vi'\nimport { zh } from './locales/zh'\nimport { zhTW } from './locales/zh-TW'\n\n/**\n * Export all of the plugin logic\n */\nexport * from './i18n'\n\n/**\n * Export all the available locales at once.\n *\n * @public\n */\nexport const locales = {\n  ar,\n  az,\n  bg,\n  bs,\n  ca,\n  cs,\n  da,\n  de,\n  el,\n  en,\n  es,\n  fa,\n  fi,\n  fr,\n  fy,\n  he,\n  hr,\n  hu,\n  id,\n  it,\n  ja,\n  kk,\n  ko,\n  lt,\n  lv,\n  nb,\n  nl,\n  pl,\n  pt,\n  ro,\n  ru,\n  sk,\n  sl,\n  sr,\n  sv,\n  tet,\n  tg,\n  th,\n  tr,\n  uk,\n  uz,\n  vi,\n  zh,\n  'zh-TW': zhTW,\n  is,\n  mn,\n}\n\n/**\n * Export each locale individually for people who want to cherry pick.\n */\nexport {\n  ar,\n  az,\n  bg,\n  bs,\n  ca,\n  cs,\n  da,\n  de,\n  el,\n  en,\n  es,\n  fa,\n  fi,\n  fr,\n  fy,\n  he,\n  hr,\n  hu,\n  id,\n  it,\n  ja,\n  kk,\n  ko,\n  lt,\n  lv,\n  nb,\n  nl,\n  pl,\n  pt,\n  ro,\n  ru,\n  sk,\n  sl,\n  sr,\n  sv,\n  tet,\n  tg,\n  th,\n  tr,\n  uk,\n  uz,\n  vi,\n  zh,\n  zhTW,\n  is,\n  mn,\n}\n\n/**\n * Export all formatter functions.\n */\nexport * from './formatters'\n", "import { camel, extend, has } from '@formkit/utils'\nimport { FormKitLibrary, FormKitPlugin, FormKitNode } from '@formkit/core'\n\n/**\n * Creates a plugin based on a list of {@link @formkit/core#FormKitLibrary | FormKitLibrary}.\n *\n * @param libraries - One or many {@link @formkit/core#FormKitLibrary | FormKitLibrary}.\n *\n * @returns {@link @formkit/core#FormKitPlugin | FormKitPlugin}\n *\n * @public\n */\nexport function createLibraryPlugin(\n  ...libraries: FormKitLibrary[]\n): FormKitPlugin {\n  /**\n   * Merge all provided library items.\n   */\n  const library = libraries.reduce(\n    (merged, lib) => extend(merged, lib) as FormKitLibrary,\n    {} as FormKitLibrary\n  )\n  /* eslint-disable-next-line @typescript-eslint/no-empty-function */\n  const plugin = () => {}\n  /**\n   * Enables the hook that exposes all library inputs.\n   * @param node - The primary plugin\n   */\n  plugin.library = function (node: FormKitNode) {\n    const type = camel(node.props.type)\n    if (has(library, type)) {\n      node.define(library[type])\n    }\n  }\n  return plugin\n}\n", "import {\n  FormKitPlugin,\n  FormKitGroupValue,\n  FormKitTypeDefinition,\n  FormKitSectionsSchema,\n  FormKitNode,\n  FormKitClasses,\n  FormKitFrameworkContext,\n  FormKitMessage,\n} from '@formkit/core'\nimport { FormKitFile } from './index'\n\n/**\n * These are props that are used as conditionals in one or more inputs, and as\n * such they need to be defined on all input types. These should all be defined\n * explicitly as \"undefined\" here, and then defined as their specific type\n * in the FormKitInputProps interface only on the inputs that use them.\n * @public\n */\nexport interface FormKitConditionalProps {\n  onValue: undefined\n  offValue: undefined\n  options: undefined\n  number: undefined\n}\n\n/**\n * An attempt to capture all non-undefined values. This is used to define\n * various conditionals where undefined is not a concrete type, but all other\n * values need to take one logical branch.\n *\n * @public\n */\nexport type AllReals =\n  | number\n  | string\n  | boolean\n  | CallableFunction\n  | Array<any>\n  | null\n  | Record<any, any>\n/**\n * This is the base interface for providing prop definitions to the FormKit\n * component. It is used to define the props that are available to the each\n * component in the FormKit library by using a discriminated union type. The\n * structure of this interface is:\n *\n * ```ts\n * interface FormKitInputProps {\n *  typeString: { type: 'string'; value?: string } // <-- All unique props\n * }\n * ```\n *\n * All inputs will also inherit all props from FormKitBaseInputProps.\n *\n * Note: It is important that all inputs provide a type and a value prop.\n * @public\n */\nexport interface FormKitInputProps<Props extends FormKitInputs<Props>> {\n  button: { type: 'button'; value?: undefined }\n  checkbox: {\n    type: 'checkbox'\n    options?: FormKitOptionsProp\n    onValue?: any\n    offValue?: any\n    value?: Props['options'] extends Record<infer T, string>\n      ? T[]\n      : Props['options'] extends FormKitOptionsItem[]\n      ? Array<Props['options'][number]['value']>\n      : Props['options'] extends Array<infer T>\n      ? T[]\n      :\n          | (Props['onValue'] extends AllReals ? Props['onValue'] : true)\n          | (Props['offValue'] extends AllReals ? Props['offValue'] : false)\n  }\n  color: { type: 'color'; value?: string }\n  date: { type: 'date'; value?: string }\n  'datetime-local': { type: 'datetime-local'; value?: string }\n  email: {\n    type: 'email'\n    value?: string\n  }\n  file: { type: 'file'; value?: FormKitFile[] }\n  form: {\n    type: 'form'\n    value?: FormKitGroupValue\n    actions?: boolean | string\n    submitAttrs?: Record<string, any>\n    submitBehavior?: 'disabled' | 'live'\n    incompleteMessage?: false | string\n  }\n  group: { type: 'group'; value?: FormKitGroupValue }\n  hidden: {\n    type: 'hidden'\n    value?: Props['number'] extends AllReals ? number : string\n    number?: 'integer' | 'float' | 'true' | true\n  }\n  list: {\n    type: 'list'\n    value?: unknown[]\n    dynamic?: boolean | 'true' | 'false'\n    sync?: boolean | 'true' | 'false'\n  }\n  meta: { type: 'meta'; value?: any }\n  month: { type: 'month'; value?: string }\n  number: {\n    type: 'number'\n    value?: Props['number'] extends AllReals ? number : string\n    number?: 'integer' | 'float' | 'true' | true\n  }\n  password: { type: 'password'; value?: string }\n  radio: {\n    type: 'radio'\n    options: FormKitOptionsProp\n    value?: FormKitOptionsValue<Props['options']>\n  }\n  range: {\n    type: 'range'\n    value?: Props['number'] extends AllReals ? number : string\n    number?: 'integer' | 'float' | 'true' | true\n  }\n  search: {\n    type: 'search'\n    value?: Props['number'] extends AllReals ? number | string : string\n    number?: 'integer' | 'float' | 'true' | true\n  }\n  select: {\n    type: 'select'\n    options?: FormKitOptionsPropWithGroups\n    value?: FormKitOptionsValue<Props['options']>\n  }\n  submit: { type: 'submit'; value?: string }\n  tel: {\n    type: 'tel'\n    value?: Props['number'] extends AllReals ? number | string : string\n    number?: 'integer' | 'float' | 'true' | true\n  }\n  text: {\n    type: 'text'\n    value?: Props['number'] extends AllReals ? number | string : string\n    number?: 'integer' | 'float' | 'true' | true\n  }\n  textarea: { type: 'textarea'; value?: string }\n  time: { type: 'time'; value?: string }\n  url: { type: 'url'; value?: string }\n  week: { type: 'week'; value?: string }\n  // This fallthrough is for inputs that do not have their type set. These\n  // are effectively \"text\" inputs.\n  _: {\n    type?:\n      | (Props['type'] extends FormKitTypeDefinition<any>\n          ? Props['type']\n          : never & {})\n      | (Props['type'] extends keyof FormKitInputProps<Props>\n          ? Props['type']\n          : never)\n    value?: Props['type'] extends FormKitTypeDefinition<infer T>\n      ? T\n      : Props['type'] extends AllReals\n      ? never\n      : string\n  }\n}\n\n/**\n * A merger of input props, base props, and conditional props. This is then\n * used as the structure for the FormKitInputs type.\n * @public\n */\nexport type MergedProps<Props extends FormKitInputs<Props>> = {\n  [K in keyof FormKitInputProps<Props>]: Omit<\n    Partial<FormKitBaseProps>,\n    keyof FormKitInputProps<Props>[K]\n  > &\n    Omit<\n      Partial<FormKitRuntimeProps<Props>>,\n      keyof FormKitInputProps<Props>[K]\n    > &\n    Omit<Partial<FormKitConditionalProps>, keyof FormKitInputProps<Props>[K]> &\n    Partial<\n      K extends keyof FormKitInputEventsAsProps<Props>\n        ? Omit<\n            FormKitEventsAsProps,\n            keyof FormKitInputEventsAsProps<Props>[K]\n          > &\n            FormKitInputEventsAsProps<Props>[K]\n        : FormKitEventsAsProps\n    > &\n    FormKitInputProps<Props>[K]\n}\n\n/**\n * Merge all events into a single type. This is then used as the structure for\n *\n * @public\n */\nexport type MergedEvents<Props extends FormKitInputs<Props>> =\n  InputType<Props> extends keyof FormKitInputEvents<Props>\n    ? FormKitBaseEvents<Props> & FormKitInputEvents<Props>[InputType<Props>]\n    : FormKitBaseEvents<Props>\n\n/**\n * Selects the \"type\" from the props if it exists, otherwise it defaults to\n * \"text\".\n *\n * @public\n */\nexport type InputType<Props extends FormKitInputs<Props>> =\n  Props['type'] extends FormKitTypeDefinition<any>\n    ? Props['type']\n    : Props['type'] extends string\n    ? Props['type']\n    : 'text'\n\n/**\n * All FormKit events should be included for a given set of props.\n *\n * @public\n */\nexport type FormKitEvents<Props extends FormKitInputs<Props>> =\n  MergedEvents<Props>\n\n/**\n * All FormKit inputs should be included for this type.\n * @public\n */\nexport type FormKitInputs<Props extends FormKitInputs<Props>> =\n  MergedProps<Props>[keyof MergedProps<Props>]\n\n/**\n * Unique events emitted by each FormKit input. The shape of this interface is:\n *\n * ```ts\n * interface FormKitInputEvents<Props extends Inputs> {\n *   typeString: { customEvent: (value: PropType<Props, 'value'>) => any } // <-- All unique events\n * }\n * ```\n *\n * All inputs will also inherit all events from FormKitBaseInputEvents.\n * @public\n */\nexport interface FormKitInputEvents<Props extends FormKitInputs<Props>> {\n  form: {\n    (event: 'submit-raw', e: Event, node: FormKitNode): any\n    (event: 'submit-invalid', node: FormKitNode): any\n    (event: 'submit', data: any, node: FormKitNode): any\n  }\n}\n\n/**\n * Extracts the type from a given prop.\n * @public\n */\nexport type PropType<\n  Props extends FormKitInputs<Props>,\n  T extends keyof FormKitInputs<Props>\n> = Props['type'] extends FormKitTypeDefinition<infer T>\n  ? T extends 'value'\n    ? Props['type']\n    : T\n  : Extract<\n      FormKitInputs<Props>,\n      {\n        type: Props['type'] extends keyof FormKitInputProps<Props>\n          ? Props['type']\n          : 'text'\n      }\n    >[T]\n\n/**\n * The proper shape of data to be passed to options prop.\n * @public\n */\nexport type FormKitOptionsValue<Options> = Options extends FormKitOptionsProp\n  ? Options extends Record<infer T, string>\n    ? T\n    : Options extends FormKitOptionsItem[]\n    ? Options[number]['value']\n    : Options extends Array<infer T>\n    ? T\n    : unknown\n  : unknown\n\n/**\n * General input events available to all FormKit inputs.\n * @public\n */\nexport interface FormKitBaseEvents<Props extends FormKitInputs<Props>> {\n  (event: 'input', value: PropType<Props, 'value'>, node: FormKitNode): any\n  (event: 'inputRaw', value: PropType<Props, 'value'>, node: FormKitNode): any\n  (event: 'input-raw', value: PropType<Props, 'value'>, node: FormKitNode): any\n  (event: 'update:modelValue', value: PropType<Props, 'value'>): any\n  (event: 'update:model-value', value: PropType<Props, 'value'>): any\n  (event: 'node', node: FormKitNode): any\n}\n\n/**\n * In a perfect world this interface would not be required at all. However, Vue\n * expects the interfaces to be defined as method overloads. Unfortunately since\n * our events interface uses generics UnionToIntersection is not able to be used\n * meaning that we lose event data if we store the events as a standard\n * interface with property keys. The only way we have found to reliably get\n * Volar (as of June 2023) to properly recognize all defined events is to use\n * a the \"standard\" method overload approach (see FormKitBaseEvents).\n *\n * (Basically we cannot use the events in this interface to automatically\n * produce the FormKitBaseEvents without Volar loosing event data)\n *\n * This means we have no way to get the event names out of the interface so we\n * cannot properly use them in our props. This matters for things like TSX\n * support where the event names need to be available as `onEventName` props.\n *\n * This interface is used to manually patch that gap in the type system. These\n * types should match up 1-1 with the events defined in FormKitBaseEvents as\n * well as FormKitInputEvents.\n *\n * @public\n */\nexport interface FormKitEventsAsProps {\n  onInput: (value: unknown, node: FormKitNode) => any\n  onInputRaw: (value: unknown, node: FormKitNode) => any\n  'onUpdate:modelValue': (value: unknown, node: FormKitNode) => any\n  onNode: (node: FormKitNode) => any\n}\n\n/**\n * See the comment tome on {@link FormKitEventsAsProps} for why this type is\n * necessary.\n *\n * @public\n */\nexport interface FormKitInputEventsAsProps<Props extends FormKitInputs<Props>> {\n  form: {\n    onSubmitRaw: (e: Event, node: FormKitNode) => any\n    onSubmitInvalid: (node: FormKitNode) => any\n    onSubmit: (data: any, node: FormKitNode) => any\n  }\n}\n\n/**\n * The shape of the context object that is passed to each slot.\n * @public\n */\nexport interface FormKitSlotData<\n  Props extends FormKitInputs<Props>,\n  E extends Record<string, any> = {}\n> {\n  (context: FormKitFrameworkContext<PropType<Props, 'value'>> & E): any\n}\n\n/**\n * Nearly all inputs in FormKit have a \"base\" set of slots. This is the\n * \"sandwich\" around the input itself, like the wrappers, help text, error\n * messages etc. Several other input’s slots extend this base interface.\n * @public\n */\nexport interface FormKitBaseSlots<Props extends FormKitInputs<Props>> {\n  help: FormKitSlotData<Props>\n  inner: FormKitSlotData<Props>\n  input: FormKitSlotData<Props>\n  label: FormKitSlotData<Props>\n  message: FormKitSlotData<Props, { message: FormKitMessage }>\n  messages: FormKitSlotData<Props>\n  outer: FormKitSlotData<Props>\n  prefix: FormKitSlotData<Props>\n  prefixIcon: FormKitSlotData<Props>\n  suffix: FormKitSlotData<Props>\n  suffixIcon: FormKitSlotData<Props>\n  wrapper: FormKitSlotData<Props>\n}\n\n/**\n * The slots available to the FormKitText input, these extend the base slots.\n * @public\n */\nexport interface FormKitTextSlots<Props extends FormKitInputs<Props>>\n  extends FormKitBaseSlots<Props> {}\n\n/**\n * The data available to slots that have an option in scope.\n * @public\n */\nexport interface OptionSlotData<Props extends FormKitInputs<Props>> {\n  option: FormKitOptionsItem<PropType<Props, 'value'>>\n}\n\n/**\n * The slots available to the select input, these extend the base slots.\n * @public\n */\nexport interface FormKitSelectSlots<Props extends FormKitInputs<Props>>\n  extends FormKitBaseSlots<Props> {\n  default: FormKitSlotData<Props>\n  option: FormKitSlotData<Props, OptionSlotData<Props>>\n  selectIcon: FormKitSlotData<Props>\n}\n\n/**\n * The slots available to the checkbox inputs even when options are not provided, these extend the base slots.\n * @public\n */\nexport interface FormKitCheckboxSlots<Props extends FormKitInputs<Props>>\n  extends FormKitBaseSlots<Props> {\n  decorator: FormKitSlotData<Props, OptionSlotData<Props>>\n  decoratorIcon: FormKitSlotData<Props, OptionSlotData<Props>>\n}\n\n/**\n * The slots available to the radio and checkbox inputs when options are\n * provided.\n * @public\n */\nexport interface FormKitBoxSlots<Props extends FormKitInputs<Props>> {\n  fieldset: FormKitSlotData<Props>\n  legend: FormKitSlotData<Props>\n  help: FormKitSlotData<Props>\n  options: FormKitSlotData<Props>\n  option: FormKitSlotData<Props, OptionSlotData<Props>>\n  wrapper: FormKitSlotData<Props, OptionSlotData<Props>>\n  inner: FormKitSlotData<Props, OptionSlotData<Props>>\n  input: FormKitSlotData<Props, OptionSlotData<Props>>\n  label: FormKitSlotData<Props, OptionSlotData<Props>>\n  prefix: FormKitSlotData<Props, OptionSlotData<Props>>\n  suffix: FormKitSlotData<Props, OptionSlotData<Props>>\n  decorator: FormKitSlotData<Props, OptionSlotData<Props>>\n  decoratorIcon: FormKitSlotData<Props, OptionSlotData<Props>>\n  optionHelp: FormKitSlotData<Props, OptionSlotData<Props>>\n  box: FormKitSlotData<Props, OptionSlotData<Props>>\n  icon: FormKitSlotData<Props, OptionSlotData<Props>>\n  message: FormKitSlotData<Props, { message: FormKitMessage }>\n  messages: FormKitSlotData<Props>\n}\n\n/**\n * The slots available to the file input, these extend the base slots.\n * @public\n */\nexport interface FormKitFileSlots<Props extends FormKitInputs<Props>>\n  extends FormKitBaseSlots<Props> {\n  fileList: FormKitSlotData<Props>\n  fileItem: FormKitSlotData<Props>\n  fileItemIcon: FormKitSlotData<Props, { file: FormKitFile }>\n  fileName: FormKitSlotData<Props, { file: FormKitFile }>\n  fileRemove: FormKitSlotData<Props, { file: FormKitFile }>\n  fileRemoveIcon: FormKitSlotData<Props, { file: FormKitFile }>\n  noFiles: FormKitSlotData<Props>\n}\n\n/**\n * The slots available to the button input, these extend the base slots.\n *\n * @public\n */\nexport type FormKitButtonSlots<Props extends FormKitInputs<Props>> = Omit<\n  FormKitBaseSlots<Props>,\n  'inner'\n> & {\n  default: FormKitSlotData<Props>\n}\n\n/**\n * Slots provided by each FormKit input. The shape of this interface is:\n *\n * ```ts\n * interface FormKitInputSlots<Props extends Inputs> {\n *   typeString: { default: (value: PropType<Props, 'value'>) => any } // <-- All unique slots\n * }\n * ```\n *\n * There is no automatic inheritance of slots — each slot must be explicitly\n * defined for each input.\n * @public\n */\nexport interface FormKitInputSlots<Props extends FormKitInputs<Props>> {\n  text: FormKitTextSlots<Props>\n  color: FormKitTextSlots<Props>\n  date: FormKitTextSlots<Props>\n  'datetime-local': FormKitTextSlots<Props>\n  email: FormKitTextSlots<Props>\n  month: FormKitTextSlots<Props>\n  number: FormKitTextSlots<Props>\n  password: FormKitTextSlots<Props>\n  search: FormKitTextSlots<Props>\n  tel: FormKitTextSlots<Props>\n  time: FormKitTextSlots<Props>\n  url: FormKitTextSlots<Props>\n  week: FormKitTextSlots<Props>\n  range: FormKitTextSlots<Props>\n  // Technically textarea has a unique schema, but the slots are the same:\n  textarea: FormKitTextSlots<Props>\n  select: FormKitSelectSlots<Props>\n  radio: Props['options'] extends AllReals\n    ? FormKitBoxSlots<Props>\n    : FormKitBaseSlots<Props>\n  list: { default: FormKitSlotData<Props> }\n  hidden: { input: FormKitSlotData<Props> }\n  meta: { wrapper: FormKitSlotData<Props> }\n  group: { default: FormKitSlotData<Props> }\n  form: {\n    form: FormKitSlotData<Props>\n    default: FormKitSlotData<Props>\n    message: FormKitSlotData<Props, { message: FormKitMessage }>\n    messages: FormKitSlotData<Props>\n    actions: FormKitSlotData<Props>\n    submit: FormKitSlotData<Props>\n  }\n  file: FormKitFileSlots<Props>\n  checkbox: Props['options'] extends AllReals\n    ? FormKitBoxSlots<Props>\n    : FormKitCheckboxSlots<Props>\n  submit: FormKitButtonSlots<Props>\n  button: FormKitButtonSlots<Props>\n}\n\n/**\n * Options should always be formatted as an array of objects with label and value\n * properties.\n *\n * @public\n */\nexport interface FormKitOptionsItem<V = unknown> {\n  label: string\n  value: V\n  attrs?: {\n    disabled?: boolean\n  } & Record<string, any>\n  __original?: any\n  [index: string]: any\n}\n\n/**\n * Option groups should always be formatted as an array of objects with group and nested options\n *\n * @public\n */\nexport interface FormKitOptionsGroupItemProp {\n  group: string\n  options: FormKitOptionsProp\n  attrs?: Record<string, any>\n}\n\n/**\n * Option groups should always be formatted as an array of objects with group and nested options\n *\n * @public\n */\nexport interface FormKitOptionsGroupItem {\n  group: string\n  options: FormKitOptionsList\n  attrs?: Record<string, any>\n}\n\n/**\n * An array of option items.\n *\n * @public\n */\nexport type FormKitOptionsList = FormKitOptionsItem[]\n\n/**\n * An array of option items with a group.\n *\n * @public\n */\nexport type FormKitOptionsListWithGroups = Array<\n  FormKitOptionsItem | FormKitOptionsGroupItem\n>\n\n/**\n * An array of option items with a group support — where the `option` of the\n * groups can be any valid FormKitOptionsProp type.\n *\n * @public\n */\nexport type FormKitOptionsListWithGroupsProp = Array<\n  FormKitOptionsItem | FormKitOptionsGroupItemProp\n>\n\n/**\n * Allows for prop extensions to be defined by using an interface whose keys\n * are ignored, but values are applied to a union type. This allows for any\n * third party code to extend the options prop by using module augmentation\n * to add new values to the union type.\n *\n * @public\n */\nexport interface FormKitOptionsPropExtensions {\n  arrayOfStrings: string[]\n  arrayOfNumbers: number[]\n  optionsList: FormKitOptionsList\n  valueLabelPojo: Record<string | number, string>\n}\n\n/**\n * The types of options that can be passed to the options prop.\n *\n * @public\n */\nexport type FormKitOptionsProp =\n  FormKitOptionsPropExtensions[keyof FormKitOptionsPropExtensions]\n\n/**\n * The types of options that can be passed to the options prop.\n *\n * @public\n */\nexport type FormKitOptionsPropWithGroups =\n  | FormKitOptionsProp\n  | FormKitOptionsListWithGroupsProp\n\n/**\n * Typings for all the built in runtime props.\n *\n * Warning: As of writing these are only specific to Vue’s runtime prop\n * requirements and should not be used as any kind of external API as they are\n * subject to change.\n *\n * @public\n */\nexport interface FormKitRuntimeProps<\n  Props extends FormKitInputs<Props>,\n  V = unknown\n> {\n  /**\n   * An object of configuration data for the input and its children.\n   */\n  config: Record<string, any>\n  /**\n   * An object of classes to be applied to the input.\n   */\n  classes: Record<string, string | Record<string, boolean> | FormKitClasses>\n  /**\n   * Amount of time to debounce input before committing.\n   */\n  delay: number\n  /**\n   * An array of errors for the input.\n   */\n  errors: string[]\n  /**\n   * A object of values\n   */\n  inputErrors: Record<string, string[]>\n  /**\n   * An explicit index to mount a child of a list at.\n   */\n  index: number\n  /**\n   * A globally unique identifier for the input — this passes through to the\n   * id attribute.\n   */\n  id: string\n  /**\n   * The dynamic value of the input.\n   */\n  modelValue: PropType<Props, 'value'>\n  /**\n   * The name of the input.\n   */\n  name: string\n  /**\n   * An explicit parent node for the input.\n   */\n  parent: FormKitNode\n  /**\n   * An array of plugins to apply to the input.\n   */\n  plugins: FormKitPlugin[]\n  /**\n   * An object of sections to merge with the input’s internal schema.\n   */\n  sectionsSchema: FormKitSectionsSchema\n  /**\n   * A boolean indicating whether the input should be synced with the model.\n   */\n  sync: boolean | undefined\n  /**\n   * The type of the input.\n   */\n  type: string | FormKitTypeDefinition<V>\n  /**\n   * A validation string or array of validation rules.\n   */\n  validation: string | Array<[rule: string, ...args: any]>\n  /**\n   * An object of validation messages to use for the input.\n   */\n  validationMessages: Record<\n    string,\n    string | ((ctx: { node: FormKitNode; name: string; args: any[] }) => string)\n  >\n  /**\n   * An object of additional validation rules to use for the input.\n   */\n  validationRules: Record<\n    string,\n    (node: FormKitNode, ...args: any[]) => boolean | Promise<boolean>\n  >\n  /**\n   * Use this to override the default validation label in validation messages.\n   */\n  validationLabel: string | ((node: FormKitNode) => string)\n}\n\n/**\n * Base props that should be applied to all FormKit inputs. These are not actual\n * runtime props and are pulled from the context.attrs object. Many of these are\n * just html attributes that are passed through to the input element.\n *\n * @public\n */\nexport interface FormKitBaseProps {\n  /**\n   * HTML Attribute, read more here: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#accept\n   */\n  accept: string\n  action: string\n  actions: 'true' | 'false' | boolean\n  dirtyBehavior: 'touched' | 'compare'\n  disabled: 'true' | 'false' | boolean\n  enctype: string\n  help: string\n  ignore: 'true' | 'false' | boolean\n  label: string\n  library: Record<string, any>\n  max: string | number\n  method: string\n  min: string | number\n  multiple: 'true' | 'false' | boolean\n  preserve: 'true' | 'false' | boolean\n  preserveErrors: 'true' | 'false' | boolean\n  placeholder: string\n  step: string | number\n  validationVisibility: 'live' | 'blur' | 'dirty' | 'submit'\n}\n\n/**\n * All the explicit FormKit props that need to be passed to FormKit’s Vue\n * component instance.\n * @public\n */\nexport const runtimeProps = [\n  'classes',\n  'config',\n  'delay',\n  'errors',\n  'id',\n  'index',\n  'inputErrors',\n  'library',\n  'modelValue',\n  'onUpdate:modelValue',\n  'name',\n  'number',\n  'parent',\n  'plugins',\n  'sectionsSchema',\n  'type',\n  'validation',\n  'validationLabel',\n  'validationMessages',\n  'validationRules',\n  // Runtime event props:\n  'onInput',\n  'onInputRaw',\n  'onUpdate:modelValue',\n  'onNode',\n  'onSubmit',\n  'onSubmitInvalid',\n  'onSubmitRaw',\n]\n\n/**\n * A helper to determine if an option is a group or an option.\n * @param option - An option\n *\n * @public\n */\nexport function isGroupOption(\n  option:\n    | FormKitOptionsItem\n    | FormKitOptionsGroupItem\n    | FormKitOptionsGroupItemProp\n): option is FormKitOptionsGroupItem {\n  return (\n    option &&\n    typeof option === 'object' &&\n    'group' in option &&\n    Array.isArray(option.options)\n  )\n}\n", "import { FormKitNode } from '@formkit/core'\nimport {\n  FormKitOptionsPropWithGroups,\n  FormKitOptionsListWithGroups,\n  FormKitOptionsItem,\n  FormKitOptionsGroupItem,\n  FormKitOptionsList,\n  FormKitOptionsProp,\n  isGroupOption,\n} from '../props'\nimport { eq, isPojo } from '@formkit/utils'\n\n/**\n * A function to normalize an array of objects, array of strings, or object of\n * key-values to use an array of objects with value and label properties.\n *\n * @param options - An un-normalized {@link FormKitOptionsProp | FormKitOptionsProp}.\n *\n * @returns A list of {@link FormKitOptionsList | FormKitOptionsList}.\n *\n * @public\n */\nexport function normalizeOptions<T extends FormKitOptionsPropWithGroups>(\n  options: T,\n  i = { count: 1 }\n): T extends FormKitOptionsProp\n  ? FormKitOptionsList\n  : FormKitOptionsListWithGroups {\n  if (Array.isArray(options)) {\n    return options.map(\n      (option): FormKitOptionsItem | FormKitOptionsGroupItem => {\n        if (typeof option === 'string' || typeof option === 'number') {\n          return {\n            label: String(option),\n            value: String(option),\n          }\n        }\n        if (typeof option == 'object') {\n          if ('group' in option) {\n            option.options = normalizeOptions(option.options || [], i)\n            return option as FormKitOptionsGroupItem\n          } else if ('value' in option && typeof option.value !== 'string') {\n            Object.assign(option, {\n              value: `__mask_${i.count++}`,\n              __original: option.value,\n            })\n          }\n        }\n        return option as FormKitOptionsItem\n      }\n    ) as any\n  }\n  return Object.keys(options).map((value: string) => {\n    return {\n      label: options[value],\n      value,\n    }\n  })\n}\n\n/**\n * Given an {@link FormKitOptionsList | FormKitOptionsListWithGroups}, find the real value in the options.\n *\n * @param options - The {@link FormKitOptionsList | FormKitOptionsListWithGroups} to check for a given value\n * @param value - The value to return\n *\n * @returns `unknown`\n *\n * @public\n */\nexport function optionValue(\n  options: FormKitOptionsListWithGroups,\n  value: string,\n  undefinedIfNotFound = false\n): unknown {\n  if (Array.isArray(options)) {\n    for (const option of options) {\n      if (typeof option !== 'object' && option) continue\n      if (isGroupOption(option)) {\n        const found = optionValue(option.options, value, true)\n        if (found !== undefined) {\n          return found\n        }\n      } else if (value == option.value) {\n        return '__original' in option ? option.__original : option.value\n      }\n    }\n  }\n  return undefinedIfNotFound ? undefined : value\n}\n\n/**\n * Determines if the value should be selected.\n *\n * @param valueA - Any type of value\n * @param valueB - Any type of value\n *\n * @returns `boolean`\n *\n * @public\n */\nexport function shouldSelect(valueA: unknown, valueB: unknown): boolean {\n  if (\n    (valueA === null && valueB === undefined) ||\n    (valueA === undefined && valueB === null)\n  )\n    return false\n  if (valueA == valueB) return true\n  if (isPojo(valueA) && isPojo(valueB)) return eq(valueA, valueB)\n  return false\n}\n\n/**\n * A feature that converts the options prop to usable values, to be used by a\n * feature or a plugin.\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport default function options(node: FormKitNode): void {\n  node.hook.prop((prop: any, next: any) => {\n    if (prop.prop === 'options') {\n      if (typeof prop.value === 'function') {\n        node.props.optionsLoader = prop.value\n        prop.value = []\n      } else {\n        node.props._normalizeCounter ??= { count: 1 }\n        prop.value = normalizeOptions(prop.value, node.props._normalizeCounter)\n      }\n    }\n    return next(prop)\n  })\n}\n", "import { extend } from '@formkit/utils'\nimport {\n  FormKitSchemaNode,\n  FormKitExtendableSchemaRoot,\n  isDOM,\n  isComponent,\n  FormKitSchemaDOMNode,\n  FormKitSchemaComponent,\n  FormKitSchemaFormKit,\n  FormKitSectionsSchema,\n  FormKitSchemaCondition,\n} from '@formkit/core'\n\n/**\n * A function that is called with an extensions argument and returns a valid\n * schema node.\n *\n * @public\n */\nexport interface FormKitSchemaExtendableSection {\n  (extensions: FormKitSectionsSchema): FormKitSchemaNode\n  _s?: string\n}\n\n/**\n * A function that when called, returns a function that can in turn be called\n * with an extension parameter.\n *\n * @public\n */\nexport interface FormKitSection<T = FormKitSchemaExtendableSection> {\n  (\n    ...children: Array<\n      FormKitSchemaExtendableSection | string | FormKitSchemaCondition\n    >\n  ): T\n}\n\n/**\n * Creates a new reusable section.\n *\n * @param section - A single section of schema\n * @param el - The element or a function that returns a schema node.\n * @param root - When true, returns a FormKitExtendableSchemaRoot. When false,\n * returns a FormKitSchemaExtendableSection.\n *\n * @returns Returns a {@link @formkit/core#FormKitExtendableSchemaRoot\n * | FormKitExtendableSchemaRoot} or a {@link\n * @formkit/core#FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}.\n *\n * @public\n */\nexport function createSection(\n  section: string,\n  el: string | null | (() => FormKitSchemaNode),\n  fragment: true\n): FormKitSection<FormKitExtendableSchemaRoot>\n\n/**\n * @param section - A single section of schema\n * @param el - The element or a function that returns a schema node.\n *\n * @public\n */\nexport function createSection(\n  section: string,\n  el: string | null | (() => FormKitSchemaNode)\n): FormKitSection<FormKitSchemaExtendableSection>\n\n/**\n * @param section - A single section of schema\n * @param el - The element or a function that returns a schema node.\n * @param root - When false, returns a FormKitSchemaExtendableSection.\n *\n * @public\n */\nexport function createSection(\n  section: string,\n  el: string | (() => FormKitSchemaNode),\n  fragment: false\n): FormKitSection<FormKitSchemaExtendableSection>\n\n/*@__NO_SIDE_EFFECTS__*/\nexport function createSection(\n  section: string,\n  el: string | null | (() => FormKitSchemaNode),\n  fragment = false\n): FormKitSection<\n  FormKitExtendableSchemaRoot | FormKitSchemaExtendableSection\n> {\n  return (\n    ...children: Array<\n      FormKitSchemaExtendableSection | string | FormKitSchemaCondition\n    >\n  ) => {\n    const extendable = (extensions: FormKitSectionsSchema) => {\n      const node = !el || typeof el === 'string' ? { $el: el } : el()\n      if (isDOM(node) || isComponent(node)) {\n        if (!node.meta) {\n          node.meta = { section }\n        } else {\n          node.meta.section = section\n        }\n        if (children.length && !node.children) {\n          node.children = [\n            ...children.map((child) =>\n              typeof child === 'function' ? child(extensions) : child\n            ),\n          ]\n        }\n        if (isDOM(node)) {\n          node.attrs = {\n            class: `$classes.${section}`,\n            ...(node.attrs || {}),\n          }\n        }\n      }\n      return {\n        if: `$slots.${section}`,\n        then: `$slots.${section}`,\n        else:\n          section in extensions\n            ? extendSchema(node, extensions[section])\n            : node,\n      }\n    }\n    extendable._s = section\n    return fragment ? createRoot(extendable) : extendable\n  }\n}\n\n/**\n * Returns an extendable schema root node.\n *\n * @param rootSection - Creates the root node.\n *\n * @returns {@link @formkit/core#FormKitExtendableSchemaRoot | FormKitExtendableSchemaRoot}\n *\n * @internal\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function createRoot(\n  rootSection: FormKitSchemaExtendableSection\n): FormKitExtendableSchemaRoot {\n  return (extensions: FormKitSectionsSchema) => {\n    return [rootSection(extensions)]\n  }\n}\n\n/**\n * Type guard for schema objects.\n *\n * @param schema - returns `true` if the node is a schema node but not a string\n * or conditional.\n *\n * @returns `boolean`\n *\n * @public\n */\nexport function isSchemaObject(\n  schema: Partial<FormKitSchemaNode> | null\n): schema is\n  | FormKitSchemaDOMNode\n  | FormKitSchemaComponent\n  | FormKitSchemaFormKit {\n  return !!(\n    schema &&\n    typeof schema === 'object' &&\n    ('$el' in schema || '$cmp' in schema || '$formkit' in schema)\n  )\n}\n\n/**\n * Extends a single schema node with an extension. The extension can be any\n * partial node including strings.\n *\n * @param schema - The base schema node.\n * @param extension - The values to extend on the base schema node.\n *\n * @returns {@link @formkit/core#FormKitSchemaNode | FormKitSchemaNode}\n *\n * @public\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function extendSchema(\n  schema: FormKitSchemaNode,\n  extension: Partial<FormKitSchemaNode> | null = {}\n): FormKitSchemaNode {\n  if (typeof schema === 'string') {\n    return isSchemaObject(extension) || typeof extension === 'string'\n      ? extension\n      : schema\n  } else if (Array.isArray(schema)) {\n    return isSchemaObject(extension) ? extension : schema\n  }\n  return extend(schema, extension) as FormKitSchemaNode\n}\n", "import { extend, isObject, token } from '@formkit/utils'\nimport {\n  FormKitExtendableSchemaRoot,\n  FormKitSchemaAttributes,\n  FormKitSchemaNode,\n  FormKitSchemaCondition,\n  FormKitSchemaDefinition,\n  FormKitSchemaComponent,\n  isComponent,\n  isDOM,\n  isConditional,\n  warn,\n  FormKitSchemaDOMNode,\n  FormKitSectionsSchema,\n} from '@formkit/core'\nimport {\n  isSchemaObject,\n  extendSchema,\n  FormKitSection,\n  FormKitSchemaExtendableSection,\n  createRoot,\n} from './createSection'\nimport {\n  outer,\n  wrapper,\n  prefix,\n  suffix,\n  label,\n  inner,\n  messages,\n  message,\n  help,\n  icon,\n} from './sections'\nimport { resetRadio } from './features/renamesRadios'\n\n/**\n * Either a schema node, or a function that returns a schema node.\n *\n * @public\n */\nexport type FormKitInputSchema =\n  | ((children?: FormKitSchemaDefinition) => FormKitSchemaNode)\n  | FormKitSchemaNode\n\n/**\n * A type narrowed type that represents a formkit schema \"section\". These are\n * always in the shape:\n * ```js\n * {\n *   if: string,\n *   then: '$slots.sectionName',\n *   else: {\n *    meta: {\n *      section: 'sectionName'\n *    },\n *    $el: 'div' // or $cmp...\n *   }\n * }\n * ```\n *\n * @public\n */\nexport type FormKitSchemaSection = FormKitSchemaCondition & {\n  else:\n    | FormKitSchemaDOMNode\n    | (FormKitSchemaComponent & { meta: { section: string } })\n}\n\n/**\n * Checks if the current schema node is a slot condition.\n *\n * @example\n *\n * ```js\n * {\n *  if: '$slot.name',\n *  then: '$slot.name',\n *  else: []\n * } // this schema node would return true.\n * ```\n *\n * @param node - A {@link @formkit/core#FormKitSchemaNode | FormKitSchemaNode}.\n *\n * @returns `boolean`\n *\n * @public\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function isSlotCondition(node: FormKitSchemaNode): node is {\n  if: string\n  then: string\n  else: FormKitSchemaNode | FormKitSchemaNode[]\n} {\n  if (\n    isConditional(node) &&\n    node.if &&\n    node.if.startsWith('$slots.') &&\n    typeof node.then === 'string' &&\n    node.then.startsWith('$slots.') &&\n    'else' in node\n  ) {\n    return true\n  }\n  return false\n}\n\n/**\n * Finds a section by name in a schema.\n *\n * @param schema - A {@link @formkit/core#FormKitSchemaDefinition | FormKitSchemaDefinition} array.\n * @param target - The name of the section to find.\n *\n * @returns a tuple of the schema and the section or a tuple of `false` and `false` if not found.\n *\n * @public\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function findSection(\n  schema: FormKitSchemaDefinition,\n  target: string\n):\n  | [false, false]\n  | [\n      FormKitSchemaNode[] | FormKitSchemaCondition | false | undefined,\n      FormKitSchemaCondition\n    ] {\n  return (\n    eachSection(\n      schema,\n      (section, sectionCondition, parent) => {\n        if (section.meta?.section === target) {\n          return [parent, sectionCondition]\n        }\n        return\n      },\n      true\n    ) ?? [false, false]\n  )\n}\n\n/**\n * Runs a callback over every section in a schema. if stopOnCallbackReturn is true\n * and the callback returns a value, the iteration will stop and return that value.\n *\n * @param schema - A {@link @formkit/core#FormKitSchemaNode | FormKitSchemaNode} array.\n * @param callback - A callback to run on every section.\n * @param stopOnCallbackReturn - If true, the loop will stop if the callback returns a value.\n * @param schemaParent - The parent of the current schema node.\n *\n * @returns\n *\n * @public\n */\nexport function eachSection<T>(\n  schema: FormKitSchemaDefinition,\n  callback: (\n    section: FormKitSchemaComponent | FormKitSchemaDOMNode,\n    sectionConditional: FormKitSchemaCondition,\n    sectionParent: FormKitSchemaNode[] | FormKitSchemaCondition | undefined\n  ) => T,\n  stopOnCallbackReturn = false,\n  schemaParent?: FormKitSchemaNode[] | FormKitSchemaCondition\n): T | void {\n  if (Array.isArray(schema)) {\n    for (const node of schema) {\n      const callbackReturn = eachSection(\n        node,\n        callback,\n        stopOnCallbackReturn,\n        schema\n      )\n      if (callbackReturn && stopOnCallbackReturn) {\n        return callbackReturn\n      }\n    }\n    return\n  }\n  if (isSection(schema)) {\n    const callbackReturn = callback(schema.else, schema, schemaParent)\n    if (callbackReturn && stopOnCallbackReturn) {\n      return callbackReturn\n    }\n    return eachSection(schema.else, callback, stopOnCallbackReturn, schema)\n  } else if ((isComponent(schema) || isDOM(schema)) && schema.children) {\n    return eachSection(\n      schema.children as FormKitSchemaNode,\n      callback,\n      stopOnCallbackReturn\n    )\n  } else if (isConditional(schema)) {\n    let callbackReturn: T | void = undefined\n\n    if (schema.then && typeof schema.then !== 'string') {\n      callbackReturn = eachSection(\n        schema.then,\n        callback,\n        stopOnCallbackReturn,\n        schema\n      )\n    }\n\n    if (!callbackReturn && schema.else && typeof schema.else !== 'string') {\n      callbackReturn = eachSection(\n        schema.else,\n        callback,\n        stopOnCallbackReturn,\n        schema\n      )\n    }\n\n    if (callbackReturn && stopOnCallbackReturn) {\n      return callbackReturn\n    }\n  }\n}\n\n/**\n * Check if a schema node is conditional, has an else clause, and that else\n * clause contains a section in the meta.\n * @param section - A schema node to check.\n * @public\n */\nfunction isSection(\n  section: FormKitSchemaNode\n): section is FormKitSchemaSection {\n  if (\n    isConditional(section) &&\n    typeof section.then === 'string' &&\n    section.else &&\n    typeof section.else !== 'string' &&\n    !Array.isArray(section.else) &&\n    !isConditional(section.else) &&\n    section.else.meta?.section\n  ) {\n    return true\n  }\n  return false\n}\n/**\n * Creates an input schema with all of the wrapping base schema.\n *\n * @param inputSection - Content to store in the input section key location.\n *\n * @returns {@link @formkit/core#FormKitExtendableSchemaRoot | FormKitExtendableSchemaRoot}\n *\n * @public\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function useSchema(\n  inputSection: FormKitSection,\n  sectionsSchema: FormKitSectionsSchema = {}\n): FormKitSchemaExtendableSection {\n  const schema = /* #__PURE__ */ outer(\n    /* #__PURE__ */ wrapper(\n      /* #__PURE__ */ label('$label'),\n      /* #__PURE__ */ inner(/* #__PURE__ */ icon('prefix'), /* #__PURE__ */ prefix(), inputSection(), /* #__PURE__ */ suffix(), /* #__PURE__ */ icon('suffix'))\n    ),\n    /* #__PURE__ */ help('$help'),\n    /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value'))\n  )\n  return (propSectionsSchema: FormKitSectionsSchema = {}) =>\n    schema(extend(sectionsSchema, propSectionsSchema) as FormKitSectionsSchema)\n}\n\n// ========================================================\n\n/**\n * Applies attributes to a given schema section by applying a higher order\n * function that merges a given set of attributes into the node.\n *\n * @param attrs - Attributes to apply to a {@link FormKitSchemaExtendableSection\n * | FormKitSchemaExtendableSection}.\n * @param section - A section to apply attributes to.\n *\n * @returns {@link FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}\n *\n * @public\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function $attrs(\n  attrs: FormKitSchemaAttributes | (() => FormKitSchemaAttributes),\n  section: FormKitSchemaExtendableSection\n): FormKitSchemaExtendableSection {\n  const extendable = (extensions: FormKitSectionsSchema) => {\n    const node = section(extensions)\n    const attributes = typeof attrs === 'function' ? attrs() : attrs\n    if (!isObject(attributes)) return node\n    if (isSlotCondition(node) && isDOM(node.else)) {\n      node.else.attrs = { ...node.else.attrs, ...attributes }\n    } else if (isDOM(node)) {\n      node.attrs = { ...node.attrs, ...attributes }\n    }\n    return node\n  }\n  extendable._s = section._s\n  return extendable\n}\n\n/**\n * Applies a condition to a given schema section.\n *\n * @param condition - A schema condition to apply to a section.\n * @param then - The section that applies if the condition is true.\n * @param otherwise - (else) The section that applies if the condition is false.\n *\n * @returns {@link FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}\n *\n * @public\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function $if(\n  condition: string,\n  then: FormKitSchemaExtendableSection,\n  otherwise?: FormKitSchemaExtendableSection\n): FormKitSchemaExtendableSection {\n  const extendable = (extensions: FormKitSectionsSchema) => {\n    const node = then(extensions)\n    if (\n      otherwise ||\n      (isSchemaObject(node) && 'if' in node) ||\n      isSlotCondition(node)\n    ) {\n      const conditionalNode: FormKitSchemaCondition = {\n        if: condition,\n        then: node,\n      }\n      if (otherwise) {\n        conditionalNode.else = otherwise(extensions)\n      }\n      return conditionalNode\n    } else if (isSlotCondition(node)) {\n      Object.assign(node.else, { if: condition })\n    } else if (isSchemaObject(node)) {\n      Object.assign(node, { if: condition })\n    }\n    return node\n  }\n  extendable._s = token()\n  return extendable\n}\n\n/**\n * Applies a condition to a given schema section.\n *\n * @param varName - The name of the variable that holds the current instance.\n * @param inName - The variable we are iterating over.\n * @param section - A section to repeat.\n *\n * @returns {@link FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}\n *\n * @public\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function $for(\n  varName: string,\n  inName: string,\n  section: FormKitSchemaExtendableSection\n) {\n  return (extensions: FormKitSectionsSchema): FormKitSchemaNode => {\n    const node = section(extensions)\n    if (isSlotCondition(node)) {\n      Object.assign(node.else, { for: [varName, inName] })\n    } else if (isSchemaObject(node)) {\n      Object.assign(node, { for: [varName, inName] })\n    }\n    return node\n  }\n}\n\n/**\n * Extends a schema node with a given set of extensions.\n *\n * @param section - A section to apply an extension to.\n * @param extendWith - A partial schema snippet to apply to the section.\n *\n * @returns {@link FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}\n *\n * @public\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function $extend(\n  section: FormKitSchemaExtendableSection,\n  extendWith: Partial<FormKitSchemaNode>\n): FormKitSchemaExtendableSection {\n  const extendable = (extensions: FormKitSectionsSchema) => {\n    const node = section({})\n    if (isSlotCondition(node)) {\n      if (Array.isArray(node.else)) return node\n      node.else = extendSchema(\n        extendSchema(node.else, extendWith),\n        section._s ? extensions[section._s] : {}\n      )\n      return node\n    }\n    return extendSchema(\n      extendSchema(node, extendWith),\n      section._s ? extensions[section._s] : {}\n    )\n  }\n  extendable._s = section._s\n  return extendable\n}\n\n/**\n * Creates a root schema section.\n *\n * @param section - A section to make a root from.\n *\n * @returns {@link FormKitSchemaExtendableSection | FormKitSchemaExtendableSection}\n *\n * @public\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function $root(\n  section: FormKitSchemaExtendableSection\n): FormKitExtendableSchemaRoot {\n  warn(800, '$root')\n  return createRoot(section)\n}\n\nexport function resetCounts() {\n  resetRadio()\n}\n\nexport * from './features'\nexport * from './sections'\n", "import { createSection } from '../createSection'\n\n/**\n * Actions section that shows the action buttons\n *\n * @public\n */\nexport const actions = createSection('actions', () => ({\n  $el: 'div',\n  if: '$actions',\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Box section used for grouping options\n *\n * @public\n */\nexport const box = createSection('input', () => ({\n  $el: 'input',\n  bind: '$attrs',\n  attrs: {\n    type: '$type',\n    name: '$node.props.altName || $node.name',\n    disabled: '$option.attrs.disabled || $disabled',\n    onInput: '$handlers.toggleChecked',\n    checked: '$fns.eq($_value, $onValue)',\n    onBlur: '$handlers.blur',\n    value: '$: true',\n    id: '$id',\n    'aria-describedby': {\n      if: '$options.length',\n      then: {\n        if: '$option.help',\n        then: '$: \"help-\" + $option.attrs.id',\n        else: undefined,\n      },\n      else: {\n        if: '$help',\n        then: '$: \"help-\" + $id',\n        else: undefined,\n      },\n    },\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Option help section\n *\n * @public\n */\nexport const boxHelp = createSection('optionHelp', () => ({\n  $el: 'div',\n  if: '$option.help',\n  attrs: {\n    id: '$: \"help-\" + $option.attrs.id',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Box Inner section\n *\n * @public\n */\nexport const boxInner = createSection('inner', 'span')\n", "import { createSection } from '../createSection'\n\n/**\n * Label section for options\n *\n * @public\n */\nexport const boxLabel = createSection('label', 'span')\n", "import { createSection } from '../createSection'\n\n/**\n * Option section used to show an option\n *\n * @public\n */\nexport const boxOption = createSection('option', () => ({\n  $el: 'li',\n  for: ['option', '$options'],\n  attrs: {\n    'data-disabled': '$option.attrs.disabled || $disabled || undefined',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Options section used to wrap all option sections in a list\n *\n * @public\n */\nexport const boxOptions = createSection('options', 'ul')\n", "import { createSection } from '../createSection'\n\n/**\n * Wrapper section for options\n *\n * @public\n */\nexport const boxWrapper = createSection('wrapper', () => ({\n  $el: 'label',\n  attrs: {\n    'data-disabled': {\n      if: '$options.length',\n      then: undefined,\n      else: '$disabled || undefined',\n    },\n    'data-checked': {\n      if: '$options == undefined',\n      then: '$fns.eq($_value, $onValue) || undefined',\n      else: '$fns.isChecked($option.value) || undefined',\n    },\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Input section for a button\n *\n * @public\n */\nexport const buttonInput = createSection('input', () => ({\n  $el: 'button',\n  bind: '$attrs',\n  attrs: {\n    type: '$type',\n    disabled: '$disabled',\n    name: '$node.name',\n    id: '$id',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Default section for a button\n *\n * @public\n */\nexport const buttonLabel = createSection('default', null)\n", "import { createSection } from '../createSection'\n\n/**\n * Decorator section\n *\n * @public\n */\nexport const decorator = createSection('decorator', () => ({\n  $el: 'span',\n  attrs: {\n    'aria-hidden': 'true',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Fieldset section, used to describe help\n *\n * @public\n */\nexport const fieldset = createSection('fieldset', () => ({\n  $el: 'fieldset',\n  attrs: {\n    id: '$id',\n    'aria-describedby': {\n      if: '$help',\n      then: '$: \"help-\" + $id',\n      else: undefined,\n    },\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Input section for a file input\n *\n * @public\n */\nexport const fileInput = createSection('input', () => ({\n  $el: 'input',\n  bind: '$attrs',\n  attrs: {\n    type: 'file',\n    disabled: '$disabled',\n    name: '$node.name',\n    onChange: '$handlers.files',\n    onBlur: '$handlers.blur',\n    id: '$id',\n    'aria-describedby': '$describedBy',\n    'aria-required': '$state.required || undefined',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * File item section for showing a file name\n *\n * @public\n */\nexport const fileItem = createSection('fileItem', () => ({\n  $el: 'li',\n  for: ['file', '$value'],\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * File list section to show all file names\n *\n * @public\n */\nexport const fileList = createSection('fileList', () => ({\n  $el: 'ul',\n  if: '$value.length',\n  attrs: {\n    'data-has-multiple': '$_hasMultipleFiles',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * File name section to show the file name\n *\n * @public\n */\nexport const fileName = createSection('fileName', () => ({\n  $el: 'span',\n  attrs: {\n    class: '$classes.fileName',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * File remove section to show a remove button for files\n *\n * @public\n */\nexport const fileRemove = createSection('fileRemove', () => ({\n  $el: 'button',\n  attrs: {\n    type: 'button',\n    onClick: '$handlers.resetFiles',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Form section\n *\n * @public\n */\nexport const formInput = createSection('form', () => ({\n  $el: 'form',\n  bind: '$attrs',\n  meta: {\n    autoAnimate: true,\n  },\n  attrs: {\n    id: '$id',\n    name: '$node.name',\n    onSubmit: '$handlers.submit',\n    'data-loading': '$state.loading || undefined',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * A simple fragment section\n *\n * @public\n */\nexport const fragment = createSection('wrapper', null, true)\n", "import { createSection } from '../createSection'\n\n/**\n * Help section that shows help text\n *\n * @public\n */\nexport const help = createSection('help', () => ({\n  $el: 'div',\n  if: '$help',\n  attrs: {\n    id: '$: \"help-\" + $id',\n  },\n}))\n", "import { createSection, FormKitSchemaExtendableSection } from '../createSection'\n\n/**\n * Icon section used by all icons\n *\n * @public\n */\nexport const icon = (\n  sectionKey: string,\n  el?: string\n): FormKitSchemaExtendableSection => {\n  return createSection(`${sectionKey}Icon`, () => {\n    const rawIconProp = `_raw${sectionKey\n      .charAt(0)\n      .toUpperCase()}${sectionKey.slice(1)}Icon`\n    return {\n      if: `$${sectionKey}Icon && $${rawIconProp}`,\n      $el: `${el ? el : 'span'}`,\n      attrs: {\n        class: `$classes.${sectionKey}Icon + \" \" + $classes.icon`,\n        innerHTML: `$${rawIconProp}`,\n        onClick: `$handlers.iconClick(${sectionKey})`,\n        role: `$fns.iconRole(${sectionKey})`,\n        tabindex: `$fns.iconRole(${sectionKey}) === \"button\" && \"0\" || undefined`,\n        for: {\n          if: `${el === 'label'}`,\n          then: '$id',\n        },\n      },\n    }\n  })()\n}\n", "import { createSection } from '../createSection'\n\n/**\n * Inner section\n *\n * @public\n */\nexport const inner = createSection('inner', 'div')\n", "import { createSection } from '../createSection'\n\n/**\n * Label section with label element\n *\n * @public\n */\nexport const label = createSection('label', () => ({\n  $el: 'label',\n  if: '$label',\n  attrs: {\n    for: '$id',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Legend section, used instead of label when its grouping fields.\n *\n * @public\n */\nexport const legend = createSection('legend', () => ({\n  $el: 'legend',\n  if: '$label',\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Message section, shows a group of messages.\n *\n * @public\n */\nexport const message = createSection('message', () => ({\n  $el: 'li',\n  for: ['message', '$messages'],\n  attrs: {\n    key: '$message.key',\n    id: `$id + '-' + $message.key`,\n    'data-message-type': '$message.type',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Messages section where all messages will be displayed.\n *\n * @public\n */\nexport const messages = createSection('messages', () => ({\n  $el: 'ul',\n  if: '$defaultMessagePlacement && $fns.length($messages)',\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * No file section that shows when there is no files\n *\n * @public\n */\nexport const noFiles = createSection('noFiles', () => ({\n  $el: 'span',\n  if: '$value == null || $value.length == 0',\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Option section used to show options\n *\n * @public\n */\nexport const optGroup = createSection('optGroup', () => ({\n  $el: 'optgroup',\n  bind: '$option.attrs',\n  attrs: {\n    label: '$option.group',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Option section used to show options\n *\n * @public\n */\nexport const option = createSection('option', () => ({\n  $el: 'option',\n  bind: '$option.attrs',\n  attrs: {\n    class: '$classes.option',\n    value: '$option.value',\n    selected: '$fns.isSelected($option)',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Options slot section that displays options when used with slots\n *\n * @public\n */\nexport const optionSlot = createSection('options', () => ({\n  $el: null,\n  if: '$options.length',\n  for: ['option', '$option.options || $options'],\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Outer section where most data attributes are assigned.\n *\n * @public\n */\nexport const outer = createSection('outer', () => ({\n  $el: 'div',\n  meta: {\n    autoAnimate: true,\n  },\n  attrs: {\n    key: '$id',\n    'data-family': '$family || undefined',\n    'data-type': '$type',\n    'data-multiple':\n      '$attrs.multiple || ($type != \"select\" && $options != undefined) || undefined',\n    'data-has-multiple': '$_hasMultipleFiles',\n    'data-disabled': '$: ($disabled !== \"false\" && $disabled) || undefined',\n    'data-empty': '$state.empty || undefined',\n    'data-complete': '$state.complete || undefined',\n    'data-invalid': '$state.invalid || undefined',\n    'data-errors': '$state.errors || undefined',\n    'data-submitted': '$state.submitted || undefined',\n    'data-prefix-icon': '$_rawPrefixIcon !== undefined || undefined',\n    'data-suffix-icon': '$_rawSuffixIcon !== undefined || undefined',\n    'data-prefix-icon-click': '$onPrefixIconClick !== undefined || undefined',\n    'data-suffix-icon-click': '$onSuffixIconClick !== undefined || undefined',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Prefix section\n *\n * @public\n */\nexport const prefix = createSection('prefix', null)\n", "import { createSection } from '../createSection'\n\n/**\n * Input section used by selects\n *\n * @public\n */\nexport const selectInput = createSection('input', () => ({\n  $el: 'select',\n  bind: '$attrs',\n  attrs: {\n    id: '$id',\n    'data-placeholder': '$fns.showPlaceholder($_value, $placeholder)',\n    disabled: '$disabled',\n    class: '$classes.input',\n    name: '$node.name',\n    onChange: '$handlers.onChange',\n    onInput: '$handlers.selectInput',\n    onBlur: '$handlers.blur',\n    'aria-describedby': '$describedBy',\n    'aria-required': '$state.required || undefined',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Submit section that displays a submit button from a form\n *\n * @public\n */\nexport const submitInput = createSection('submit', () => ({\n  $cmp: 'FormKit',\n  bind: '$submitAttrs',\n  props: {\n    type: 'submit',\n    label: '$submitLabel',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Suffix section\n *\n * @public\n */\nexport const suffix = createSection('suffix', null)\n", "import { createSection } from '../createSection'\n\n/**\n * Input section\n *\n * @public\n */\nexport const textInput = createSection('input', () => ({\n  $el: 'input',\n  bind: '$attrs',\n  attrs: {\n    type: '$type',\n    disabled: '$disabled',\n    name: '$node.name',\n    onInput: '$handlers.DOMInput',\n    onBlur: '$handlers.blur',\n    value: '$_value',\n    id: '$id',\n    'aria-describedby': '$describedBy',\n    'aria-required': '$state.required || undefined',\n  },\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Input section used by textarea inputs\n *\n * @public\n */\nexport const textareaInput = createSection('input', () => ({\n  $el: 'textarea',\n  bind: '$attrs',\n  attrs: {\n    disabled: '$disabled',\n    name: '$node.name',\n    onInput: '$handlers.DOMInput',\n    onBlur: '$handlers.blur',\n    value: '$_value',\n    id: '$id',\n    'aria-describedby': '$describedBy',\n    'aria-required': '$state.required || undefined',\n  },\n  children: '$initialValue',\n}))\n", "import { createSection } from '../createSection'\n\n/**\n * Wrapper input section\n *\n * @public\n */\nexport const wrapper = createSection('wrapper', 'div')\n", "import type { FormKitNode } from '@formkit/core'\n\n/**\n * A simple counter to keep track of how many radios have been placed.\n */\nlet radioInstance = 0\n\nexport function resetRadio() {\n  radioInstance = 0\n}\n\n/**\n * Automatically rename any radio inputs.\n * @param node - A formkit node.\n * @returns\n *\n * @public\n */\nexport default function renamesRadios(node: FormKitNode) {\n  if (node.type === 'group' || node.type === 'list') {\n    node.plugins.add(renamesRadiosPlugin)\n  }\n}\n\nfunction renamesRadiosPlugin(node: FormKitNode) {\n  if (node.props.type === 'radio') {\n    node.addProps(['altName'])\n    node.props.altName = `${node.name}_${radioInstance++}`\n  }\n}\n", "import { FormKitNode } from '@formkit/core'\nimport { has } from '@formkit/utils'\nimport normalizeBoxes from './normalizeBoxes'\nimport { shouldSelect, optionValue } from './options'\n\n/**\n * Event handler when an input is toggled.\n *\n * @param node - The {@link @formkit/node#FormKitNode | FormKitNode} being toggled.\n * @param e - The input event related to the toggling.\n *\n * @public\n */\nfunction toggleChecked(node: FormKitNode, e: Event) {\n  const el = e.target\n  if (el instanceof HTMLInputElement) {\n    const value = Array.isArray(node.props.options)\n      ? optionValue(node.props.options, el.value)\n      : el.value\n    if (Array.isArray(node.props.options) && node.props.options.length) {\n      if (!Array.isArray(node._value)) {\n        // There is no array value set\n        node.input([value])\n      } else if (\n        !node._value.some((existingValue) => shouldSelect(value, existingValue))\n      ) {\n        // The value is not in the current set\n        node.input([...node._value, value])\n      } else {\n        // Filter out equivalent values\n        node.input(\n          node._value.filter(\n            (existingValue) => !shouldSelect(value, existingValue)\n          )\n        )\n      }\n    } else {\n      if (el.checked) {\n        node.input(node.props.onValue)\n      } else {\n        node.input(node.props.offValue)\n      }\n    }\n  }\n}\n\n/**\n * Checks if a given option is present in the node value.\n *\n * @param node - The The {@link @formkit/node#FormKitNode | FormKitNode} being checked.\n * @param value - The value of any option.\n *\n * @returns `boolean`\n *\n * @public\n */\nfunction isChecked(node: FormKitNode, value: any) {\n  // We need to force vue’s reactivity to respond when the value is run:\n  node.context?.value\n  node.context?._value\n  if (Array.isArray(node._value)) {\n    return node._value.some((existingValue) =>\n      shouldSelect(optionValue(node.props.options, value), existingValue)\n    )\n  }\n  return false\n}\n\n/**\n * A feature that adds checkbox selection support.\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport default function checkboxes(node: FormKitNode): void {\n  node.on('created', () => {\n    if (node.context?.handlers) {\n      node.context.handlers.toggleChecked = toggleChecked.bind(null, node)\n    }\n    if (node.context?.fns) {\n      node.context.fns.isChecked = isChecked.bind(null, node)\n    }\n    // Configure our default onValue and offValue\n    if (!has(node.props, 'onValue')) node.props.onValue = true\n    if (!has(node.props, 'offValue')) node.props.offValue = false\n  })\n\n  node.hook.prop(normalizeBoxes(node))\n}\n", "import { FormKitMiddleware, FormKitNode } from '@formkit/core'\nimport { extend, slugify } from '@formkit/utils'\n\n/**\n * A feature that normalizes box types (checkboxes, radios).\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @returns A {@link @formkit/node#FormKitMiddleware | FormKitMiddleware}.\n *\n * @public\n */\nexport default function normalizeBoxes(\n  node: FormKitNode\n): FormKitMiddleware<{ prop: string | symbol; value: any }> {\n  return function (prop, next) {\n    if (prop.prop === 'options' && Array.isArray(prop.value)) {\n      prop.value = prop.value.map((option) => {\n        if (!option.attrs?.id) {\n          return extend(option, {\n            attrs: {\n              id: `${node.props.id}-option-${slugify(String(option.value))}`,\n            },\n          })\n        }\n        return option\n      })\n      if (node.props.type === 'checkbox' && !Array.isArray(node.value)) {\n        if (node.isCreated) {\n          node.input([], false)\n        } else {\n          node.on('created', () => {\n            if (!Array.isArray(node.value)) {\n              node.input([], false)\n            }\n          })\n        }\n      }\n    }\n    return next(prop)\n  }\n}\n", "import { FormKitNode } from '@formkit/core'\n\n/**\n * Adds icon props definition.\n *\n * @param sectionKey - the location the icon should be loaded.\n * @param defaultIcon - the icon that should be loaded if a match is found in the user's CSS.\n *\n * @returns A {@link @formkit/core#FormKitPlugin | FormKitPlugin}.\n *\n * @public\n */\nexport default function defaultIcon(sectionKey: string, defaultIcon: string) {\n  return (node: FormKitNode): void => {\n    if (node.props[`${sectionKey}Icon`] === undefined) {\n      node.props[`${sectionKey}Icon`] = defaultIcon.startsWith('<svg')\n        ? defaultIcon\n        : `default:${defaultIcon}`\n    }\n  }\n}\n", "import { FormKitNode } from '@formkit/core'\nimport { undefine } from '@formkit/utils'\n\n/**\n * A feature that allows disabling children of this node.\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport default function disables(node: FormKitNode): void {\n  node.on('created', () => {\n    // If the disabled prop belongs to this *actual* node (not inherited), then\n    // perform an `undefine` on it, if not then we'll let the prop be inherited.\n    if ('disabled' in node.props) {\n      node.props.disabled = undefine(node.props.disabled)\n      node.config.disabled = undefine(node.props.disabled)\n    }\n  })\n  node.hook.prop(({ prop, value }, next) => {\n    value = prop === 'disabled' ? undefine(value) : value\n    return next({ prop, value })\n  })\n  node.on('prop:disabled', ({ payload: value }) => {\n    node.config.disabled = undefine(value)\n  })\n}\n", "import { FormKitNode, createMessage } from '@formkit/core'\n\n/**\n * Creates a new feature that generates a localization message of type ui\n * for use on a given component.\n *\n * @param key - The key of the message.\n * @param value - The value of the message.\n *\n * @returns A {@link @formkit/core#FormKitPlugin | FormKitPlugin}.\n *\n * @public\n */\nexport default function localize(\n  key: string,\n  value?: string\n): (node: FormKitNode) => void {\n  return (node: FormKitNode): void => {\n    node.store.set(\n      /* #__PURE__ */ createMessage({\n        key,\n        type: 'ui',\n        value: value || key,\n        meta: {\n          localize: true,\n          i18nArgs: [node],\n        },\n      })\n    )\n  }\n}\n", "import { FormKitNode } from '@formkit/core'\nimport localize from './localize'\nimport { FormKitFileValue } from '../index'\n\ndeclare global {\n  interface Window {\n    _FormKit_File_Drop: boolean\n  }\n}\n\nconst isBrowser = typeof window !== 'undefined'\n\n/**\n * Remove the data-file-hover attribute from the target.\n *\n * @param e - Event\n *\n * @internal\n */\nfunction removeHover(e: Event) {\n  if (\n    e.target instanceof HTMLElement &&\n    e.target.hasAttribute('data-file-hover')\n  ) {\n    e.target.removeAttribute('data-file-hover')\n  }\n}\n\n/**\n * Prevent stray drag/drop events from navigating the window.\n *\n * @param e - Event\n *\n * @internal\n */\nfunction preventStrayDrop(type: string, e: Event) {\n  if (!(e.target instanceof HTMLInputElement)) {\n    e.preventDefault()\n  } else if (type === 'dragover') {\n    e.target.setAttribute('data-file-hover', 'true')\n  }\n  if (type === 'drop') {\n    removeHover(e)\n  }\n}\n\n/**\n * A feature to add file handling support to an input.\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport default function files(node: FormKitNode): void {\n  // Localize our content:\n  localize('noFiles', 'Select file')(node)\n  localize('removeAll', 'Remove all')(node)\n  localize('remove')(node)\n  node.addProps(['_hasMultipleFiles'])\n\n  if (isBrowser) {\n    if (!window._FormKit_File_Drop) {\n      window.addEventListener(\n        'dragover',\n        preventStrayDrop.bind(null, 'dragover')\n      )\n      window.addEventListener('drop', preventStrayDrop.bind(null, 'drop'))\n      window.addEventListener('dragleave', removeHover)\n      window._FormKit_File_Drop = true\n    }\n  }\n  node.hook.input((value, next) => next(Array.isArray(value) ? value : []))\n  node.on('input', ({ payload: value }) => {\n    node.props._hasMultipleFiles =\n      Array.isArray(value) && value.length > 1 ? true : undefined\n  })\n\n  node.on('reset', () => {\n    if (node.props.id && isBrowser) {\n      const el = document.getElementById(node.props.id)\n      if (el) (el as HTMLInputElement).value = ''\n    }\n  })\n\n  node.on('created', () => {\n    if (!Array.isArray(node.value)) node.input([], false)\n\n    if (!node.context) return\n\n    node.context.handlers.resetFiles = (e: Event) => {\n      e.preventDefault()\n      node.input([])\n      if (node.props.id && isBrowser) {\n        const el = document.getElementById(node.props.id)\n        if (el) (el as HTMLInputElement).value = ''\n        el?.focus()\n      }\n    }\n\n    node.context.handlers.files = (e: Event) => {\n      const files: FormKitFileValue = []\n      if (e.target instanceof HTMLInputElement && e.target.files) {\n        for (let i = 0; i < e.target.files.length; i++) {\n          let file\n          if ((file = e.target.files.item(i))) {\n            files.push({ name: file.name, file })\n          }\n        }\n        node.input(files)\n      }\n      if (node.context) node.context.files = files\n      // Call the original listener if there is one.\n\n      if (typeof node.props.attrs?.onChange === 'function') {\n        node.props.attrs?.onChange(e)\n      }\n    }\n  })\n}\n", "import { createMessage, FormKitNode } from '@formkit/core'\nimport { has, clone } from '@formkit/utils'\n\nconst loading = /* #__PURE__ */ createMessage({\n  key: 'loading',\n  value: true,\n  visible: false,\n})\n\n/**\n * Handle the submit event.\n *\n * @param e - The event\n *\n * @internal\n */\nasync function handleSubmit(node: FormKitNode, submitEvent: Event) {\n  const submitNonce = Math.random()\n  node.props._submitNonce = submitNonce\n  submitEvent.preventDefault()\n  await node.settled\n\n  if (node.ledger.value('validating')) {\n    // There are validation rules still pending.\n    node.store.set(loading)\n    await node.ledger.settled('validating')\n    node.store.remove('loading')\n    // If this was not the same submit event, bail out.\n    if (node.props._submitNonce !== submitNonce) return\n  }\n  // Set the submitted state on all children\n  const setSubmitted = (n: FormKitNode) =>\n    n.store.set(\n      /* #__PURE__ */ createMessage({\n        key: 'submitted',\n        value: true,\n        visible: false,\n      })\n    )\n  node.walk(setSubmitted)\n  setSubmitted(node)\n\n  node.emit('submit-raw')\n  if (typeof node.props.onSubmitRaw === 'function') {\n    node.props.onSubmitRaw(submitEvent, node)\n  }\n\n  if (node.ledger.value('blocking')) {\n    if (typeof node.props.onSubmitInvalid === 'function') {\n      node.props.onSubmitInvalid(node)\n    }\n    // There is still a blocking message in the store.\n    if (node.props.incompleteMessage !== false) {\n      setIncompleteMessage(node)\n    }\n  } else {\n    // No blocking messages\n    if (typeof node.props.onSubmit === 'function') {\n      // call onSubmit\n      const retVal = node.props.onSubmit(\n        node.hook.submit.dispatch(clone(node.value as Record<string, any>)),\n        node\n      )\n      if (retVal instanceof Promise) {\n        const autoDisable =\n          node.props.disabled === undefined &&\n          node.props.submitBehavior !== 'live'\n        if (autoDisable) node.props.disabled = true\n        node.store.set(loading)\n        await retVal\n        if (autoDisable) node.props.disabled = false\n        node.store.remove('loading')\n      }\n    } else {\n      if (submitEvent.target instanceof HTMLFormElement) {\n        submitEvent.target.submit()\n      }\n    }\n  }\n}\n\n/**\n * Set the incomplete message on a specific node.\n * @param node - The node to set the incomplete message on.\n */\nfunction setIncompleteMessage(node: FormKitNode) {\n  node.store.set(\n    /* #__PURE__ */ createMessage({\n      blocking: false,\n      key: `incomplete`,\n      meta: {\n        localize: node.props.incompleteMessage === undefined,\n        i18nArgs: [{ node }],\n        showAsMessage: true,\n      },\n      type: 'ui',\n      value: node.props.incompleteMessage || 'Form incomplete.',\n    })\n  )\n}\n\n/**\n * A feature to add a submit handler and actions section.\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport default function form(node: FormKitNode): void {\n  node.props.isForm = true\n  node.ledger.count('validating', (m) => m.key === 'validating')\n\n  node.props.submitAttrs ??= {\n    disabled: node.props.disabled,\n  }\n\n  node.on('prop:disabled', ({ payload: disabled }) => {\n    node.props.submitAttrs = { ...node.props.submitAttrs, disabled }\n  })\n\n  node.on('created', () => {\n    if (node.context?.handlers) {\n      node.context.handlers.submit = handleSubmit.bind(null, node)\n    }\n    if (!has(node.props, 'actions')) {\n      node.props.actions = true\n    }\n  })\n  node.on('prop:incompleteMessage', () => {\n    if (node.store.incomplete) setIncompleteMessage(node)\n  })\n  node.on('settled:blocking', () => node.store.remove('incomplete'))\n}\n", "import { FormKitNode } from '@formkit/core'\n\n/**\n * A feature that applies `ignore=\"true\"` by default.\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport default function ignore(node: FormKitNode): void {\n  if (node.props.ignore === undefined) {\n    node.props.ignore = true\n    node.parent = null\n  }\n}\n", "import { FormKitNode } from '@formkit/core'\n\n/**\n * A feature that ensures the input has an `initialValue` prop.\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport default function initialValue(node: FormKitNode): void {\n  node.on('created', () => {\n    if (node.context) {\n      node.context.initialValue = node.value || ''\n    }\n  })\n}\n", "import { FormKitNode } from '@formkit/core'\n\n/**\n * A feature that allows casting to numbers.\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport default function casts(node: FormKitNode): void {\n  if (typeof node.props.number === 'undefined') return\n  const strict = ['number', 'range', 'hidden'].includes(node.props.type)\n  node.hook.input((value, next) => {\n    if (value === '') return next(undefined)\n    const numericValue =\n      node.props.number === 'integer' ? parseInt(value) : parseFloat(value)\n    if (!Number.isFinite(numericValue))\n      return strict ? next(undefined) : next(value)\n    return next(numericValue)\n  })\n}\n", "import { FormKitNode, warn } from '@formkit/core'\nimport normalizeBoxes from './normalizeBoxes'\nimport { optionValue, shouldSelect } from './options'\n\n/**\n * Sets the value of a radio button when checked.\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n * @param event - Event\n *\n * @public\n */\nfunction toggleChecked(node: FormKitNode, event: Event) {\n  if (event.target instanceof HTMLInputElement) {\n    node.input(optionValue(node.props.options, event.target.value))\n  }\n}\n\n/**\n * Checks if the value being checked is the current value.\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n * @param value - The value to check\n *\n * @returns `boolean`\n *\n * @public\n */\nfunction isChecked(node: FormKitNode, value: string) {\n  // We need to force vue’s reactivity to respond when the value is run:\n  node.context?.value\n  node.context?._value\n  return shouldSelect(optionValue(node.props.options, value), node._value)\n}\n\n/**\n * A feature to check if the value being checked is the current value.\n *\n * @param node - A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @public\n */\nexport default function radios(node: FormKitNode): void {\n  node.on('created', () => {\n    if (!Array.isArray(node.props.options)) {\n      warn(350, {\n        node,\n        inputType: 'radio',\n      })\n    }\n    if (node.context?.handlers) {\n      node.context.handlers.toggleChecked = toggleChecked.bind(null, node)\n    }\n    if (node.context?.fns) {\n      node.context.fns.isChecked = isChecked.bind(null, node)\n    }\n  })\n  node.hook.prop(normalizeBoxes(node))\n}\n", "import {\n  FormKitOptionsItem,\n  FormKitOptionsGroupItem,\n  FormKitOptionsListWithGroups,\n} from './../props'\nimport { FormKitNode } from '@formkit/core'\nimport { undefine, eq } from '@formkit/utils'\nimport { shouldSelect, optionValue } from './options'\nimport { FormKitOptionsList, isGroupOption } from '../props'\n\n/**\n * Checks if a the given option should have the selected attribute.\n * @param node - The node being evaluated.\n * @param option - The option value to check\n * @returns\n * @public\n */\nfunction isSelected(\n  node: FormKitNode,\n  option: FormKitOptionsItem | FormKitOptionsGroupItem\n) {\n  if (isGroupOption(option)) return false\n  // Here we trick reactivity (if at play) to watch this function.\n  node.context && node.context.value\n  const optionValue = '__original' in option ? option.__original : option.value\n  return Array.isArray(node._value)\n    ? node._value.some((optionA) => shouldSelect(optionA, optionValue))\n    : (node._value === undefined ||\n        (node._value === null && !containsValue(node.props.options, null))) &&\n      option.attrs &&\n      option.attrs['data-is-placeholder']\n    ? true\n    : shouldSelect(optionValue, node._value)\n}\n\n/**\n * Checks to see if a given value is anywhere in the options list.\n */\nfunction containsValue(\n  options: FormKitOptionsListWithGroups,\n  value: unknown\n): boolean {\n  return options.some((option) => {\n    if (isGroupOption(option)) {\n      return containsValue(option.options, value)\n    } else {\n      return (\n        ('__original' in option ? option.__original : option.value) === value\n      )\n    }\n  })\n}\n\n/**\n * Defers the change event till after the next cycle.\n * @param node - The node being evaluated.\n * @param e - The change event.\n */\nasync function deferChange(node: FormKitNode, e: Event) {\n  if (typeof node.props.attrs?.onChange === 'function') {\n    await new Promise((r) => setTimeout(r, 0))\n    await node.settled\n    node.props.attrs.onChange(e)\n  }\n}\n\n/**\n * Select the correct values.\n * @param e - The input event emitted by the select.\n */\nfunction /* #__PURE__ */ selectInput(node: FormKitNode, e: Event) {\n  const target = e.target as HTMLSelectElement\n  const value = target.hasAttribute('multiple')\n    ? Array.from(target.selectedOptions).map((o) =>\n        optionValue(node.props.options, o.value)\n      )\n    : optionValue(node.props.options, target.value)\n  node.input(value)\n}\n\n/**\n * Appends a placeholder to the options list.\n * @param options - An options list\n * @param placeholder - A placeholder string to append\n * @returns\n */\nfunction applyPlaceholder(options: FormKitOptionsList, placeholder: string) {\n  if (\n    !options.some(\n      (option) => option.attrs && option.attrs['data-is-placeholder']\n    )\n  ) {\n    return [\n      {\n        label: placeholder,\n        value: '',\n        attrs: {\n          hidden: true,\n          disabled: true,\n          'data-is-placeholder': 'true',\n        },\n      },\n      ...options,\n    ]\n  }\n  return options\n}\n\n/**\n * Given an options list, find the first true value.\n * @param options - An options list (with groups)\n */\nfunction firstValue(options: FormKitOptionsListWithGroups): unknown {\n  const option = options.length > 0 ? options[0] : undefined\n  if (!option) return undefined\n  if (isGroupOption(option)) return firstValue(option.options)\n  return '__original' in option ? option.__original : option.value\n}\n\n/**\n * Converts the options prop to usable values.\n * @param node - A formkit node.\n * @public\n */\nexport default function select(node: FormKitNode): void {\n  // Set the initial value of a multi-input\n  node.on('created', () => {\n    const isMultiple = undefine(node.props.attrs?.multiple)\n\n    if (\n      !isMultiple &&\n      node.props.placeholder &&\n      Array.isArray(node.props.options)\n    ) {\n      node.hook.prop(({ prop, value }, next) => {\n        if (prop === 'options') {\n          value = applyPlaceholder(value, node.props.placeholder)\n        }\n        return next({ prop, value })\n      })\n      node.props.options = applyPlaceholder(\n        node.props.options,\n        node.props.placeholder\n      )\n    }\n    if (isMultiple) {\n      if (node.value === undefined) {\n        node.input([], false)\n      }\n    } else if (node.context && !node.context.options) {\n      // If this input is (probably) using the default slot, we need to add a\n      // \"value\" attribute to get bound\n      node.props.attrs = Object.assign({}, node.props.attrs, {\n        value: node._value,\n      })\n      node.on('input', ({ payload }) => {\n        node.props.attrs = Object.assign({}, node.props.attrs, {\n          value: payload,\n        })\n      })\n    }\n    if (node.context?.handlers) {\n      node.context.handlers.selectInput = selectInput.bind(null, node)\n      node.context.handlers.onChange = deferChange.bind(null, node)\n    }\n    if (node.context?.fns) {\n      node.context.fns.isSelected = isSelected.bind(null, node)\n      node.context.fns.showPlaceholder = (value: unknown, placeholder) => {\n        if (!Array.isArray(node.props.options)) return false\n        const hasMatchingValue = node.props.options.some(\n          (option: FormKitOptionsItem) => {\n            if (option.attrs && 'data-is-placeholder' in option.attrs)\n              return false\n            const optionValue =\n              '__original' in option ? option.__original : option.value\n            return eq(value, optionValue)\n          }\n        )\n        return placeholder && !hasMatchingValue ? true : undefined\n      }\n    }\n  })\n\n  node.hook.input((value, next) => {\n    if (\n      !node.props.placeholder &&\n      value === undefined &&\n      Array.isArray(node.props?.options) &&\n      node.props.options.length &&\n      !undefine(node.props?.attrs?.multiple)\n    ) {\n      value = firstValue(node.props.options)\n    }\n    return next(value)\n  })\n}\n", "import { FormKitTypeDefinition } from '@formkit/core'\nimport {\n  outer,\n  wrapper,\n  help,\n  messages,\n  message,\n  icon,\n  prefix,\n  suffix,\n  buttonInput,\n  buttonLabel,\n  localize,\n  ignores,\n} from '../compose'\n\n/**\n * Input definition for a button.\n * @public\n */\nexport const button: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ outer(\n    /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value')),\n    /* #__PURE__ */ wrapper(\n      /* #__PURE__ */ buttonInput(\n        /* #__PURE__ */ icon('prefix'),\n        /* #__PURE__ */ prefix(),\n        /* #__PURE__ */ buttonLabel('$label || $ui.submit.value'),\n        /* #__PURE__ */ suffix(),\n        /* #__PURE__ */ icon('suffix')\n      )\n    ),\n    /* #__PURE__ */ help('$help')\n  ),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'input',\n  /**\n   * The family of inputs this one belongs too. For example \"text\" and \"email\"\n   * are both part of the \"text\" family. This is primary used for styling.\n   */\n  family: 'button',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: [],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [localize('submit'), ignores],\n  /**\n   * A key to use for memoizing the schema. This is used to prevent the schema\n   * from needing to be stringified when performing a memo lookup.\n   */\n  schemaMemoKey: 'h6st4epl3j8',\n}\n", "import { FormKitTypeDefinition } from '@formkit/core'\nimport {\n  outer,\n  boxInner,\n  help,\n  boxHelp,\n  messages,\n  message,\n  prefix,\n  suffix,\n  fieldset,\n  decorator,\n  box,\n  icon,\n  legend,\n  boxOption,\n  boxOptions,\n  boxWrapper,\n  boxLabel,\n  options,\n  checkboxes,\n  $if,\n  $extend,\n  defaultIcon,\n} from '../compose'\n\n/**\n * Input definition for a checkbox(ess).\n * @public\n */\nexport const checkbox: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ outer(\n    $if(\n      '$options == undefined',\n      /**\n       * Single checkbox structure.\n       */\n      /* #__PURE__ */ boxWrapper(\n        /* #__PURE__ */ boxInner(/* #__PURE__ */ prefix(), /* #__PURE__ */ box(), /* #__PURE__ */ decorator(/* #__PURE__ */ icon('decorator')), /* #__PURE__ */ suffix()),\n        $extend(/* #__PURE__ */ boxLabel('$label'), {\n          if: '$label',\n        })\n      ),\n      /**\n       * Multi checkbox structure.\n       */\n      /* #__PURE__ */ fieldset(\n        /* #__PURE__ */ legend('$label'),\n        /* #__PURE__ */ help('$help'),\n        /* #__PURE__ */ boxOptions(\n          /* #__PURE__ */ boxOption(\n            /* #__PURE__ */ boxWrapper(\n              /* #__PURE__ */ boxInner(\n                /* #__PURE__ */ prefix(),\n                $extend(/* #__PURE__ */ box(), {\n                  bind: '$option.attrs',\n                  attrs: {\n                    id: '$option.attrs.id',\n                    value: '$option.value',\n                    checked: '$fns.isChecked($option.value)',\n                  },\n                }),\n                /* #__PURE__ */ decorator(/* #__PURE__ */ icon('decorator')),\n                /* #__PURE__ */ suffix()\n              ),\n              $extend(/* #__PURE__ */ boxLabel('$option.label'), {\n                if: '$option.label',\n              })\n            ),\n            /* #__PURE__ */ boxHelp('$option.help')\n          )\n        )\n      )\n    ),\n    // Help text only goes under the input when it is a single.\n    $if('$options == undefined && $help', /* #__PURE__ */ help('$help')),\n    /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value'))\n  ),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'input',\n  /**\n   * The family of inputs this one belongs too. For example \"text\" and \"email\"\n   * are both part of the \"text\" family. This is primary used for styling.\n   */\n  family: 'box',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: ['options', 'onValue', 'offValue', 'optionsLoader'],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [\n    options,\n    checkboxes,\n    defaultIcon('decorator', 'checkboxDecorator'),\n  ],\n  /**\n   * The key used to memoize the schema.\n   */\n  schemaMemoKey: 'qje02tb3gu8',\n}\n", "import { FormKitTypeDefinition } from '@formkit/core'\nimport {\n  outer,\n  inner,\n  wrapper,\n  label,\n  help,\n  messages,\n  message,\n  prefix,\n  suffix,\n  icon,\n  fileInput,\n  fileItem,\n  fileList,\n  fileName,\n  fileRemove,\n  noFiles,\n  files,\n  $if,\n  defaultIcon,\n} from '../compose'\n\n/**\n * Input definition for a file input.\n * @public\n */\nexport const file: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ outer(\n    /* #__PURE__ */ wrapper(\n      /* #__PURE__ */ label('$label'),\n      /* #__PURE__ */ inner(\n        /* #__PURE__ */ icon('prefix', 'label'),\n        /* #__PURE__ */ prefix(),\n        /* #__PURE__ */ fileInput(),\n        /* #__PURE__ */ fileList(\n          /* #__PURE__ */ fileItem(\n            /* #__PURE__ */ icon('fileItem'),\n            /* #__PURE__ */ fileName('$file.name'),\n            $if(\n              '$value.length === 1',\n              /* #__PURE__ */ fileRemove(\n                /* #__PURE__ */ icon('fileRemove'),\n                '$ui.remove.value + \" \" + $file.name'\n              )\n            )\n          )\n        ),\n        $if('$value.length > 1', /* #__PURE__ */ fileRemove('$ui.removeAll.value')),\n        /* #__PURE__ */ noFiles(/* #__PURE__ */ icon('noFiles'), '$ui.noFiles.value'),\n        /* #__PURE__ */ suffix(),\n        /* #__PURE__ */ icon('suffix')\n      )\n    ),\n    /* #__PURE__ */ help('$help'),\n    /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value'))\n  ),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'input',\n  /**\n   * The family of inputs this one belongs too. For example \"text\" and \"email\"\n   * are both part of the \"text\" family. This is primary used for styling.\n   */\n  family: 'text',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: [],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [\n    files,\n    defaultIcon('fileItem', 'fileItem'),\n    defaultIcon('fileRemove', 'fileRemove'),\n    defaultIcon('noFiles', 'noFiles'),\n  ],\n  /**\n   * The key used to memoize the schema.\n   */\n  schemaMemoKey: '9kqc4852fv8',\n}\n", "import { FormKitTypeDefinition } from '@formkit/core'\nimport {\n  formInput,\n  messages,\n  message,\n  actions,\n  submitInput,\n  forms,\n  disablesChildren,\n} from '../compose'\n\n/**\n * Input definition for a form.\n * @public\n */\nexport const form: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ formInput(\n    '$slots.default',\n    /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value')),\n    /* #__PURE__ */ actions(/* #__PURE__ */ submitInput())\n  ),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'group',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: [\n    'actions',\n    'submit',\n    'submitLabel',\n    'submitAttrs',\n    'submitBehavior',\n    'incompleteMessage',\n  ],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [forms, disablesChildren],\n  /**\n   * The key used to memoize the schema.\n   */\n  schemaMemoKey: '5bg016redjo',\n}\n", "import { FormKitTypeDefinition } from '@formkit/core'\nimport { fragment, disablesChildren, renamesRadios } from '../compose'\n\n/**\n * Input definition for a group.\n * @public\n */\nexport const group: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ fragment('$slots.default'),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'group',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: [],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [disablesChildren, renamesRadios],\n}\n", "import { FormKitTypeDefinition } from '@formkit/core'\nimport { textInput, casts } from '../compose'\n\n/**\n * Input definition for a hidden input.\n * @public\n */\nexport const hidden: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ textInput(),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'input',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: [],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [casts],\n}\n", "import { FormKitTypeDefinition } from '@formkit/core'\nimport { fragment, disablesChildren, renamesRadios } from '../compose'\n\n/**\n * Input definition for a list.\n * @public\n */\nexport const list: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ fragment('$slots.default'),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'list',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: ['sync', 'dynamic'],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [disablesChildren, renamesRadios],\n}\n", "import { FormKitTypeDefinition } from '@formkit/core'\nimport { fragment } from '../compose'\n\n/**\n * Input definition for a meta input.\n * @public\n */\nexport const meta: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ fragment(),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'input',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: [],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [],\n}\n", "import { FormKitTypeDefinition } from '@formkit/core'\nimport {\n  outer,\n  boxInner,\n  help,\n  boxHelp,\n  messages,\n  message,\n  prefix,\n  suffix,\n  fieldset,\n  decorator,\n  box,\n  icon,\n  legend,\n  boxOption,\n  boxOptions,\n  boxWrapper,\n  boxLabel,\n  options,\n  radios,\n  $if,\n  $extend,\n  defaultIcon,\n} from '../compose'\n\n/**\n * Input definition for a radio.\n * @public\n */\nexport const radio: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ outer(\n    $if(\n      '$options == undefined',\n      /**\n       * Single radio structure.\n       */\n      /* #__PURE__ */ boxWrapper(\n        /* #__PURE__ */ boxInner(/* #__PURE__ */ prefix(), /* #__PURE__ */ box(), /* #__PURE__ */ decorator(/* #__PURE__ */ icon('decorator')), /* #__PURE__ */ suffix()),\n        $extend(/* #__PURE__ */ boxLabel('$label'), {\n          if: '$label',\n        })\n      ),\n      /**\n       * Multi radio structure.\n       */\n      /* #__PURE__ */ fieldset(\n        /* #__PURE__ */ legend('$label'),\n        /* #__PURE__ */ help('$help'),\n        /* #__PURE__ */ boxOptions(\n          /* #__PURE__ */ boxOption(\n            /* #__PURE__ */ boxWrapper(\n              /* #__PURE__ */ boxInner(\n                /* #__PURE__ */ prefix(),\n                $extend(/* #__PURE__ */ box(), {\n                  bind: '$option.attrs',\n                  attrs: {\n                    id: '$option.attrs.id',\n                    value: '$option.value',\n                    checked: '$fns.isChecked($option.value)',\n                  },\n                }),\n                /* #__PURE__ */ decorator(/* #__PURE__ */ icon('decorator')),\n                /* #__PURE__ */ suffix()\n              ),\n              $extend(/* #__PURE__ */ boxLabel('$option.label'), {\n                if: '$option.label',\n              })\n            ),\n            /* #__PURE__ */ boxHelp('$option.help')\n          )\n        )\n      )\n    ),\n    // Help text only goes under the input when it is a single.\n    $if('$options == undefined && $help', /* #__PURE__ */ help('$help')),\n    /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value'))\n  ),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'input',\n  /**\n   * The family of inputs this one belongs too. For example \"text\" and \"email\"\n   * are both part of the \"text\" family. This is primary used for styling.\n   */\n  family: 'box',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: ['options', 'onValue', 'offValue', 'optionsLoader'],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [options, radios, defaultIcon('decorator', 'radioDecorator')],\n  /**\n   * The key used to memoize the schema.\n   */\n  schemaMemoKey: 'qje02tb3gu8',\n}\n", "import { FormKitTypeDefinition } from '@formkit/core'\nimport {\n  outer,\n  inner,\n  wrapper,\n  label,\n  help,\n  messages,\n  message,\n  prefix,\n  suffix,\n  icon,\n  selectInput,\n  option,\n  optionSlot,\n  optGroup,\n  $if,\n  options,\n  selects,\n  defaultIcon,\n} from '../compose'\n\n/**\n * Input definition for a select.\n * @public\n */\nexport const select: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ outer(\n    /* #__PURE__ */ wrapper(\n      /* #__PURE__ */ label('$label'),\n      /* #__PURE__ */ inner(\n        /* #__PURE__ */ icon('prefix'),\n        /* #__PURE__ */ prefix(),\n        /* #__PURE__ */ selectInput(\n          $if(\n            '$slots.default',\n            () => '$slots.default',\n            /* #__PURE__ */ optionSlot(\n              $if(\n                '$option.group',\n                /* #__PURE__ */ optGroup(/* #__PURE__ */ optionSlot(/* #__PURE__ */ option('$option.label'))),\n                /* #__PURE__ */ option('$option.label')\n              )\n            )\n          )\n        ),\n        $if('$attrs.multiple !== undefined', () => '', /* #__PURE__ */ icon('select')),\n        /* #__PURE__ */ suffix(),\n        /* #__PURE__ */ icon('suffix')\n      )\n    ),\n    /* #__PURE__ */ help('$help'),\n    /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value'))\n  ),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'input',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: ['options', 'placeholder', 'optionsLoader'],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [options, selects, defaultIcon('select', 'select')],\n  /**\n   * The key used to memoize the schema.\n   */\n  schemaMemoKey: 'cb119h43krg',\n}\n", "import { FormKitTypeDefinition } from '@formkit/core'\nimport {\n  outer,\n  inner,\n  wrapper,\n  label,\n  help,\n  messages,\n  message,\n  prefix,\n  suffix,\n  icon,\n  textareaInput,\n  initialValue,\n} from '../compose'\n\n/**\n * Input definition for a textarea.\n * @public\n */\nexport const textarea: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ outer(\n    /* #__PURE__ */ wrapper(\n      /* #__PURE__ */ label('$label'),\n      /* #__PURE__ */ inner(\n        /* #__PURE__ */ icon('prefix', 'label'),\n        /* #__PURE__ */ prefix(),\n        /* #__PURE__ */ textareaInput(),\n        /* #__PURE__ */ suffix(),\n        /* #__PURE__ */ icon('suffix')\n      )\n    ),\n    /* #__PURE__ */ help('$help'),\n    /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value'))\n  ),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'input',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: [],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [initialValue],\n  /**\n   * The key used to memoize the schema.\n   */\n  schemaMemoKey: 'b1n0td79m9g',\n}\n", "import { FormKitTypeDefinition } from '@formkit/core'\nimport {\n  outer,\n  inner,\n  wrapper,\n  label,\n  help,\n  messages,\n  message,\n  icon,\n  prefix,\n  suffix,\n  textInput,\n  casts,\n} from '../compose'\n\n/**\n * Input definition for a text.\n * @public\n */\nexport const text: FormKitTypeDefinition = {\n  /**\n   * The actual schema of the input, or a function that returns the schema.\n   */\n  schema: /* #__PURE__ */ outer(\n    /* #__PURE__ */ wrapper(\n      /* #__PURE__ */ label('$label'),\n      /* #__PURE__ */ inner(\n        /* #__PURE__ */ icon('prefix', 'label'),\n        /* #__PURE__ */ prefix(),\n        /* #__PURE__ */ textInput(),\n        /* #__PURE__ */ suffix(),\n        /* #__PURE__ */ icon('suffix')\n      )\n    ),\n    /* #__PURE__ */ help('$help'),\n    /* #__PURE__ */ messages(/* #__PURE__ */ message('$message.value'))\n  ),\n  /**\n   * The type of node, can be a list, group, or input.\n   */\n  type: 'input',\n  /**\n   * The family of inputs this one belongs too. For example \"text\" and \"email\"\n   * are both part of the \"text\" family. This is primary used for styling.\n   */\n  family: 'text',\n  /**\n   * An array of extra props to accept for this input.\n   */\n  props: [],\n  /**\n   * Additional features that should be added to your input\n   */\n  features: [casts],\n  /**\n   * The key used to memoize the schema.\n   */\n  schemaMemoKey: 'c3cc4kflsg',\n}\n", "/**\n * The official FormKit Inputs plugin. This package contains the source code for\n * all native HTML input types. Read the\n * {@link https://formkit.com/essentials/inputs | inputs documentation} for\n * usage instructions.\n *\n * @packageDocumentation\n */\n\n/**\n * Export the plugin.\n */\nexport { createLibraryPlugin } from './plugin'\n\n/**\n * Helper function for normalizing options.\n */\nexport { normalizeOptions } from './features/options'\n\n/**\n * createSection() and related utilities.\n */\nexport {\n  FormKitSchemaExtendableSection,\n  FormKitSection,\n  createSection,\n  isSchemaObject,\n  extendSchema,\n} from './createSection'\n\n/**\n * Composable logic.\n */\nexport * from './compose'\n\n/**\n * Prop types.\n */\nexport * from './props'\n\n/**\n * A single file object in FormKit’s synthetic \"FileList\".\n *\n * @public\n */\nexport interface FormKitFile {\n  name: string\n  file?: File\n}\n\n/**\n * A synthetic array-based \"FileList\".\n *\n * @public\n */\nexport type FormKitFileValue = FormKitFile[]\n\n/**\n * Export again as group.\n */\nimport { button } from './inputs/button'\nimport { button as submit } from './inputs/button'\nimport { checkbox } from './inputs/checkbox'\nimport { file } from './inputs/file'\nimport { form } from './inputs/form'\nimport { group } from './inputs/group'\nimport { hidden } from './inputs/hidden'\nimport { list } from './inputs/list'\nimport { meta } from './inputs/meta'\nimport { radio } from './inputs/radio'\nimport { select } from './inputs/select'\nimport { textarea } from './inputs/textarea'\nimport { text } from './inputs/text'\nimport { text as color } from './inputs/text'\nimport { text as date } from './inputs/text'\nimport { text as datetimeLocal } from './inputs/text'\nimport { text as email } from './inputs/text'\nimport { text as month } from './inputs/text'\nimport { text as number } from './inputs/text'\nimport { text as password } from './inputs/text'\nimport { text as search } from './inputs/text'\nimport { text as tel } from './inputs/text'\nimport { text as time } from './inputs/text'\nimport { text as url } from './inputs/text'\nimport { text as week } from './inputs/text'\nimport { text as range } from './inputs/text'\n\nexport {\n  button,\n  submit,\n  checkbox,\n  file,\n  form,\n  group,\n  hidden,\n  list,\n  meta,\n  radio,\n  select,\n  textarea,\n  text,\n  color,\n  date,\n  datetimeLocal,\n  email,\n  month,\n  number,\n  password,\n  search,\n  tel,\n  time,\n  url,\n  week,\n  range,\n}\n\nexport const inputs = {\n  button,\n  submit,\n  checkbox,\n  file,\n  form,\n  group,\n  hidden,\n  list,\n  meta,\n  radio,\n  select,\n  textarea,\n  text,\n  color,\n  date,\n  datetimeLocal,\n  email,\n  month,\n  number,\n  password,\n  search,\n  tel,\n  time,\n  url,\n  week,\n  range,\n}\n", "/**\n * This package contains the official themes for FormKit. Read the\n * {@link https://formkit.com/getting-started/installation |\n * installation documentation} for more information.\n *\n * @packageDocumentation\n */\n\nimport {\n  FORMKIT_VERSION,\n  FormKitNode,\n  FormKitClasses,\n  FormKitEvent,\n} from '@formkit/core'\n\n/**\n * A function that returns a class list string\n * @internal\n */\ntype ClassFunction = (node: FormKitNode, sectionKey: string) => string\n\n/**\n * A function that returns an icon SVG string.\n * @public\n */\nexport interface FormKitIconLoader {\n  (iconName: string): string | undefined | Promise<string | undefined>\n}\n\n/**\n * A function that returns a remote URL for retrieving an SVG icon by name.\n * @public\n */\nexport interface FormKitIconLoaderUrl {\n  (iconName: string): string | undefined\n}\n\n/**\n * A function to generate FormKit class functions from a JavaScript object.\n * @param classes - An object of input types with nested objects of sectionKeys and class lists.\n * @returns An object of sectionKeys with class functions.\n * @public\n */\nexport function generateClasses(\n  classes: Record<string, Record<string, string>>\n): Record<string, string | FormKitClasses | Record<string, boolean>> {\n  const classesBySectionKey: Record<string, Record<string, any>> = {}\n  Object.keys(classes).forEach((type) => {\n    Object.keys(classes[type]).forEach((sectionKey) => {\n      if (!classesBySectionKey[sectionKey]) {\n        classesBySectionKey[sectionKey] = {\n          [type]: classes[type][sectionKey],\n        }\n      } else {\n        classesBySectionKey[sectionKey][type] = classes[type][sectionKey]\n      }\n    })\n  })\n\n  Object.keys(classesBySectionKey).forEach((sectionKey) => {\n    const classesObject = classesBySectionKey[sectionKey]\n    classesBySectionKey[sectionKey] = function (node, sectionKey) {\n      return addClassesBySection(node, sectionKey, classesObject)\n    } as ClassFunction\n  })\n\n  return classesBySectionKey\n}\n\n/**\n * Updates a class list for a given sectionKey\n * @param node - the FormKit node being operated on\n * @param sectionKey - The section key to which the class list will be applied\n * @param classByType - Object containing mappings of class lists to section keys\n * @returns\n * @public\n */\nfunction addClassesBySection(\n  node: FormKitNode,\n  _sectionKey: string,\n  classesByType: Record<string, () => string>\n): string {\n  const type = node.props.type\n  const family = node.props.family\n  let classList = ''\n  if (classesByType.global) {\n    classList += classesByType.global + ' '\n  }\n  if (classesByType[`family:${family}`]) {\n    classList += classesByType[`family:${family}`] + ' '\n  }\n  if (classesByType[type]) {\n    classList += classesByType[type]\n  }\n  const listParts = classList.split('$reset')\n  if (listParts.length > 1) {\n    return `$reset ${listParts[listParts.length - 1].trim()}`\n  }\n  return listParts[0].trim()\n}\n\n/**\n * The document's computed CSS styles\n */\nlet documentStyles: Record<any, any> | undefined = undefined\nlet documentThemeLinkTag: HTMLElement | null = null\n\n/**\n * Stores the state of theme loading\n */\nlet themeDidLoad: (value?: unknown) => void\nlet themeHasLoaded = false\nlet themeWasRequested = false\n\nconst themeLoaded = /* #__PURE__ */ new Promise<void>((res) => {\n  themeDidLoad = () => {\n    themeHasLoaded = true\n    res()\n  }\n})\n\n/**\n * Check if we are client-side\n */\nconst isClient = typeof window !== 'undefined' && typeof fetch !== 'undefined'\ndocumentStyles = isClient\n  ? /* #__PURE__ */ getComputedStyle(document.documentElement)\n  : undefined\n\n/**\n * The FormKit icon Registry - a global record of loaded icons.\n * @public\n */\nexport const iconRegistry: Record<string, string | undefined> = {}\n\n/**\n * A collection of existing icon requests to avoid duplicate fetching\n */\nconst iconRequests: Record<string, any> = {}\n\n/**\n * Creates the theme plugin based on a given theme name.\n * @param theme - The name or id of the theme to apply.\n * @param icons - Icons you want to add to the global icon registry.\n * @param iconLoaderUrl - A function that returns a remote url for retrieving an\n * SVG icon by name.\n * @param iconLoader - A function that handles loading an icon when it is not\n * found in the registry.\n * @public\n */\nexport function createThemePlugin(\n  theme?: string,\n  icons?: Record<string, string | undefined>,\n  iconLoaderUrl?: FormKitIconLoaderUrl,\n  iconLoader?: FormKitIconLoader\n): (node: FormKitNode) => any {\n  if (icons) {\n    // add any user-provided icons to the registry\n    Object.assign(iconRegistry, icons)\n  }\n\n  // if we have a theme declared, request it\n  if (\n    isClient &&\n    !themeWasRequested &&\n    documentStyles?.getPropertyValue('--formkit-theme')\n  ) {\n    // we have the theme loaded locally\n    themeDidLoad()\n    themeWasRequested = true\n  } else if (theme && !themeWasRequested && isClient) {\n    // we have the theme name but need to request it remotely\n    loadTheme(theme)\n  } else if (!themeWasRequested && isClient) {\n    // we don't have a discoverable theme, so don't wait for it\n    themeDidLoad()\n  }\n\n  const themePlugin = function themePlugin(node: FormKitNode) {\n    // register the icon handler, and override with local prop value if it exists\n    node.addProps(['iconLoader', 'iconLoaderUrl'])\n    node.props.iconHandler = createIconHandler(\n      node.props?.iconLoader ? node.props.iconLoader : iconLoader,\n      node.props?.iconLoaderUrl ? node.props.iconLoaderUrl : iconLoaderUrl\n    )\n    loadIconPropIcons(node, node.props.iconHandler)\n\n    node.on('created', () => {\n      // set up the `-icon` click handlers\n      if (node?.context?.handlers) {\n        node.context.handlers.iconClick = (\n          sectionKey: string\n        ): ((e: MouseEvent) => void) | void => {\n          const clickHandlerProp = `on${sectionKey\n            .charAt(0)\n            .toUpperCase()}${sectionKey.slice(1)}IconClick`\n          const handlerFunction = node.props[clickHandlerProp]\n          if (handlerFunction && typeof handlerFunction === 'function') {\n            return (e: MouseEvent) => {\n              return handlerFunction(node, e)\n            }\n          }\n          return undefined\n        }\n      }\n      if (node?.context?.fns) {\n        node.context.fns.iconRole = (sectionKey: string): string | null => {\n          const clickHandlerProp = `on${sectionKey\n            .charAt(0)\n            .toUpperCase()}${sectionKey.slice(1)}IconClick`\n          return typeof node.props[clickHandlerProp] === 'function'\n            ? 'button'\n            : null\n        }\n      }\n    })\n  }\n\n  themePlugin.iconHandler = createIconHandler(iconLoader, iconLoaderUrl)\n  return themePlugin\n}\n\n/**\n * Loads a FormKit theme\n */\nfunction loadTheme(theme: string) {\n  if (!theme || !isClient || typeof getComputedStyle !== 'function') {\n    // if we're not client-side then bail\n    return\n  }\n\n  // since we're client-side, flag that we've requested the theme\n  themeWasRequested = true\n\n  documentThemeLinkTag = document.getElementById('formkit-theme')\n\n  // retrieve document styles on plugin creation when the window object exists\n\n  if (\n    theme &&\n    // if we have a window object\n    isClient &&\n    // we don't have an existing theme OR the theme being set up is different\n    ((!documentStyles?.getPropertyValue('--formkit-theme') &&\n      !documentThemeLinkTag) ||\n      (documentThemeLinkTag?.getAttribute('data-theme') &&\n        documentThemeLinkTag?.getAttribute('data-theme') !== theme))\n  ) {\n    // if for some reason we didn't overwrite the __FKV__ token during publish\n    // then use the `latest` tag for CDN fetching. (this applies to local dev as well)\n    const formkitVersion = FORMKIT_VERSION.startsWith('__')\n      ? 'latest'\n      : FORMKIT_VERSION\n    const themeUrl = `https://cdn.jsdelivr.net/npm/@formkit/themes@${formkitVersion}/dist/${theme}/theme.css`\n    const link = document.createElement('link')\n    link.type = 'text/css'\n    link.rel = 'stylesheet'\n    link.id = 'formkit-theme'\n    link.setAttribute('data-theme', theme)\n    link.onload = () => {\n      documentStyles = getComputedStyle(document.documentElement) // grab new variables from theme\n      themeDidLoad()\n    }\n    document.head.appendChild(link)\n    link.href = themeUrl\n    // if we had an existing theme being loaded, remove it.\n    if (documentThemeLinkTag) {\n      documentThemeLinkTag.remove()\n    }\n  }\n}\n\n/**\n * Returns a function responsible for loading an icon by name.\n * @param iconLoader - a function for loading an icon when it's not found in the\n * iconRegistry.\n * @param iconLoaderUrl - a function that returns a remote URL for retrieving an\n * SVG icon by name.\n * @public\n */\nexport function createIconHandler(\n  iconLoader?: FormKitIconLoader,\n  iconLoaderUrl?: FormKitIconLoaderUrl\n): FormKitIconLoader {\n  return (\n    iconName: string | boolean\n  ): string | undefined | Promise<string | undefined> => {\n    // bail if we got something that wasn't string\n    if (typeof iconName !== 'string') return\n    // if we're dealing with an inline SVG, just use it as-is\n    if (iconName.startsWith('<svg')) {\n      return iconName\n    }\n\n    // is this a default icon that should only load from a stylesheet?\n    const isDefault = iconName.startsWith('default:')\n    iconName = isDefault ? iconName.split(':')[1] : iconName\n\n    // check if we've already loaded the icon before\n    const iconWasAlreadyLoaded = iconName in iconRegistry\n\n    let loadedIcon: string | undefined | Promise<string | undefined> = undefined\n\n    if (iconWasAlreadyLoaded) {\n      return iconRegistry[iconName]\n    } else if (!iconRequests[iconName]) {\n      loadedIcon = getIconFromStylesheet(iconName)\n      loadedIcon =\n        isClient && typeof loadedIcon === 'undefined'\n          ? Promise.resolve(loadedIcon)\n          : loadedIcon\n      if (loadedIcon instanceof Promise) {\n        iconRequests[iconName] = loadedIcon\n          .then((iconValue) => {\n            if (!iconValue && typeof iconName === 'string' && !isDefault) {\n              return (loadedIcon =\n                typeof iconLoader === 'function'\n                  ? iconLoader(iconName)\n                  : getRemoteIcon(iconName, iconLoaderUrl))\n            }\n            return iconValue\n          })\n          .then((finalIcon) => {\n            if (typeof iconName === 'string') {\n              iconRegistry[isDefault ? `default:${iconName}` : iconName] =\n                finalIcon\n            }\n            return finalIcon\n          })\n      } else if (typeof loadedIcon === 'string') {\n        iconRegistry[isDefault ? `default:${iconName}` : iconName] = loadedIcon\n        return loadedIcon\n      }\n    }\n    return iconRequests[iconName]\n  }\n}\n\nfunction getIconFromStylesheet(\n  iconName: string\n): string | undefined | Promise<string | undefined> {\n  if (!isClient) return\n  if (themeHasLoaded) {\n    return loadStylesheetIcon(iconName)\n  } else {\n    return themeLoaded.then(() => {\n      return loadStylesheetIcon(iconName)\n    })\n  }\n}\n\nfunction loadStylesheetIcon(iconName: string) {\n  const cssVarIcon = documentStyles?.getPropertyValue(`--fk-icon-${iconName}`)\n  if (cssVarIcon) {\n    // if we have a matching icon in the CSS properties, then decode it\n    const icon: string = atob(cssVarIcon)\n    if (icon.startsWith('<svg')) {\n      iconRegistry[iconName] = icon\n      return icon\n    }\n  }\n  return undefined\n}\n\n/**\n * Attempts to fetch a remote icon from the FormKit CDN\n * @param iconName - The string name of the icon\n * @public\n */\nfunction getRemoteIcon(\n  iconName: string,\n  iconLoaderUrl?: FormKitIconLoaderUrl\n): Promise<string | undefined> | undefined {\n  const formkitVersion = FORMKIT_VERSION.startsWith('__')\n    ? 'latest'\n    : FORMKIT_VERSION\n  const fetchUrl =\n    typeof iconLoaderUrl === 'function'\n      ? iconLoaderUrl(iconName)\n      : `https://cdn.jsdelivr.net/npm/@formkit/icons@${formkitVersion}/dist/icons/${iconName}.svg`\n  if (!isClient) return undefined\n  return fetch(`${fetchUrl}`)\n    .then(async (r) => {\n      const icon = await r.text()\n      if (icon.startsWith('<svg')) {\n        return icon\n      }\n      return undefined\n    })\n    .catch((e) => {\n      console.error(e)\n      return undefined\n    })\n}\n\n/**\n * Loads icons for the matching `-icon` props on a given node\n */\nfunction loadIconPropIcons(\n  node: FormKitNode,\n  iconHandler: FormKitIconLoader\n): void {\n  const iconRegex = /^[a-zA-Z-]+(?:-icon|Icon)$/\n  const iconProps = Object.keys(node.props).filter((prop) => {\n    return iconRegex.test(prop)\n  })\n  iconProps.forEach((sectionKey) => {\n    return loadPropIcon(node, iconHandler, sectionKey)\n  })\n}\n\n/**\n * Loads an icon from an icon-prop declaration eg. suffix-icon=\"settings\"\n */\nfunction loadPropIcon(\n  node: FormKitNode,\n  iconHandler: FormKitIconLoader,\n  sectionKey: string\n): Promise<void> | void {\n  const iconName = node.props[sectionKey]\n  const loadedIcon = iconHandler(iconName)\n  const rawIconProp = `_raw${sectionKey\n    .charAt(0)\n    .toUpperCase()}${sectionKey.slice(1)}`\n  const clickHandlerProp = `on${sectionKey\n    .charAt(0)\n    .toUpperCase()}${sectionKey.slice(1)}Click`\n  node.addProps([rawIconProp, clickHandlerProp])\n  // listen for changes to the icon prop\n  node.on(`prop:${sectionKey}`, reloadIcon)\n  if (loadedIcon instanceof Promise) {\n    return loadedIcon.then((svg) => {\n      node.props[rawIconProp] = svg\n    })\n  } else {\n    node.props[rawIconProp] = loadedIcon\n  }\n  return\n}\n\n/**\n * reloads an icon when the prop value changes\n */\nfunction reloadIcon(event: FormKitEvent): void | Promise<void> {\n  const node = event.origin\n  const iconName = event.payload\n  const iconHandler = node?.props?.iconHandler\n  const sectionKey = event.name.split(':')[1]\n  const rawIconProp = `_raw${sectionKey\n    .charAt(0)\n    .toUpperCase()}${sectionKey.slice(1)}`\n\n  if (iconHandler && typeof iconHandler === 'function') {\n    const loadedIcon = iconHandler(iconName)\n\n    if (loadedIcon instanceof Promise) {\n      return loadedIcon.then((svg) => {\n        node.props[rawIconProp] = svg\n      })\n    } else {\n      node.props[rawIconProp] = loadedIcon\n    }\n  }\n}\n", "import {\n  warningHandler,\n  errorHandler,\n  FormKitHandlerPayload,\n  FormKitNode,\n  FormKitMiddleware,\n} from '@formkit/core'\n\n/**\n * Catalog of the error message codes in FormKit.\n * @public\n */\nconst errors: Record<\n  string | number,\n  string | ((error: FormKitHandlerPayload) => string)\n> = {\n  /**\n   * FormKit errors:\n   */\n  100: ({ data: node }: { data: FormKitNode }) =>\n    `Only groups, lists, and forms can have children (${node.name}).`,\n  101: ({ data: node }: { data: FormKitNode }) =>\n    `You cannot directly modify the store (${node.name}). See: https://formkit.com/advanced/core#message-store`,\n  102: ({\n    data: [node, property],\n  }: {\n    data: [node: FormKitNode, property: string]\n  }) => `You cannot directly assign node.${property} (${node.name})`,\n  103: ({ data: [operator] }) =>\n    `Schema expressions cannot start with an operator (${operator})`,\n  104: ({ data: [operator, expression] }) =>\n    `Schema expressions cannot end with an operator (${operator} in \"${expression}\")`,\n  105: ({ data: expression }) => `Invalid schema expression: ${expression}`,\n  106: ({ data: name }) => `Cannot submit because (${name}) is not in a form.`,\n  107: ({ data: [node, value] }: { data: [FormKitNode, unknown] }) =>\n    `Cannot set ${node.name} to non object value: ${value}`,\n  108: ({ data: [node, value] }: { data: [FormKitNode, unknown] }) =>\n    `Cannot set ${node.name} to non array value: ${value}`,\n  /**\n   * Input specific errors:\n   */\n  300: ({ data: [node] }: { data: [FormKitNode, unknown] }) =>\n    `Cannot set behavior prop to overscroll (on ${node.name} input) when options prop is a function.`,\n  /**\n   * FormKit vue errors:\n   */\n  600: ({ data: node }: { data: FormKitNode }) =>\n    `Unknown input type${\n      typeof node.props.type === 'string' ? ' \"' + node.props.type + '\"' : ''\n    } (\"${node.name}\")`,\n  601: ({ data: node }: { data: FormKitNode }) =>\n    `Input definition${\n      typeof node.props.type === 'string' ? ' \"' + node.props.type + '\"' : ''\n    } is missing a schema or component property (${node.name}).`,\n}\n\n/**\n * Catalog of the warning message codes in FormKit.\n * @public\n */\nconst warnings: Record<\n  string | number,\n  string | ((error: FormKitHandlerPayload) => string)\n> = {\n  /**\n   * Core warnings:\n   */\n  150: ({ data: fn }: { data: string }) =>\n    `Schema function \"${fn}()\" is not a valid function.`,\n  151: ({ data: id }: { data: string }) => `No form element with id: ${id}`,\n  152: ({ data: id }: { data: string }) => `No input element with id: ${id}`,\n  /**\n   * Input specific warnings:\n   */\n  350: ({\n    data: { node, inputType },\n  }: {\n    data: {\n      node: FormKitNode\n      inputType: string\n    }\n  }) =>\n    `Invalid options prop for ${node.name} input (${inputType}). See https://formkit.com/inputs/${inputType}`,\n  /**\n   * Vue warnings:\n   */\n  650: 'Schema \"$get()\" must use the id of an input to access.',\n  651: ({ data: id }: { data: string }) =>\n    `Cannot setErrors() on \"${id}\" because no such id exists.`,\n  652: ({ data: id }: { data: string }) =>\n    `Cannot clearErrors() on \"${id}\" because no such id exists.`,\n  /**\n   * Deprecation warnings:\n   */\n  800: ({ data: name }: { data: string }) => `${name} is deprecated.`,\n}\n\n/**\n * Decodes an error that is being emitted and console logs it.\n * @param error - The error currently being handled\n * @param next - Call additional handlers\n * @returns\n */\nconst decodeErrors: FormKitMiddleware<FormKitHandlerPayload> = (\n  error: FormKitHandlerPayload,\n  next\n) => {\n  if (error.code in errors) {\n    const err = errors[error.code]\n    error.message = typeof err === 'function' ? err(error) : err\n  }\n  return next(error)\n}\n\nlet registered = false\n\n/**\n * Register the dev handler (idempotent).\n *\n * @public\n */\nfunction register() {\n  if (!registered) {\n    errorHandler(decodeErrors)\n    warningHandler(decodeWarnings)\n    registered = true\n  }\n}\n\n/**\n * Decodes an error that is being emitted and console logs it.\n * @param error - The error currently being handled\n * @param next - Call additional handlers\n * @returns\n */\nconst decodeWarnings: FormKitMiddleware<FormKitHandlerPayload> = (\n  warning: FormKitHandlerPayload,\n  next\n) => {\n  if (warning.code in warnings) {\n    const warn = warnings[warning.code]\n    warning.message = typeof warn === 'function' ? warn(warning) : warn\n  }\n  return next(warning)\n}\n\n// Some bundlers need to see an export:\nexport { errors, warnings, register }\n", "import {\n  reactive,\n  computed,\n  ref,\n  watch,\n  markRaw,\n  triggerRef,\n  nextTick,\n  isRef,\n  isReactive,\n} from 'vue'\nimport {\n  FormKitPlugin,\n  FormKitFrameworkContext,\n  FormKitMessage,\n  createClasses,\n  createMessage,\n  generateClassList,\n  FormKitTypeDefinition,\n} from '@formkit/core'\nimport {\n  eq,\n  has,\n  camel,\n  empty,\n  undefine,\n  cloneAny,\n  shallowClone,\n} from '@formkit/utils'\nimport { createObserver } from '@formkit/observer'\nimport { FormKitPseudoProps } from '@formkit/core'\n\n/**\n * A plugin that creates Vue-specific context object on each given node.\n *\n * @param node - FormKitNode to create the context on.\n *\n * @public\n */\nconst vueBindings: FormKitPlugin = function vueBindings(node) {\n  /**\n   * Start a validity counter on all blocking messages.\n   */\n  node.ledger.count('blocking', (m) => m.blocking)\n  const isValid = ref<boolean>(!node.ledger.value('blocking'))\n  /**\n   * Start an error message counter.\n   */\n  node.ledger.count('errors', (m) => m.type === 'error')\n  const hasErrors = ref<boolean>(!!node.ledger.value('errors'))\n\n  /**\n   * Keep track of the first time a Vue tick cycle has passed.\n   */\n  let hasTicked = false\n  nextTick(() => {\n    hasTicked = true\n  })\n\n  /**\n   * All messages with the visibility state set to true.\n   */\n  const availableMessages = reactive<Record<string, FormKitMessage>>(\n    node.store.reduce((store, message) => {\n      if (message.visible) {\n        store[message.key] = message\n      }\n      return store\n    }, {} as Record<string, FormKitMessage>)\n  )\n  /**\n   * A flag that determines when validation messages should be displayed.\n   */\n  const validationVisibility = ref<string>(\n    node.props.validationVisibility ||\n      (node.props.type === 'checkbox' ? 'dirty' : 'blur')\n  )\n  node.on('prop:validationVisibility', ({ payload }) => {\n    validationVisibility.value = payload\n  })\n\n  /**\n   * Keep track of if this input has ever shown validation errors.\n   */\n  const hasShownErrors = ref(validationVisibility.value === 'live')\n\n  /**\n   * If the input is required or not, this is the only validation rule that\n   * needs to be explicitly called out since it powers the aria-required attr.\n   */\n  const isRequired = ref<boolean>(false)\n  const checkForRequired = (parsedRules?: Array<{ name: string }>) => {\n    isRequired.value = (parsedRules ?? []).some(\n      (rule) => rule.name === 'required'\n    )\n  }\n  checkForRequired(node.props.parsedRules)\n  node.on('prop:parsedRules', ({ payload }) => checkForRequired(payload))\n\n  /**\n   * An array of unique identifiers that should only be used for iterating\n   * inside a synced list.\n   */\n  const items = ref(node.children.map((child) => child.uid))\n\n  /**\n   * The current visibility state of validation messages.\n   */\n  const validationVisible = computed<boolean>(() => {\n    if (!context.state) return false\n    if (context.state.submitted) return true\n    if (!hasShownErrors.value && !context.state.settled) {\n      return false\n    }\n    switch (validationVisibility.value) {\n      case 'live':\n        return true\n      case 'blur':\n        return context.state.blurred\n      case 'dirty':\n        return context.state.dirty\n      default:\n        return false\n    }\n  })\n\n  /**\n   * Determines if the input should be considered \"invalid\" — note that this is different than a valid input! A\n   * valid input is one where the input is not loading, not pending validation, not unsettled, and passes all\n   * validation rules. An invalid input is one whose validation rules are not explicitly not passing, and those rules\n   * are visible to the user.\n   */\n  const isInvalid = computed<boolean>(() => {\n    return context.state.failing && validationVisible.value\n  })\n\n  /**\n   * Determines if the input should be considered \"complete\".\n   */\n  const isComplete = computed<boolean>(() => {\n    return context && hasValidation.value\n      ? isValid.value && !hasErrors.value\n      : context.state.dirty && !empty(context.value)\n  })\n\n  /**\n   * If the input has validation rules or not.\n   */\n  const hasValidation = ref<boolean>(\n    Array.isArray(node.props.parsedRules) && node.props.parsedRules.length > 0\n  )\n  node.on('prop:parsedRules', ({ payload: rules }) => {\n    hasValidation.value = Array.isArray(rules) && rules.length > 0\n  })\n\n  /**\n   * All messages that are currently on display to an end user. This changes\n   * based on the current message type visibility, like errorVisibility.\n   */\n  const messages = computed<Record<string, FormKitMessage>>(() => {\n    const visibleMessages: Record<string, FormKitMessage> = {}\n    for (const key in availableMessages) {\n      const message = availableMessages[key]\n      if (message.type !== 'validation' || validationVisible.value) {\n        visibleMessages[key] = message\n      }\n    }\n    return visibleMessages\n  })\n\n  /**\n   * UI Messages.\n   */\n  const ui = reactive(\n    node.store.reduce((messages, message) => {\n      if (message.type === 'ui' && message.visible)\n        messages[message.key] = message\n      return messages\n    }, {} as Record<string, FormKitMessage>)\n  )\n\n  const passing = computed<boolean>(() => !context.state.failing)\n\n  /**\n   * This is the reactive data object that is provided to all schemas and\n   * forms. It is a subset of data in the core node object.\n   */\n  const cachedClasses = reactive<Record<string, string>>({})\n  const classes = new Proxy(cachedClasses as Record<PropertyKey, string>, {\n    get(...args) {\n      if (!node) return ''\n      const [target, property] = args\n      let className: string | null = Reflect.get(...args)\n      if (!className && typeof property === 'string') {\n        if (!has(target, property) && !property.startsWith('__v')) {\n          const observedNode = createObserver(node)\n          observedNode.watch((node) => {\n            const rootClasses =\n              typeof node.config.rootClasses === 'function'\n                ? node.config.rootClasses(property, node)\n                : {}\n            const globalConfigClasses = node.config.classes\n              ? createClasses(property, node, node.config.classes[property])\n              : {}\n            const classesPropClasses = createClasses(\n              property,\n              node,\n              node.props[`_${property}Class`]\n            )\n            const sectionPropClasses = createClasses(\n              property,\n              node,\n              node.props[`${property}Class`]\n            )\n            className = generateClassList(\n              node,\n              property,\n              rootClasses,\n              globalConfigClasses,\n              classesPropClasses,\n              sectionPropClasses\n            )\n            target[property] = className ?? ''\n          })\n        }\n      }\n      return className\n    },\n  })\n\n  node.on('prop:rootClasses', () => {\n    const keys = Object.keys(cachedClasses)\n    for (const key of keys) {\n      delete cachedClasses[key]\n    }\n  })\n\n  const describedBy = computed<string | undefined>(() => {\n    if (!node) return undefined\n    const describers = []\n    if (context.help) {\n      describers.push(`help-${node.props.id}`)\n    }\n    for (const key in messages.value) {\n      describers.push(`${node.props.id}-${key}`)\n    }\n    return describers.length ? describers.join(' ') : undefined\n  })\n\n  const value = ref(node.value)\n  const _value = ref(node.value)\n\n  const context: FormKitFrameworkContext = reactive({\n    _value,\n    attrs: node.props.attrs,\n    disabled: node.props.disabled,\n    describedBy,\n    fns: {\n      length: (obj: Record<PropertyKey, any>) => Object.keys(obj).length,\n      number: (value: any) => Number(value),\n      string: (value: any) => String(value),\n      json: (value: any) => JSON.stringify(value),\n      eq,\n    },\n    handlers: {\n      blur: (e?: Event) => {\n        if (!node) return\n        node.store.set(\n          /* #__PURE__ */ createMessage({ key: 'blurred', visible: false, value: true })\n        )\n        if (typeof node.props.attrs.onBlur === 'function') {\n          node.props.attrs.onBlur(e)\n        }\n      },\n      touch: () => {\n        const doCompare = context.dirtyBehavior === 'compare'\n        if (node.store.dirty?.value && !doCompare) return\n        const isDirty = !eq(node.props._init, node._value)\n        if (!isDirty && !doCompare) return\n        node.store.set(\n          /* #__PURE__ */ createMessage({ key: 'dirty', visible: false, value: isDirty })\n        )\n      },\n      DOMInput: (e: Event) => {\n        node.input((e.target as HTMLInputElement).value)\n        node.emit('dom-input-event', e)\n      },\n    },\n    help: node.props.help,\n    id: node.props.id as string,\n    items,\n    label: node.props.label,\n    messages,\n    didMount: false,\n    node: markRaw(node),\n    options: node.props.options,\n    defaultMessagePlacement: true,\n    slots: node.props.__slots,\n    state: {\n      blurred: false,\n      complete: isComplete,\n      dirty: false,\n      empty: empty(value),\n      submitted: false,\n      settled: node.isSettled,\n      valid: isValid,\n      invalid: isInvalid,\n      errors: hasErrors,\n      rules: hasValidation,\n      validationVisible,\n      required: isRequired,\n      failing: false,\n      passing,\n    },\n    type: node.props.type,\n    family: node.props.family,\n    ui,\n    value,\n    classes,\n  })\n\n  /**\n   * Ensure the context object is properly configured after booting up.\n   */\n  node.on('created', () => {\n    if (!eq(context.value, node.value)) {\n      _value.value = node.value\n      value.value = node.value\n      triggerRef(value)\n      triggerRef(_value)\n    }\n    ;(async () => {\n      await node.settled\n      if (node) node.props._init = cloneAny(node.value)\n    })()\n  })\n\n  /**\n   * When the node mounts, set the didMount flag.\n   */\n  node.on('mounted', () => {\n    context.didMount = true\n  })\n\n  /**\n   * Sets the settled state.\n   */\n  node.on('settled', ({ payload: isSettled }) => {\n    context.state.settled = isSettled\n  })\n\n  /**\n   * Observes node.props properties explicitly and updates them in the context\n   * object.\n   * @param observe - Props to observe and register as context data.\n   */\n  function observeProps(observe: FormKitPseudoProps) {\n    const propNames = Array.isArray(observe) ? observe : Object.keys(observe)\n    propNames.forEach((prop) => {\n      prop = camel(prop)\n      if (!has(context, prop)) {\n        context[prop] = node.props[prop]\n      }\n      node.on(`prop:${prop}`, ({ payload }) => {\n        context[prop as keyof FormKitFrameworkContext] = payload\n      })\n    })\n  }\n\n  /**\n   * We use a node observer to individually observe node props.\n   */\n  const rootProps = () => {\n    const props = [\n      '__root',\n      'help',\n      'label',\n      'disabled',\n      'options',\n      'type',\n      'attrs',\n      'preserve',\n      'preserveErrors',\n      'id',\n      'dirtyBehavior',\n    ]\n    const iconPattern = /^[a-zA-Z-]+(?:-icon|Icon)$/\n    const matchingProps = Object.keys(node.props).filter((prop) => {\n      return iconPattern.test(prop)\n    })\n    return props.concat(matchingProps)\n  }\n  observeProps(rootProps())\n\n  /**\n   * Once the input is defined, deal with it.\n   * @param definition - Type definition.\n   */\n  function definedAs<V = unknown>(definition: FormKitTypeDefinition<V>) {\n    if (definition.props) observeProps(definition.props)\n  }\n\n  node.props.definition && definedAs(node.props.definition)\n\n  /**\n   * When new props are added to the core node as \"props\" (ie not attrs) then\n   * we automatically need to start tracking them here.\n   */\n  node.on('added-props', ({ payload }) => observeProps(payload))\n\n  /**\n   * Watch for input events from core.\n   */\n  node.on('input', ({ payload }) => {\n    if (node.type !== 'input' && !isRef(payload) && !isReactive(payload)) {\n      _value.value = shallowClone(payload)\n    } else {\n      _value.value = payload\n      triggerRef(_value)\n    }\n  })\n\n  /**\n   * Model updates from core. This is the raw value and should emitted as a\n   * model update even if the value did not update internally. Why? Because\n   * the model that created this event may have not be the same value as our\n   * internal value.\n   *\n   * See test: \"emits a modelUpdated event even when the value results in the\n   * same value\"\n   */\n  node.on('commitRaw', ({ payload }) => {\n    if (node.type !== 'input' && !isRef(payload) && !isReactive(payload)) {\n      value.value = _value.value = shallowClone(payload)\n    } else {\n      value.value = _value.value = payload\n      triggerRef(value)\n    }\n    node.emit('modelUpdated')\n  })\n\n  /**\n   * Watch for input commits from core.\n   */\n  node.on('commit', ({ payload }) => {\n    // The input is dirty after a value has been input by a user\n    if (\n      (!context.state.dirty || context.dirtyBehavior === 'compare') &&\n      node.isCreated &&\n      hasTicked\n    ) {\n      if (!node.store.validating?.value) {\n        context.handlers.touch()\n      } else {\n        const receipt = node.on('message-removed', ({ payload: message }) => {\n          if (message.key === 'validating') {\n            context.handlers.touch()\n            node.off(receipt)\n          }\n        })\n      }\n    }\n    if (\n      isComplete &&\n      node.type === 'input' &&\n      hasErrors.value &&\n      !undefine(node.props.preserveErrors)\n    ) {\n      node.store.filter(\n        (message) =>\n          !(message.type === 'error' && message.meta?.autoClear === true)\n      )\n    }\n    if (node.type === 'list' && node.sync) {\n      items.value = node.children.map((child) => child.uid)\n    }\n    context.state.empty = empty(payload)\n  })\n\n  /**\n   * Update the local state in response to messages.\n   * @param message - A formkit message\n   */\n  const updateState = async (message: FormKitMessage) => {\n    if (\n      message.type === 'ui' &&\n      message.visible &&\n      !message.meta.showAsMessage\n    ) {\n      ui[message.key] = message\n    } else if (message.visible) {\n      availableMessages[message.key] = message\n    } else if (message.type === 'state') {\n      context.state[message.key] = !!message.value\n    }\n  }\n\n  /**\n   * Listen to message events and modify the local message data values.\n   */\n  node.on('message-added', (e) => updateState(e.payload))\n  node.on('message-updated', (e) => updateState(e.payload))\n  node.on('message-removed', ({ payload: message }) => {\n    delete ui[message.key]\n    delete availableMessages[message.key]\n    delete context.state[message.key]\n  })\n  node.on('settled:blocking', () => {\n    isValid.value = true\n  })\n  node.on('unsettled:blocking', () => {\n    isValid.value = false\n  })\n  node.on('settled:errors', () => {\n    hasErrors.value = false\n  })\n  node.on('unsettled:errors', () => {\n    hasErrors.value = true\n  })\n\n  /**\n   * Watch the validation visible prop and set the hasShownErrors state.\n   */\n  watch(validationVisible, (value) => {\n    if (value) {\n      hasShownErrors.value = true\n    }\n  })\n\n  node.context = context\n\n  // The context is complete\n  node.emit('context', node, false)\n\n  node.on('destroyed', () => {\n    node.context = undefined\n    /* @ts-ignore */ // eslint-disable-line\n    node = null\n  })\n}\n\nexport default vueBindings\n", "import { FormKitOptions, FormKitLibrary } from '@formkit/core'\nimport { extend } from '@formkit/utils'\nimport * as defaultRules from '@formkit/rules'\nimport {\n  createValidationPlugin,\n  FormKitValidationRule,\n} from '@formkit/validation'\nimport {\n  createI18nPlugin,\n  FormKitLocale,\n  FormKitLocaleRegistry,\n  en,\n} from '@formkit/i18n'\nimport { createLibraryPlugin, inputs as defaultInputs } from '@formkit/inputs'\nimport {\n  createThemePlugin,\n  FormKitIconLoader,\n  FormKitIconLoaderUrl,\n} from '@formkit/themes'\nimport bindings from './bindings'\nimport { register as decodeErrors } from '@formkit/dev'\n\n/**\n * Configuration for plugins\n *\n * @public\n */\nexport interface PluginConfigs {\n  rules: Record<string, FormKitValidationRule>\n  locales: FormKitLocaleRegistry\n  inputs: FormKitLibrary\n  messages: Record<string, Partial<FormKitLocale>>\n  locale: string\n  theme: string\n  iconLoaderUrl: FormKitIconLoaderUrl\n  iconLoader: FormKitIconLoader\n  icons: Record<string, string | undefined>\n}\n\n/**\n * The allowed options for defaultConfig.\n *\n * @public\n */\nexport type DefaultConfigOptions = FormKitOptions &\n  Partial<PluginConfigs> &\n  Record<string, unknown>\n\n/**\n * Default configuration options. Includes all validation rules,\n * en i18n messages.\n *\n * @public\n */\nexport const defaultConfig = (\n  options: DefaultConfigOptions = {}\n): FormKitOptions => {\n  decodeErrors()\n  const {\n    rules = {},\n    locales = {},\n    inputs = {},\n    messages = {},\n    locale = undefined,\n    theme = undefined,\n    iconLoaderUrl = undefined,\n    iconLoader = undefined,\n    icons = {},\n    ...nodeOptions\n  } = options\n  /**\n   * The default configuration includes the validation plugin,\n   * with all core-available validation rules.\n   */\n  const validation = createValidationPlugin({\n    ...defaultRules,\n    ...(rules || {}),\n  })\n\n  /**\n   * Includes the i18n plugin with only the english language\n   * messages.\n   */\n  const i18n = createI18nPlugin(\n    extend({ en, ...(locales || {}) }, messages) as FormKitLocaleRegistry\n  )\n\n  /**\n   * Create the library of inputs that are generally available. This default\n   * config imports all \"native\" inputs by default, but\n   */\n  const library = createLibraryPlugin(defaultInputs, inputs)\n\n  /**\n   * Create the theme plugin for the user provided theme\n   */\n  const themePlugin = createThemePlugin(theme, icons, iconLoaderUrl, iconLoader)\n\n  return extend(\n    {\n      plugins: [library, themePlugin, bindings, i18n, validation],\n      ...(!locale ? {} : { config: { locale } }),\n    },\n    nodeOptions || {},\n    true\n  ) as FormKitOptions\n}\n", "import { error, FormKitNode, FormKitSchemaDefinition } from '@formkit/core'\nimport {\n  h,\n  ref,\n  defineComponent,\n  InjectionKey,\n  ConcreteComponent,\n  VNode,\n  RendererNode,\n  RendererElement,\n  SetupContext,\n  RenderFunction,\n  VNodeProps,\n  AllowedComponentProps,\n  ComponentCustomProps,\n  markRaw,\n} from 'vue'\nimport { useInput } from './composables/useInput'\nimport { FormKitSchema } from './FormKitSchema'\nimport {\n  FormKitInputs,\n  FormKitInputSlots,\n  FormKitEvents,\n  InputType,\n  runtimeProps,\n} from '@formkit/inputs'\nimport { getCurrentInstance } from 'vue'\n\n/**\n * The type definition for the FormKit’s slots, this is not intended to be used\n * directly.\n * @public\n */\nexport type Slots<Props extends FormKitInputs<Props>> =\n  InputType<Props> extends keyof FormKitInputSlots<Props>\n    ? FormKitInputSlots<Props>[InputType<Props>]\n    : {}\n\n/**\n * The TypeScript definition for the FormKit component.\n * @public\n */\nexport type FormKitComponent = <Props extends FormKitInputs<Props>>(\n  props: Props & VNodeProps & AllowedComponentProps & ComponentCustomProps,\n  context?: Pick<FormKitSetupContext<Props>, 'attrs' | 'emit' | 'slots'>,\n  setup?: FormKitSetupContext<Props>\n) => VNode<\n  RendererNode,\n  RendererElement,\n  {\n    [key: string]: any\n  }\n> & { __ctx?: FormKitSetupContext<Props> }\n\n/**\n * Type definition for the FormKit component Vue context.\n * @public\n */\nexport interface FormKitSetupContext<Props extends FormKitInputs<Props>> {\n  props: {} & Props\n  expose(exposed: {}): void\n  attrs: any\n  slots: Slots<Props>\n  emit: FormKitEvents<Props>\n}\n\n/**\n * Flag to determine if we are running on the server.\n */\nconst isServer = typeof window === 'undefined'\n\n/**\n * The symbol that represents the formkit parent injection value.\n *\n * @public\n */\nexport const parentSymbol: InjectionKey<FormKitNode> = Symbol('FormKitParent')\n\n/**\n * The symbol that represents the formkit component callback injection value.\n * This is used by tooling to know which component \"owns\" this node — some\n * effects are linked to that component, for example, hot module reloading.\n *\n * @internal\n */\nexport const componentSymbol: InjectionKey<(node: FormKitNode) => void> =\n  Symbol('FormKitComponentCallback')\n\n/**\n * This variable is set to the node that is currently having its schema created.\n *\n * @internal\n */\nlet currentSchemaNode: FormKitNode | null = null\n\n/**\n * Returns the node that is currently having its schema created.\n *\n * @public\n */\nexport const getCurrentSchemaNode = () => currentSchemaNode\n/**\n * The actual runtime setup function for the FormKit component.\n *\n * @param props - The props passed to the component.\n * @param context - The context passed to the component.\n */\nfunction FormKit<Props extends FormKitInputs<Props>>(\n  props: Props,\n  context: SetupContext<{}, {}>\n): RenderFunction {\n  const node = useInput<Props, any>(props, context)\n  if (!node.props.definition) error(600, node)\n  if (node.props.definition.component) {\n    return () =>\n      h(\n        node.props.definition?.component as any,\n        {\n          context: node.context,\n        },\n        { ...context.slots }\n      )\n  }\n  if (true && import.meta.hot) {\n    const instance = getCurrentInstance()\n    let initPreserve: boolean | undefined\n    import.meta.hot?.on('vite:beforeUpdate', () => {\n      initPreserve = node.props.preserve\n      node.props.preserve = true\n    })\n    import.meta.hot?.on('vite:afterUpdate', () => {\n      instance?.proxy?.$forceUpdate()\n      node.props.preserve = initPreserve\n    })\n  }\n  const schema = ref<FormKitSchemaDefinition>([])\n  let memoKey: string | undefined = node.props.definition.schemaMemoKey\n  const generateSchema = () => {\n    const schemaDefinition = node.props?.definition?.schema\n    if (!schemaDefinition) error(601, node)\n    if (typeof schemaDefinition === 'function') {\n      currentSchemaNode = node\n      schema.value = schemaDefinition({ ...(props.sectionsSchema || {}) })\n      currentSchemaNode = null\n      if (\n        (memoKey && props.sectionsSchema) ||\n        ('memoKey' in schemaDefinition &&\n          typeof schemaDefinition.memoKey === 'string')\n      ) {\n        memoKey =\n          (memoKey ?? schemaDefinition?.memoKey) +\n          JSON.stringify(props.sectionsSchema)\n      }\n    } else {\n      schema.value = schemaDefinition\n    }\n  }\n  generateSchema()\n\n  // If someone emits the schema event, we re-generate the schema\n  if (!isServer) {\n    node.on('schema', () => {\n      memoKey += '♻️'\n      generateSchema()\n    })\n  }\n\n  context.emit('node', node)\n  const definitionLibrary = node.props.definition.library as\n    | Record<string, ConcreteComponent>\n    | undefined\n\n  const library = {\n    FormKit: markRaw(formkitComponent),\n    ...definitionLibrary,\n    ...(props.library ?? {}),\n  }\n\n  /**\n   * Emit the mounted event.\n   */\n  function didMount() {\n    node.emit('mounted')\n  }\n\n  // // Expose the FormKitNode to template refs.\n  context.expose({ node })\n  return () =>\n    h(\n      FormKitSchema,\n      {\n        schema: schema.value,\n        data: node.context,\n        onMounted: didMount,\n        library,\n        memoKey,\n      },\n      { ...context.slots }\n    )\n}\n\n/**\n * The root FormKit component. Use it to craft all inputs and structure of your\n * forms. For example:\n *\n * ```vue\n * <FormKit\n *  type=\"text\"\n *  label=\"Name\"\n *  help=\"Please enter your name\"\n *  validation=\"required|length:2\"\n * />\n * ```\n *\n * @public\n */\nexport const formkitComponent = /* #__PURE__ */ defineComponent(\n  FormKit as any,\n  {\n    props: runtimeProps as any,\n    inheritAttrs: false,\n  }\n) as unknown as FormKitComponent\n\n// ☝️ We need to cheat here a little bit since our runtime props and our\n// public prop interface are different (we treat some attrs as props to allow\n// for runtime \"prop\" creation).\n\nexport default formkitComponent\n", "import {\n  Component,\n  PropType,\n  RendererElement,\n  RendererNode,\n  VNode,\n  createTextVNode,\n  defineComponent,\n  h,\n  ref,\n  isRef,\n  reactive,\n  resolveComponent,\n  watchEffect,\n  watch,\n  Ref,\n  getCurrentInstance,\n  ConcreteComponent,\n  onUnmounted,\n  markRaw,\n  onMounted,\n} from 'vue'\nimport { has, isPojo } from '@formkit/utils'\nimport {\n  FormKitSchemaAttributes,\n  FormKitSchemaNode,\n  isDOM,\n  isConditional,\n  isComponent,\n  compile,\n  FormKitSchemaCondition,\n  FormKitSchemaAttributesCondition,\n  FormKitAttributeValue,\n  FormKitCompilerOutput,\n  FormKitSchemaDefinition,\n  getNode,\n  warn,\n  watchRegistry,\n  isNode,\n  sugar,\n} from '@formkit/core'\nimport { onSSRComplete } from './composables/onSSRComplete'\nimport FormKit from './FormKit'\n\n/**\n * A simple flag to tell if we are running on the server or not.\n */\nconst isServer = typeof window === 'undefined'\n\n/**\n * A library of components available to the schema (in addition to globally\n * registered ones)\n *\n * @public\n */\nexport interface FormKitComponentLibrary {\n  [index: string]: Component\n}\n\n/**\n * Defines the structure a parsed node.\n */\ntype RenderContent = [\n  condition: false | (() => boolean | number | string),\n  element: string | Component | null,\n  attrs: () => FormKitSchemaAttributes,\n  children: RenderChildren | null,\n  alternate: RenderChildren | null,\n  iterator:\n    | null\n    | [\n        getNodeValues: () =>\n          | number\n          | string\n          | boolean\n          | any[]\n          | Record<string, any>,\n        valueName: string,\n        keyName: string | null\n      ],\n  resolve: boolean\n]\n/**\n * The actual signature of a VNode in Vue.\n *\n * @public\n */\nexport type VirtualNode = VNode<\n  RendererNode,\n  RendererElement,\n  { [key: string]: any }\n>\n/**\n * The types of values that can be rendered by Vue.\n *\n * @public\n */\nexport type Renderable = null | string | number | boolean | VirtualNode\n/**\n * A list of renderable items.\n *\n * @public\n */\nexport type RenderableList =\n  | Renderable\n  | Renderable[]\n  | (Renderable | Renderable[])[]\n\n/**\n * An object of slots\n *\n * @public\n */\nexport type RenderableSlots = Record<string, RenderableSlot>\n\n/**\n * A slot function that can be rendered.\n *\n * @public\n */\nexport type RenderableSlot = (\n  data?: Record<string, any>,\n  key?: object\n) => RenderableList\n/**\n * Describes renderable children.\n */\ninterface RenderChildren {\n  (iterationData?: Record<string, unknown>): RenderableList | RenderableSlots\n  slot?: boolean\n}\n\n/**\n * The format children elements can be in.\n */\ninterface RenderNodes {\n  (iterationData?: Record<string, unknown>): Renderable | Renderable[]\n}\n\ninterface SchemaProvider {\n  (\n    providerCallback: SchemaProviderCallback,\n    instanceKey: object\n  ): RenderChildren\n}\n\ntype SchemaProviderCallback = (\n  requirements: string[],\n  hints?: Record<string, boolean>\n) => Record<string, () => any>\n\ntype ProviderRegistry = ((\n  providerCallback: SchemaProviderCallback,\n  key: object\n) => void)[]\n\n/**\n * A registry of memoized schemas (in JSON) to their respective render function\n * and provider registry.\n */\nconst memo: Record<string, [RenderChildren, ProviderRegistry]> = {}\n\n/**\n * A map of memoized keys to how many instances of that memo are currently in\n * use.\n */\nconst memoKeys: Record<string, number> = {}\n\n/**\n * This object represents the current component instance during render. It is\n * critical for linking the current instance to the data required for render.\n */\nlet instanceKey: object\n\n/**\n * A registry of scoped data produced during runtime that is keyed by the\n * instance object. For example data from: for-loop instances and slot data.\n */\n// NOTE: This is a hack to get around the fact that the TS compiler doesn't\n// understand WeakMap's allowing us to use a object as a keys, see:\n// https://github.com/microsoft/TypeScript/issues/52534\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nconst instanceScopes = new WeakMap<object, Record<string, any>[]>()\n\n/**\n * Indicates the a section of the schema is raw.\n */\nconst raw = '__raw__'\n\n/**\n * Is a class prop.\n */\nconst isClassProp = /[a-zA-Z0-9\\-][cC]lass$/\n\n/**\n * Returns a reference as a placeholder to a specific location on an object.\n * @param data - A reactive data object\n * @param token - A dot-syntax string representing the object path\n * @returns\n */\nfunction getRef(\n  token: string,\n  data: Record<string, any> | Ref<Record<string, any>>\n): Ref<unknown> {\n  const value = ref<any>(null)\n  if (token === 'get') {\n    const nodeRefs: Record<string, Ref<unknown>> = {}\n    value.value = get.bind(null, nodeRefs)\n    return value\n  }\n  const path = token.split('.')\n  watchEffect(() => {\n    value.value = getValue(\n      isRef<Record<string, any>>(data) ? data.value : data,\n      path\n    )\n  })\n  return value\n}\n\n/**\n * Returns a value inside a set of data objects.\n * @param sets - An array of objects to search through\n * @param path - A array of string paths easily produced by split()\n * @returns\n */\nfunction getValue(\n  set: (false | Record<string, any>)[] | Record<string, any>,\n  path: string[]\n): any {\n  if (Array.isArray(set)) {\n    for (const subset of set) {\n      const value = subset !== false && getValue(subset, path)\n      if (value !== undefined) return value\n    }\n    return undefined\n  }\n  let foundValue: any = undefined\n\n  let obj: unknown = set\n  for (const i in path) {\n    const key = path[i]\n    if (typeof obj !== 'object' || obj === null) {\n      foundValue = undefined\n      break\n    }\n    const currentValue: unknown = (obj as Record<string, any>)[key]\n    if (Number(i) === path.length - 1 && currentValue !== undefined) {\n      // When the value is a function, we need to bind the `this` value\n      // before providing this back to the compiler.\n      foundValue =\n        typeof currentValue === 'function'\n          ? currentValue.bind(obj)\n          : currentValue\n      break\n    }\n    obj = currentValue\n  }\n  return foundValue\n}\n\n/**\n * Get the node from the global registry\n * @param id - A dot-syntax string where the node is located.\n */\nfunction get(nodeRefs: Record<string, Ref<unknown>>, id?: string) {\n  if (typeof id !== 'string') return warn(650)\n  if (!(id in nodeRefs)) nodeRefs[id] = ref<unknown>(undefined)\n  if (nodeRefs[id].value === undefined) {\n    nodeRefs[id].value = null\n    const root = getNode(id)\n    if (root) nodeRefs[id].value = root.context\n    watchRegistry(id, ({ payload: node }) => {\n      nodeRefs[id].value = isNode(node) ? node.context : node\n    })\n  }\n  return nodeRefs[id].value\n}\n\n/**\n *\n * @param library - A library of concrete components to use\n * @param schema -\n * @returns\n */\nfunction parseSchema(\n  library: FormKitComponentLibrary,\n  schema: FormKitSchemaNode | FormKitSchemaNode[],\n  memoKey?: string\n): SchemaProvider {\n  /**\n   * Given an if/then/else schema node, pre-compile the node and return the\n   * artifacts for the render function.\n   * @param data - The schema context object\n   * @param library - The available components\n   * @param node - The node to parse\n   */\n  function parseCondition(\n    library: FormKitComponentLibrary,\n    node: FormKitSchemaCondition\n  ): [RenderContent[0], RenderContent[3], RenderContent[4]] {\n    const condition = provider(compile(node.if), { if: true })\n    const children = createElements(library, node.then)\n    const alternate = node.else ? createElements(library, node.else) : null\n    return [condition, children, alternate]\n  }\n\n  /**\n   * Parses a conditional if/then/else attribute statement.\n   * @param data - The data object\n   * @param attr - The attribute\n   * @param _default - The default value\n   * @returns\n   */\n  function parseConditionAttr(\n    attr: FormKitSchemaAttributesCondition,\n    _default: FormKitAttributeValue\n  ): () => FormKitAttributeValue | FormKitSchemaAttributes {\n    const condition = provider(compile(attr.if))\n    let b: () => FormKitAttributeValue = () => _default\n    let a: () => FormKitAttributeValue = () => _default\n\n    if (typeof attr.then === 'object') {\n      a = parseAttrs(attr.then, undefined)\n    } else if (typeof attr.then === 'string' && attr.then?.startsWith('$')) {\n      a = provider(compile(attr.then))\n    } else {\n      a = () => attr.then\n    }\n\n    if (has(attr, 'else')) {\n      if (typeof attr.else === 'object') {\n        b = parseAttrs(attr.else)\n      } else if (typeof attr.else === 'string' && attr.else?.startsWith('$')) {\n        b = provider(compile(attr.else))\n      } else {\n        b = () => attr.else\n      }\n    }\n    return () => (condition() ? a() : b())\n  }\n\n  /**\n   * Parse attributes for dynamic content.\n   * @param attrs - Object of attributes\n   * @returns\n   */\n  function parseAttrs(\n    unparsedAttrs?: FormKitSchemaAttributes | FormKitSchemaAttributesCondition,\n    bindExp?: string,\n    _default = {}\n  ): () => FormKitSchemaAttributes {\n    const explicitAttrs = new Set(Object.keys(unparsedAttrs || {}))\n    const boundAttrs = bindExp ? provider(compile(bindExp)) : () => ({})\n    const staticAttrs: FormKitSchemaAttributes = {}\n    const setters: Array<(obj: Record<string, any>) => void> = [\n      (attrs) => {\n        const bound: Record<string, any> = boundAttrs()\n        for (const attr in bound) {\n          if (!explicitAttrs.has(attr)) {\n            attrs[attr] = bound[attr]\n          }\n        }\n      },\n    ]\n    if (unparsedAttrs) {\n      if (isConditional(unparsedAttrs)) {\n        // This is a root conditional object that must produce an object of\n        // attributes.\n        const condition = parseConditionAttr(\n          unparsedAttrs,\n          _default\n        ) as () => FormKitSchemaAttributes\n        return condition\n      }\n      // Some attributes are explicitly bound, we need to parse those ones\n      // using the compiler and create a dynamic \"setter\".\n      for (let attr in unparsedAttrs) {\n        const value = unparsedAttrs[attr]\n        let getValue: () => any\n        const isStr = typeof value === 'string'\n\n        if (attr.startsWith(raw)) {\n          // attributes prefixed with __raw__ should not be parsed\n          attr = attr.substring(7)\n          getValue = () => value\n        } else if (\n          isStr &&\n          value.startsWith('$') &&\n          value.length > 1 &&\n          !(value.startsWith('$reset') && isClassProp.test(attr))\n        ) {\n          // Most attribute values starting with $ should be compiled\n          // -class attributes starting with `$reset` should not be compiled\n          getValue = provider(compile(value))\n        } else if (typeof value === 'object' && isConditional(value)) {\n          // Conditional attrs require further processing\n          getValue = parseConditionAttr(value, undefined)\n        } else if (typeof value === 'object' && isPojo(value)) {\n          // Sub-parse pojos\n          getValue = parseAttrs(value)\n        } else {\n          // In all other cases, the value is static\n          getValue = () => value\n          staticAttrs[attr] = value\n        }\n        setters.push((attrs) => {\n          attrs[attr] = getValue()\n        })\n      }\n    }\n    return () => {\n      const attrs = Array.isArray(unparsedAttrs) ? [] : {}\n      setters.forEach((setter) => setter(attrs))\n      return attrs\n    }\n  }\n\n  /**\n   * Given a single schema node, parse it and extract the value.\n   * @param data - A state object provided to each node\n   * @param node - The schema node being parsed\n   * @returns\n   */\n  function parseNode(\n    library: FormKitComponentLibrary,\n    _node: FormKitSchemaNode\n  ): RenderContent {\n    let element: RenderContent[1] = null\n    let attrs: () => FormKitSchemaAttributes = () => null\n    let condition: false | (() => boolean | number | string) = false\n    let children: RenderContent[3] = null\n    let alternate: RenderContent[4] = null\n    let iterator: RenderContent[5] = null\n    let resolve = false\n    const node = sugar(_node)\n    if (isDOM(node)) {\n      // This is an actual HTML DOM element\n      element = node.$el\n      attrs =\n        node.$el !== 'text' ? parseAttrs(node.attrs, node.bind) : () => null\n    } else if (isComponent(node)) {\n      // This is a Vue Component\n      if (typeof node.$cmp === 'string') {\n        if (has(library, node.$cmp)) {\n          element = library[node.$cmp]\n        } else {\n          element = node.$cmp\n          resolve = true\n        }\n      } else {\n        // in this case it must be an actual component\n        element = node.$cmp\n      }\n      attrs = parseAttrs(node.props, node.bind)\n    } else if (isConditional(node)) {\n      // This is an if/then schema statement\n      ;[condition, children, alternate] = parseCondition(library, node)\n    }\n\n    // This is the same as a \"v-if\" statement — not an if/else statement\n    if (!isConditional(node) && 'if' in node) {\n      condition = provider(compile(node.if as string))\n    } else if (!isConditional(node) && element === null) {\n      // In this odd case our element is actually a partial and\n      // we only want to render the children.\n      condition = () => true\n    }\n\n    // Compile children down to a function\n    if ('children' in node && node.children) {\n      if (typeof node.children === 'string') {\n        // We are dealing with a raw string value\n        if (node.children.startsWith('$slots.')) {\n          // this is a lone text node, turn it into a slot\n          element = element === 'text' ? 'slot' : element\n          children = provider(compile(node.children))\n        } else if (node.children.startsWith('$') && node.children.length > 1) {\n          const value = provider(compile(node.children))\n          children = () => String(value())\n        } else {\n          children = () => String(node.children)\n        }\n      } else if (Array.isArray(node.children)) {\n        // We are dealing with node sub-children\n        children = createElements(library, node.children)\n      } else {\n        // This is a conditional if/else clause\n        const [childCondition, c, a] = parseCondition(library, node.children)\n        children = (iterationData?: Record<string, unknown>) =>\n          childCondition && childCondition()\n            ? c && c(iterationData)\n            : a && a(iterationData)\n      }\n    }\n\n    if (isComponent(node)) {\n      if (children) {\n        // Children of components need to be provided as an object of slots\n        // so we provide an object with the default slot provided as children.\n        // We also create a new scope for this default slot, and then on each\n        // render pass the scoped slot props to the scope.\n        const produceChildren = children\n        children = (iterationData?: Record<string, unknown>) => {\n          return {\n            default(\n              slotData?: Record<string, any>,\n              key?: object\n            ): RenderableList {\n              // We need to switch the current instance key back to the one that\n              // originally called this component's render function.\n              const currentKey = instanceKey\n              if (key) instanceKey = key\n              if (slotData) instanceScopes.get(instanceKey)?.unshift(slotData)\n              if (iterationData)\n                instanceScopes.get(instanceKey)?.unshift(iterationData)\n              const c = produceChildren(iterationData)\n              // Ensure our instance key never changed during runtime\n              if (slotData) instanceScopes.get(instanceKey)?.shift()\n              if (iterationData) instanceScopes.get(instanceKey)?.shift()\n              instanceKey = currentKey\n              return c as RenderableList\n            },\n          }\n        }\n        children.slot = true\n      } else {\n        // If we dont have any children, we still need to provide an object\n        // instead of an empty array (which raises a warning in vue)\n        children = () => ({})\n      }\n    }\n\n    // Compile the for loop down\n    if ('for' in node && node.for) {\n      const values = node.for.length === 3 ? node.for[2] : node.for[1]\n      const getValues =\n        typeof values === 'string' && values.startsWith('$')\n          ? provider(compile(values))\n          : () => values\n      iterator = [\n        getValues,\n        node.for[0],\n        node.for.length === 3 ? String(node.for[1]) : null,\n      ]\n    }\n    return [condition, element, attrs, children, alternate, iterator, resolve]\n  }\n\n  /**\n   * Given a particular function that produces children, ensure that the second\n   * argument of all these slots is the original instance key being used to\n   * render the slots.\n   * @param children - The children() function that will produce slots\n   */\n  function createSlots(\n    children: RenderChildren,\n    iterationData?: Record<string, unknown>\n  ): RenderableSlots | null {\n    const slots = children(iterationData) as RenderableSlots\n    const currentKey = instanceKey\n    return Object.keys(slots).reduce((allSlots, slotName) => {\n      const slotFn = slots && slots[slotName]\n      allSlots[slotName] = (data?: Record<string, any>) => {\n        return (slotFn && slotFn(data, currentKey)) || null\n      }\n      return allSlots\n    }, {} as RenderableSlots)\n  }\n\n  /**\n   * Creates an element\n   * @param data - The context data available to the node\n   * @param node - The schema node to render\n   * @returns\n   */\n  function createElement(\n    library: FormKitComponentLibrary,\n    node: FormKitSchemaNode\n  ): RenderNodes {\n    // Parses the schema node into pertinent parts\n    const [condition, element, attrs, children, alternate, iterator, resolve] =\n      parseNode(library, node)\n    // This is a sub-render function (called within a render function). It must\n    // only use pre-compiled features, and be organized in the most efficient\n    // manner possible.\n    let createNodes: RenderNodes = ((\n      iterationData?: Record<string, unknown>\n    ) => {\n      if (condition && element === null && children) {\n        // Handle conditional if/then statements\n        return condition()\n          ? children(iterationData)\n          : alternate && alternate(iterationData)\n      }\n\n      if (element && (!condition || condition())) {\n        // handle text nodes\n        if (element === 'text' && children) {\n          return createTextVNode(String(children()))\n        }\n        // Handle lone slots\n        if (element === 'slot' && children) return children(iterationData)\n        // Handle resolving components\n        const el = resolve ? resolveComponent(element as string) : element\n        // If we are rendering slots as children, ensure their instanceKey is properly added\n        const slots: RenderableSlots | null = children?.slot\n          ? createSlots(children, iterationData)\n          : null\n        // Handle dom elements and components\n        return h(\n          el as ConcreteComponent,\n          attrs(),\n          (slots || (children ? children(iterationData) : [])) as Renderable[]\n        )\n      }\n\n      return typeof alternate === 'function'\n        ? alternate(iterationData)\n        : alternate\n    }) as RenderNodes\n\n    if (iterator) {\n      const repeatedNode = createNodes\n      const [getValues, valueName, keyName] = iterator\n      createNodes = (() => {\n        const _v = getValues()\n        const values = Number.isFinite(_v)\n          ? Array(Number(_v))\n              .fill(0)\n              .map((_, i) => i)\n          : _v\n        const fragment = []\n        if (typeof values !== 'object') return null\n        const instanceScope = instanceScopes.get(instanceKey) || []\n        const isArray = Array.isArray(values)\n        for (const key in values) {\n          if (isArray && key in Array.prototype) continue // Fix #299\n          const iterationData: Record<string, unknown> = Object.defineProperty(\n            {\n              ...instanceScope.reduce(\n                (\n                  previousIterationData: Record<string, undefined>,\n                  scopedData: Record<string, undefined>\n                ) => {\n                  if (previousIterationData.__idata) {\n                    return { ...previousIterationData, ...scopedData }\n                  }\n                  return scopedData\n                },\n                {} as Record<string, undefined>\n              ),\n              [valueName]: (values as Record<string, any>)[key],\n              ...(keyName !== null\n                ? { [keyName]: isArray ? Number(key) : key }\n                : {}),\n            },\n            '__idata',\n            { enumerable: false, value: true }\n          )\n          instanceScope.unshift(iterationData)\n          fragment.push(repeatedNode.bind(null, iterationData)())\n          instanceScope.shift()\n        }\n        return fragment\n      }) as RenderNodes\n    }\n    return createNodes as RenderNodes\n  }\n\n  /**\n   * Given a schema, parse it and return the resulting renderable nodes.\n   * @param data - The schema context object\n   * @param library - The available components\n   * @param node - The node to parse\n   * @returns\n   */\n  function createElements(\n    library: FormKitComponentLibrary,\n    schema: FormKitSchemaNode | FormKitSchemaNode[]\n  ): RenderChildren {\n    if (Array.isArray(schema)) {\n      const els = schema.map(createElement.bind(null, library))\n      return (iterationData?: Record<string, unknown>) =>\n        els.map((element) => element(iterationData))\n    }\n    // Single node to render\n    const element = createElement(library, schema)\n    return (iterationData?: Record<string, unknown>) => element(iterationData)\n  }\n\n  /**\n   * Data providers produced as a result of the compiler.\n   */\n  const providers: ProviderRegistry = []\n\n  /**\n   * Append the requisite compiler provider and return the compiled function.\n   * @param compiled - A compiled function\n   * @returns\n   */\n  function provider(\n    compiled: FormKitCompilerOutput,\n    hints: Record<string, boolean> = {}\n  ) {\n    const compiledFns = new WeakMap<object, FormKitCompilerOutput>()\n    providers.push((callback: SchemaProviderCallback, key: object) => {\n      compiledFns.set(\n        key,\n        compiled.provide((tokens) => callback(tokens, hints))\n      )\n    })\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return () => compiledFns.get(instanceKey)!()\n  }\n\n  /**\n   * Creates a new instance of a given schema — this either comes from a\n   * memoized copy of the parsed schema or a freshly parsed version. An object\n   * instance key, and dataProvider functions are passed in.\n   * @param providerCallback - A function that is called for each required provider\n   * @param key - a object representing the current instance\n   */\n  function createInstance(\n    providerCallback: SchemaProviderCallback,\n    key: object\n  ) {\n    memoKey ??= toMemoKey(schema)\n    const [render, compiledProviders] = has(memo, memoKey)\n      ? memo[memoKey]\n      : [createElements(library, schema), providers]\n\n    if (!isServer) {\n      memoKeys[memoKey] ??= 0\n      memoKeys[memoKey]++\n      memo[memoKey] = [render, compiledProviders]\n    }\n\n    compiledProviders.forEach((compiledProvider) => {\n      compiledProvider(providerCallback, key)\n    })\n    return () => {\n      // Set the instance key for this pass of rendering.\n      instanceKey = key\n      return render()\n    }\n  }\n  return createInstance\n}\n\n/**\n * Checks the current runtime scope for data.\n * @param token - The token to lookup in the current scope\n * @param defaultValue - The default ref value to use if no scope is found.\n */\nfunction useScope(token: string, defaultValue: any) {\n  const scopedData = instanceScopes.get(instanceKey) || []\n  let scopedValue: any = undefined\n  if (scopedData.length) {\n    scopedValue = getValue(scopedData, token.split('.'))\n  }\n  return scopedValue === undefined ? defaultValue : scopedValue\n}\n\n/**\n * Get the current scoped data and flatten it.\n */\nfunction slotData(data: Record<string, any>, key: object) {\n  return new Proxy(data, {\n    get(...args) {\n      let data: any = undefined\n      const property = args[1]\n      if (typeof property === 'string') {\n        const prevKey = instanceKey\n        instanceKey = key\n        data = useScope(property, undefined)\n        instanceKey = prevKey\n      }\n      return data !== undefined ? data : Reflect.get(...args)\n    },\n  })\n}\n\n/**\n * Provides data to a parsed schema.\n * @param provider - The SchemaProvider (output of calling parseSchema)\n * @param data - Data to fetch values from\n * @returns\n */\nfunction createRenderFn(\n  instanceCreator: SchemaProvider,\n  data: Record<string, any>,\n  instanceKey: object\n) {\n  return instanceCreator(\n    (requirements, hints: Record<string, boolean> = {}) => {\n      return requirements.reduce((tokens, token) => {\n        if (token.startsWith('slots.')) {\n          const slot = token.substring(6)\n          const hasSlot = () =>\n            data.slots &&\n            has(data.slots, slot) &&\n            typeof data.slots[slot] === 'function'\n          if (hints.if) {\n            // If statement — dont render the slot, check if it exists\n            tokens[token] = hasSlot\n          } else if (data.slots) {\n            // Render the slot with current scope data\n            const scopedData = slotData(data, instanceKey)\n            tokens[token] = () =>\n              hasSlot() ? data.slots[slot](scopedData) : null\n          }\n        } else {\n          const value = getRef(token, data)\n          tokens[token] = () => useScope(token, value.value)\n        }\n        return tokens\n      }, {} as Record<string, any>)\n    },\n    instanceKey\n  )\n}\n\n/**\n * Removes the schema from the memo and cleans up the instance scope.\n * @param schema - The schema to remove from memo.\n * @param instanceKey - The instance key to remove.\n */\nfunction clean(\n  schema: FormKitSchemaDefinition,\n  memoKey: string | undefined,\n  instanceKey: object\n) {\n  memoKey ??= toMemoKey(schema)\n  memoKeys[memoKey]--\n  if (memoKeys[memoKey] === 0) {\n    delete memoKeys[memoKey]\n    const [, providers] = memo[memoKey]\n    delete memo[memoKey]\n    providers.length = 0\n  }\n  instanceScopes.delete(instanceKey)\n}\n\n/**\n * Convert a schema to a memo key.\n * @param schema - A schema to convert to a memo key\n */\nfunction toMemoKey(schema: FormKitSchemaDefinition) {\n  return JSON.stringify(schema, (_, value) => {\n    // Technically there shouldn’t be any functions in here, but just in case\n    // we want to sniff them out and convert them to strings\n    // See: https://github.com/formkit/formkit/issues/933\n    if (typeof value === 'function') {\n      return value.toString()\n    }\n    return value\n  })\n}\n\n/**\n * The FormKitSchema vue component:\n *\n * @public\n */\nexport const FormKitSchema = /* #__PURE__ */ defineComponent({\n  name: 'FormKitSchema',\n  props: {\n    schema: {\n      type: [Array, Object] as PropType<FormKitSchemaDefinition>,\n      required: true,\n    },\n    data: {\n      type: Object as PropType<Record<string, any>>,\n      default: () => ({}),\n    },\n    library: {\n      type: Object as PropType<FormKitComponentLibrary>,\n      default: () => ({}),\n    },\n    memoKey: {\n      type: String,\n      required: false,\n    },\n  },\n  emits: ['mounted'],\n  setup(props, context) {\n    const instance = getCurrentInstance()\n    let instanceKey = {}\n    instanceScopes.set(instanceKey, [])\n    const library = { FormKit: markRaw(FormKit), ...props.library }\n    let provider = parseSchema(library, props.schema, props.memoKey)\n    let render: RenderChildren\n    let data: Record<string, any>\n    // // Re-parse the schema if it changes:\n    if (!isServer) {\n      watch(\n        () => props.schema,\n        (newSchema, oldSchema) => {\n          const oldKey = instanceKey\n          instanceKey = {}\n          instanceScopes.set(instanceKey, [])\n          provider = parseSchema(library, props.schema, props.memoKey)\n          render = createRenderFn(provider, data, instanceKey)\n          if (newSchema === oldSchema) {\n            // In this edge case, someone pushed/modified something in the schema\n            // and we've successfully re-parsed, but since the schema is not\n            // referenced in the render function it technically isnt a dependency\n            // and we need to force a re-render since we swapped out the render\n            // function completely.\n            ;(instance?.proxy?.$forceUpdate as unknown as CallableFunction)()\n          }\n          clean(props.schema, props.memoKey, oldKey)\n        },\n        { deep: true }\n      )\n    }\n\n    // // Watch the data object explicitly\n    watchEffect(() => {\n      data = Object.assign(reactive(props.data ?? {}), {\n        slots: context.slots,\n      })\n      context.slots\n      render = createRenderFn(provider, data, instanceKey)\n    })\n\n    /**\n     * Perform cleanup operations when the component is unmounted. This should\n     * remove any memory allocations that were made during the render process.\n     */\n    function cleanUp() {\n      // Perform cleanup operations\n      clean(props.schema, props.memoKey, instanceKey)\n      /* eslint-disable @typescript-eslint/no-non-null-assertion */\n      if (data) {\n        if (data.node) data.node.destroy()\n        data.slots = null!\n        data = null!\n      }\n      render = null!\n      /* eslint-enable @typescript-eslint/no-non-null-assertion */\n    }\n\n    // When the component is mounted, emit the mounted event\n    onMounted(() => context.emit('mounted'))\n    // For browser rendering:\n    onUnmounted(cleanUp)\n    // For SSR rendering:\n    onSSRComplete(getCurrentInstance()?.appContext.app, cleanUp)\n\n    return () => (render ? render() : null)\n  },\n})\n\nexport default FormKitSchema\n", "import { App } from 'vue'\n\n/**\n * A flag indicating if this is (likely) a server context.\n */\nconst isServer = typeof window === 'undefined'\n\n/**\n * A map of Vue applications to a set of callbacks to be flushed after SSR is\n * complete.\n */\nconst ssrCompleteRegistry = new Map<App<any>, Set<CallableFunction>>()\n\n/**\n * Flush all callbacks registered with onSSRComplete for a given app.\n * @param app - The Vue application.\n * @public\n */\nexport function ssrComplete(app: App<any>) {\n  if (!isServer) return\n  const callbacks = ssrCompleteRegistry.get(app)\n  if (!callbacks) return\n  for (const callback of callbacks) {\n    callback()\n  }\n  callbacks.clear()\n  ssrCompleteRegistry.delete(app)\n}\n\n/**\n * Register a callback for when SSR is complete. No-op if not in a server\n * context.\n * @param app - The Vue application.\n * @param callback - The callback to be called after SSR is complete.\n * @public\n */\nexport function onSSRComplete(\n  app: App<any> | undefined,\n  callback: CallableFunction\n) {\n  if (!isServer || !app) return\n  if (!ssrCompleteRegistry.has(app)) ssrCompleteRegistry.set(app, new Set())\n  ssrCompleteRegistry.get(app)?.add(callback)\n}\n", "import { h, ref, watch, provide, InjectionKey, Ref } from 'vue'\nimport { defineComponent } from 'vue'\n\n/**\n * The symbol that represents the formkit’s root element injection value.\n *\n * @public\n */\nexport const rootSymbol: InjectionKey<Ref<Document | ShadowRoot | undefined>> =\n  Symbol()\n\n/**\n * The FormKitRoot wrapper component used to provide context to FormKit about\n * whether a FormKit input is booting in a Document or ShadowRoot. This is\n * generally only necessary when booting FormKit nodes in contexts that do not\n * have a document. For example, if running code like this:\n *\n * ```ts\n * document.getElementById(node.props.id)\n * ```\n *\n * does not work because the `document` is not available or is not in the same\n * scope, you can place a `<FormKitRoot>` component somewhere near the root of\n * of your shadowRoot and it will inform any FormKitNode child (at any depth)\n * that it is running in a shadow root. The \"root\" (`Document` or `ShadowRoot`)\n * will be made available to all child nodes at `node.context._root`\n *\n * @public\n */\nexport const FormKitRoot = /* #__PURE__ */ defineComponent((_p, context) => {\n  const boundary = ref<null | HTMLElement>(null)\n  const showBody = ref(false)\n  const shadowRoot = ref<Document | ShadowRoot | undefined>(undefined)\n\n  const stopWatch = watch(boundary, (el) => {\n    let parent: Node | null | undefined = el\n    let root: null | Node = null\n    while ((parent = parent?.parentNode)) {\n      root = parent\n      if (root instanceof ShadowRoot || root instanceof Document) {\n        foundRoot(root)\n        break\n      }\n    }\n    stopWatch()\n    showBody.value = true\n  })\n  provide(rootSymbol, shadowRoot)\n\n  function foundRoot(root: Document | ShadowRoot) {\n    shadowRoot.value = root\n  }\n\n  return () =>\n    showBody.value && context.slots.default\n      ? context.slots.default()\n      : h('template', { ref: boundary })\n})\n", "import { parentSymbol, componentSymbol } from '../FormKit'\nimport { rootSymbol } from '../FormKitRoot'\nimport {\n  error,\n  createNode,\n  FormKitNode,\n  FormKitOptions,\n  FormKitMessage,\n  createMessage,\n} from '@formkit/core'\nimport { FormKitRuntimeProps } from '@formkit/inputs'\nimport {\n  nodeProps,\n  except,\n  camel,\n  extend,\n  only,\n  kebab,\n  cloneAny,\n  slugify,\n  isObject,\n  token,\n  undefine,\n  oncePerTick,\n  eq,\n  shallowClone,\n} from '@formkit/utils'\nimport {\n  toRef,\n  watchEffect,\n  inject,\n  provide,\n  watch,\n  getCurrentInstance,\n  computed,\n  ref,\n  WatchStopHandle,\n  onBeforeUnmount,\n  onMounted,\n  SetupContext,\n} from 'vue'\nimport { FormKitInputs } from '@formkit/inputs'\nimport { optionsSymbol } from '../plugin'\nimport { FormKitGroupValue } from 'packages/core/src'\nimport { FormKitPseudoProps } from '@formkit/core'\n\ninterface FormKitComponentListeners {\n  onSubmit?: (payload?: FormKitGroupValue) => Promise<unknown> | unknown\n  onSubmitRaw?: (event?: Event) => unknown\n  onSubmitInvalid?: (node?: Node) => unknown\n}\n\nconst isBrowser = typeof window !== 'undefined'\n\n/**\n * Props that are extracted from the attrs object.\n * TODO: Currently local, this should probably exported to a inputs or another\n * package.\n */\nconst pseudoProps = [\n  // Boolean props\n  'ignore',\n  'disabled',\n  'preserve',\n  // String props\n  'help',\n  'label',\n  /^preserve(-e|E)rrors/,\n  /^[a-z]+(?:-visibility|Visibility|-behavior|Behavior)$/,\n  /^[a-zA-Z-]+(?:-class|Class)$/,\n  'prefixIcon',\n  'suffixIcon',\n  /^[a-zA-Z-]+(?:-icon|Icon)$/,\n]\n\nconst boolProps = ['disabled', 'ignore', 'preserve']\n\n/**\n * Given some props, map those props to individualized props internally.\n * @param node - A formkit node\n * @param props - Some props that may include a classes object\n */\nfunction classesToNodeProps(node: FormKitNode, props: Record<string, any>) {\n  if (props.classes) {\n    Object.keys(props.classes).forEach(\n      (key: keyof (typeof props)['classes']) => {\n        if (typeof key === 'string') {\n          node.props[`_${key}Class`] = props.classes[key]\n          // We need to ensure Vue is aware that we want to actually observe the\n          // child values too, so we touch them here.\n          if (isObject(props.classes[key]) && key === 'inner')\n            Object.values(props.classes[key])\n        }\n      }\n    )\n  }\n}\n\n/**\n * Extracts known FormKit listeners.\n * @param props - Extract known FormKit listeners.\n * @returns\n */\nfunction onlyListeners(\n  props: Record<string, unknown> | null | undefined\n): FormKitComponentListeners {\n  if (!props) return {}\n  const knownListeners = ['Submit', 'SubmitRaw', 'SubmitInvalid'].reduce(\n    (listeners, listener) => {\n      const name = `on${listener}`\n      if (name in props) {\n        if (typeof props[name] === 'function') {\n          listeners[name] = props[name] as CallableFunction\n        }\n      }\n      return listeners\n    },\n    {} as Record<string, CallableFunction>\n  )\n  return knownListeners as FormKitComponentListeners\n}\n\n/**\n * A composable for creating a new FormKit node.\n *\n * @param type - The type of node (input, group, list)\n * @param attrs - The FormKit \"props\" — which is really the attrs list.\n *\n * @returns {@link @formkit/core#FormKitNode | FormKitNode}\n *\n * @public\n */\nexport function useInput<\n  Props extends FormKitInputs<Props>,\n  Context extends SetupContext<any, any>\n>(props: Props, context: Context, options: FormKitOptions = {}): FormKitNode {\n  /**\n   * The configuration options, these are provided by either the plugin or by\n   * explicit props.\n   */\n  const config = Object.assign({}, inject(optionsSymbol) || {}, options)\n\n  /**\n   * The root element — generally this is either a Document or ShadowRoot.\n   */\n  const __root = inject(rootSymbol, ref(isBrowser ? document : undefined))\n\n  /**\n   * The component symbol, this is used to register the node with the \"owner\"\n   * component.\n   */\n  const __cmpCallback = inject(componentSymbol, () => {\n    /* void */\n  })\n\n  /**\n   * The current instance.\n   */\n  const instance = getCurrentInstance()\n\n  /**\n   * Extracts the listeners.\n   */\n  const listeners = onlyListeners(instance?.vnode.props)\n\n  /**\n   * Determines if the prop is v-modeled. Credit to:\n   * {@link https://github.com/LinusBorg | Thorsten Lünborg}\n   * for coming up with this solution.\n   */\n  const isVModeled = ['modelValue', 'model-value'].some(\n    (prop) => prop in (instance?.vnode.props ?? {})\n  )\n\n  // Track if the input has mounted or not.\n  let isMounted = false\n  onMounted(() => {\n    isMounted = true\n  })\n\n  /**\n   * Determines if the object being passed as a v-model is reactive.\n   */\n  // const isReactiveVModel = isVModeled && isReactive(props.modelValue)\n\n  /**\n   * Define the initial component\n   */\n  const value: any =\n    props.modelValue !== undefined\n      ? props.modelValue\n      : cloneAny(context.attrs.value)\n\n  /**\n   * Creates the node's initial props from the context, props, and definition\n   * @returns\n   */\n  function createInitialProps(): Record<string, any> {\n    const initialProps: Record<string, any> = {\n      ...nodeProps(props),\n      ...listeners,\n      type: props.type ?? 'text',\n      __root: __root.value,\n      __slots: context.slots,\n    }\n    const attrs = except(nodeProps(context.attrs), pseudoProps)\n    if (!attrs.key) attrs.key = token()\n    initialProps.attrs = attrs\n    const propValues = only(nodeProps(context.attrs), pseudoProps)\n    for (const propName in propValues) {\n      if (boolProps.includes(propName) && propValues[propName] === '') {\n        propValues[propName] = true\n      }\n      initialProps[camel(propName)] = propValues[propName]\n    }\n    const classesProps = { props: {} }\n    classesToNodeProps(classesProps as FormKitNode, props)\n    Object.assign(initialProps, classesProps.props)\n    if (typeof initialProps.type !== 'string') {\n      initialProps.definition = initialProps.type\n      delete initialProps.type\n    }\n    return initialProps\n  }\n\n  /**\n   * Create the FormKitNode.\n   */\n  const initialProps = createInitialProps()\n\n  /**\n   * The parent node.\n   */\n  const parent = initialProps.ignore\n    ? null\n    : props.parent || inject(parentSymbol, null)\n  const node = createNode(\n    extend(\n      config || {},\n      {\n        name: props.name || undefined,\n        value,\n        parent,\n        plugins: (config.plugins || []).concat(props.plugins ?? []),\n        config: props.config || {},\n        props: initialProps,\n        index: props.index,\n        sync: !!undefine(context.attrs.sync || context.attrs.dynamic),\n      },\n      false,\n      true\n    ) as Partial<FormKitOptions>\n  ) as FormKitNode\n\n  /**\n   * Call the component callback.\n   */\n  __cmpCallback(node)\n\n  /**\n   * If no definition has been assigned at this point — we're out!\n   */\n  if (!node.props.definition) error(600, node)\n\n  /**\n   * All props that are bound \"late\" (after node creation) — are added to a set\n   * which is used to watch the context.attrs object.\n   */\n  const lateBoundProps = ref<Set<string | RegExp>>(\n    new Set(\n      Array.isArray(node.props.__propDefs)\n        ? node.props.__propDefs\n        : Object.keys(node.props.__propDefs ?? {})\n    )\n  )\n\n  /**\n   * Any additional props added at a \"later\" time should also be part of the\n   * late bound props.\n   */\n  node.on(\n    'added-props',\n    ({ payload: lateProps }: { payload: FormKitPseudoProps }) => {\n      const propNames = Array.isArray(lateProps)\n        ? lateProps\n        : Object.keys(lateProps ?? {})\n      propNames.forEach((newProp) => lateBoundProps.value.add(newProp))\n    }\n  )\n\n  /**\n   * These prop names must be assigned.\n   */\n  const pseudoPropNames = computed(() =>\n    pseudoProps.concat([...lateBoundProps.value]).reduce((names, prop) => {\n      if (typeof prop === 'string') {\n        names.push(camel(prop))\n        names.push(kebab(prop))\n      } else {\n        names.push(prop)\n      }\n      return names\n    }, [] as Array<string | RegExp>)\n  )\n\n  /* Splits Classes object into discrete props for each key */\n  watchEffect(() => classesToNodeProps(node, props))\n\n  /**\n   * The props object already has properties even if they start as \"undefined\"\n   * so we can loop over them and individual watchEffect to prevent responding\n   * inappropriately.\n   */\n  const passThrough = nodeProps(props)\n  for (const prop in passThrough) {\n    watch(\n      () => props[prop as keyof FormKitRuntimeProps<Props>],\n      () => {\n        if (props[prop as keyof FormKitRuntimeProps<Props>] !== undefined) {\n          node.props[prop] = props[prop as keyof FormKitRuntimeProps<Props>]\n        }\n      }\n    )\n  }\n\n  // Ensure the root always stays up to date.\n  watchEffect(() => {\n    node.props.__root = __root.value\n  })\n\n  /**\n   * Watch \"pseudoProp\" attributes explicitly.\n   */\n  const attributeWatchers = new Set<WatchStopHandle>()\n  const possibleProps = nodeProps(context.attrs)\n  watchEffect(() => {\n    watchAttributes(only(possibleProps, pseudoPropNames.value))\n  })\n\n  /**\n   * Defines attributes that should be used as props.\n   * @param attrProps - Attributes that should be used as props instead\n   */\n  function watchAttributes(attrProps: Record<string, any>) {\n    attributeWatchers.forEach((stop) => {\n      stop()\n      attributeWatchers.delete(stop)\n    })\n    for (const prop in attrProps) {\n      const camelName = camel(prop)\n      attributeWatchers.add(\n        watch(\n          () => context.attrs[prop],\n          () => {\n            node.props[camelName] = context.attrs[prop]\n          }\n        )\n      )\n    }\n  }\n\n  /**\n   * Watch and dynamically set attribute values, those values that are not\n   * props and are not pseudoProps\n   */\n  watchEffect(() => {\n    const attrs = except(nodeProps(context.attrs), pseudoPropNames.value)\n    // An explicit exception to ensure naked \"multiple\" attributes appear on the\n    // outer wrapper as data-multiple=\"true\"\n    if ('multiple' in attrs) attrs.multiple = undefine(attrs.multiple)\n    if (typeof attrs.onBlur === 'function') {\n      attrs.onBlur = oncePerTick(attrs.onBlur)\n    }\n    node.props.attrs = Object.assign({}, node.props.attrs || {}, attrs)\n  })\n\n  /**\n   * Add any/all \"prop\" errors to the store.\n   */\n  watchEffect(() => {\n    const messages = (props.errors ?? []).map((error) =>\n      /* #__PURE__ */ createMessage({\n        key: slugify(error),\n        type: 'error',\n        value: error,\n        meta: { source: 'prop' },\n      })\n    )\n    node.store.apply(\n      messages,\n      (message) => message.type === 'error' && message.meta.source === 'prop'\n    )\n  })\n\n  /**\n   * Add input errors.\n   */\n  if (node.type !== 'input') {\n    const sourceKey = `${node.name}-prop`\n    watchEffect(() => {\n      const inputErrors = props.inputErrors ?? {}\n      const keys = Object.keys(inputErrors)\n      if (!keys.length) node.clearErrors(true, sourceKey)\n      const messages = keys.reduce((messages, key) => {\n        let value = inputErrors[key]\n        if (typeof value === 'string') value = [value]\n        if (Array.isArray(value)) {\n          messages[key] = value.map((error) =>\n            /* #__PURE__ */ createMessage({\n              key: error,\n              type: 'error',\n              value: error,\n              meta: { source: sourceKey },\n            })\n          )\n        }\n        return messages\n      }, {} as Record<string, FormKitMessage[]>)\n      node.store.apply(\n        messages,\n        (message) =>\n          message.type === 'error' && message.meta.source === sourceKey\n      )\n    })\n  }\n\n  /**\n   * Watch the config prop for any changes.\n   */\n  watchEffect(() => Object.assign(node.config, props.config))\n\n  /**\n   * Produce another parent object.\n   */\n  if (node.type !== 'input') {\n    provide(parentSymbol, node)\n  }\n\n  // let inputTimeout: number | undefined\n\n  let clonedValueBeforeVmodel: unknown = undefined\n  /**\n   * Explicitly watch the input value, and emit changes (lazy)\n   */\n  node.on('modelUpdated', () => {\n    // Emit the values after commit\n    context.emit('inputRaw', node.context?.value, node)\n    if (isMounted) {\n      context.emit('input', node.context?.value, node)\n    }\n    if (isVModeled && node.context) {\n      clonedValueBeforeVmodel = cloneAny(node.value)\n      context.emit('update:modelValue', shallowClone(node.value))\n    }\n  })\n\n  /**\n   * Enabled support for v-model, using this for groups/lists is not recommended\n   */\n  if (isVModeled) {\n    watch(\n      toRef(props, 'modelValue'),\n      (value) => {\n        if (!eq(clonedValueBeforeVmodel, value)) {\n          node.input(value, false)\n        }\n      },\n      { deep: true }\n    )\n\n    /**\n     * On initialization, if the node’s value was updated (like in a plugin\n     * hook) then we should emit a `modelUpdated` event.\n     */\n    if (node.value !== value) {\n      node.emit('modelUpdated')\n    }\n  }\n\n  /**\n   * When this input shuts down, we need to \"delete\" the node too.\n   */\n  onBeforeUnmount(() => node.destroy())\n\n  return node\n}\n", "import {\n  FormKitOptions,\n  FormKitNode,\n  FormKitRootConfig,\n  getNode,\n  createConfig,\n  setErrors,\n  clearErrors,\n  submitForm,\n  reset,\n} from '@formkit/core'\nimport type { App, Plugin, InjectionKey } from 'vue'\nimport FormKit, { FormKitComponent } from './FormKit'\nimport FormKitSchema from './FormKitSchema'\n\ndeclare module 'vue' {\n  interface ComponentCustomProperties {\n    $formkit: FormKitVuePlugin\n  }\n  interface GlobalComponents {\n    // @ts-ignore\n    FormKit: FormKitComponent\n    FormKitSchema: typeof FormKitSchema\n  }\n}\n/**\n * The global instance of the FormKit plugin.\n *\n * @public\n */\nexport interface FormKitVuePlugin {\n  get: (id: string) => FormKitNode | undefined\n  setLocale: (locale: string) => void\n  setErrors: (\n    formId: string,\n    errors: string[] | Record<string, string | string[]>,\n    inputErrors?: string[] | Record<string, string | string[]>\n  ) => void\n  clearErrors: (formId: string) => void\n  submit: (formId: string) => void\n  reset: (formId: string, resetTo?: unknown) => void\n}\n\n/**\n * The Create a new instance of the FormKit plugin for Vue.\n *\n * @param app - A Vue application\n * @param config - FormKit Vue plugin configuration options\n *\n * @internal\n */\nfunction createPlugin(\n  app: App<any>,\n  options: FormKitOptions & Record<string, any>\n): FormKitVuePlugin {\n  app\n    .component(options.alias || 'FormKit', FormKit as any)\n    .component(options.schemaAlias || 'FormKitSchema', FormKitSchema)\n  return {\n    get: getNode,\n    setLocale: (locale: string) => {\n      if (options.config?.rootConfig) {\n        options.config.rootConfig.locale = locale\n      }\n    },\n    clearErrors,\n    setErrors,\n    submit: submitForm,\n    reset,\n  }\n}\n\n/**\n * The symbol key for accessing the FormKit node options.\n *\n * @public\n */\nexport const optionsSymbol: InjectionKey<FormKitOptions> =\n  Symbol.for('FormKitOptions')\n\n/**\n * The symbol key for accessing FormKit root configuration.\n *\n * @public\n */\nexport const configSymbol: InjectionKey<FormKitRootConfig> =\n  Symbol.for('FormKitConfig')\n\n/**\n * Create the FormKit plugin.\n *\n * @public\n */\nexport const plugin: Plugin = {\n  install(\n    app,\n    _options: FormKitOptions | ((...args: any[]) => FormKitOptions)\n  ): void {\n    /**\n     * Extend the default configuration options.\n     */\n    const options: FormKitOptions = Object.assign(\n      {\n        alias: 'FormKit',\n        schemaAlias: 'FormKitSchema',\n      },\n      typeof _options === 'function' ? _options() : _options\n    )\n    /**\n     * The root configuration options.\n     */\n    const rootConfig = createConfig(options.config || {})\n    /**\n     * We dont want to explicitly provide any \"config\" options, only a root\n     * config option — so here we override the existing config options.\n     */\n    options.config = { rootConfig }\n    /**\n     * Register the global $formkit plugin property.\n     */\n    app.config.globalProperties.$formkit = createPlugin(app, options)\n    /**\n     * Provide the config to the application for injection.\n     */\n    app.provide(optionsSymbol, options)\n    /**\n     * Provide the root config to the application.\n     */\n    app.provide(configSymbol, rootConfig)\n    /**\n     * Register the FormKit component globally.\n     */\n    if (typeof window !== 'undefined') {\n      globalThis.__FORMKIT_CONFIGS__ = (\n        globalThis.__FORMKIT_CONFIGS__ || []\n      ).concat([rootConfig])\n    }\n  },\n}\n", "import {\n  FormKitTypeDefinition,\n  FormKitSchemaNode,\n  FormKitSectionsSchema,\n} from '@formkit/core'\nimport { cloneAny } from '@formkit/utils'\nimport { createSection, FormKitSection, useSchema } from '@formkit/inputs'\nimport { Component, markRaw } from 'vue'\n\nlet totalCreated = 1\n\n/**\n * Determine if the given object is a vue component.\n *\n * @param obj - Object or function\n * @returns\n * @public\n */\nfunction isComponent(obj: any): obj is Component {\n  return (\n    (typeof obj === 'function' && obj.length === 2) ||\n    (typeof obj === 'object' &&\n      !Array.isArray(obj) &&\n      !('$el' in obj) &&\n      !('$cmp' in obj) &&\n      !('if' in obj))\n  )\n}\n\n/**\n * Creates a new input from schema or a Vue component with the \"standard\"\n * FormKit features in place such as labels, help text, validation messages, and\n * class support.\n *\n * @param schemaOrComponent - The actual schema of the input or the component.\n * @param definitionOptions - Any options in the FormKitTypeDefinition you want\n * to define.\n *\n * @returns {@link @formkit/core#FormKitTypeDefinition | FormKitTypeDefinition}\n *\n * @public\n */\nexport function createInput<V = unknown>(\n  schemaOrComponent: FormKitSchemaNode | FormKitSection | Component,\n  definitionOptions: Partial<FormKitTypeDefinition<V>> = {},\n  sectionsSchema: FormKitSectionsSchema = {}\n): FormKitTypeDefinition<V> {\n  const definition: FormKitTypeDefinition<V> = {\n    type: 'input',\n    ...definitionOptions,\n  }\n  let schema: FormKitSection\n  if (isComponent(schemaOrComponent)) {\n    const cmpName = `SchemaComponent${totalCreated++}`\n    schema = createSection('input', () => ({\n      $cmp: cmpName,\n      props: {\n        context: '$node.context',\n      },\n    }))\n    definition.library = { [cmpName]: markRaw(schemaOrComponent) }\n  } else if (typeof schemaOrComponent === 'function') {\n    schema = schemaOrComponent\n  } else {\n    schema = createSection('input', () => cloneAny(schemaOrComponent))\n  }\n\n  // Use the default wrapping schema\n  definition.schema = useSchema(schema || 'Schema undefined', sectionsSchema)\n  if (!definition.schemaMemoKey) {\n    definition.schemaMemoKey = `${Math.random()}`\n  }\n  return definition\n}\n", "import { DefaultConfigOptions } from '../index'\n\nexport function defineFormKitConfig(\n  config: DefaultConfigOptions | (() => DefaultConfigOptions)\n): () => DefaultConfigOptions {\n  return () => (typeof config === 'function' ? config() : config)\n}\n", "import {\n  h,\n  defineComponent,\n  ref,\n  computed,\n  reactive,\n  onMounted,\n  KeepAlive,\n} from 'vue'\nimport { FormKitSchemaDefinition } from '@formkit/core'\nimport { FormKitSchema } from './index'\nimport { FormKitNode } from '@formkit/core'\nimport { getNode } from '@formkit/core'\nimport { FormKitSchemaNode } from 'packages/core/src'\n\nlet inputList: Record<string, string[]> = {}\nconst schemas: Record<string, FormKitSchemaDefinition[]> = {}\n\nconst classes = {\n  container: `\n    formkit-kitchen-sink \n    p-8\n  `,\n  tabs: `\n    formkit-tabs \n    mt-4 \n    mr-[min(350px,25vw)]\n  `,\n  tab: `\n    formkit-kitchen-sink-tab\n    inline-block\n    mb-4\n    -mr-px\n    cursor-pointer\n    px-4\n    py-2\n    border\n    border-neutral-200\n    text-neutral-800\n    data-[active]:bg-neutral-800\n    data-[active]:border-neutral-800\n    data-[active]:text-neutral-50\n    hover:bg-neutral-100\n    hover:text-neutral-900\n    dark:border-neutral-700\n    dark:text-neutral-50\n    dark:data-[active]:bg-neutral-100\n    dark:data-[active]:border-neutral-100\n    dark:data-[active]:text-neutral-800\n    dark:hover:bg-neutral-800\n    dark:hover:text-neutral-50\n  `,\n  filterContainer: `\n    formkit-filter-container\n    grid\n    grid-cols-[repeat(auto-fit,300px)]\n    mr-[min(350px,25vw)]\n    -mt-4\n    mb-8\n    px-4\n    pt-8\n    pb-4\n    border\n    relative\n    -translate-y-px\n    max-w-[1000px]\n    border-neutral-200\n    dark:border-neutral-700\n  `,\n  filterGroup: `\n    formkit-filter-group\n    mr-8\n    mb-8\n    [&_legend]:text-lg\n    [&_ul]:columns-2\n    [&_ul>li:first-child]:[column-span:all]\n    [&_ul>li:first-child]:mt-2\n    [&_ul>li:first-child]:mb-2\n    [&_ul>li:first-child]:pb-2\n    [&_ul>li:first-child]:border-b\n    [&_ul>li:first-child]:border-neutral-200\n    dark:[&_ul>li:first-child]:border-neutral-700\n  `,\n  formContainer: `\n    formkit-form-container\n    w-full\n    bg-white\n    rounded\n    border\n    border-neutral-100\n    shadow-lg\n    max-w-[800px]\n    p-[min(5vw,5rem)]\n    dark:bg-neutral-900\n    dark:border-neutral-800\n    dark:shadow-3xl\n    [&_form>h1]:text-2xl\n    [&_form>h1]:mb-4\n    [&_form>h1]:font-bold\n    [&_form>h1+p]:text-base\n    [&_form>h1+p]:mb-4\n    [&_form>h1+p]:-mt-2\n    [&_form_.double]:flex\n    [&_form_.double>*]:w-1/2\n    [&_form_.double>*:first-child]:mr-2\n    [&_form_.triple]:flex\n    [&_form_.triple>*]:w-1/3\n    [&_form_.triple>*:first-child]:mr-2\n    [&_form_.triple>*:last-child]:ml-2\n  `,\n  inputs: `formkit-inputs`,\n  specimen: `\n    formkit-specimen \n    flex \n    flex-col \n    p-2 \n    max-w-[75vw]\n  `,\n  inputSection: `\n    group/section\n    formkit-input-section \n    mr-[min(325px,25vw)]\n  `,\n  specimenGroup: `\n    formkit-specimen-group\n    grid\n    mb-16\n    grid-cols-[repeat(auto-fit,400px)]\n    group-data-[type=\"transferlist\"]/section:grid-cols-[repeat(auto-fit,650px)]\n    group-data-[type=\"multi-step\"]/section:grid-cols-[repeat(auto-fit,550px)]\n  `,\n  inputType: `\n    formkit-input-type\n    block\n    font-bold\n    text-neutral-900\n    border-b\n    border-neutral-100\n    text-3xl\n    mb-8\n    pb-2\n    capitalize\n    dark:border-neutral-800 \n    dark:text-neutral-50\n  `,\n}\n\n/**\n * Fetches the list of inputs from the remote schema repository\n */\nasync function fetchInputList() {\n  const response = await fetch(\n    'https://raw.githubusercontent.com/formkit/input-schemas/master/index.json'\n  )\n  const json = await response.json()\n  return json\n}\n\n/**\n * Fetches the list of inputs from the remote schema repository\n */\nasync function fetchInputSchema(input: string) {\n  try {\n    const response = await fetch(\n      `https://raw.githubusercontent.com/formkit/input-schemas/master/schemas/${input}.json`\n    )\n    const json = await response.json()\n    return json\n  } catch (error) {\n    console.error(error)\n  }\n}\n\n/**\n * Renders FormKit components fetched from a remote schema repository.\n * This is a kitchen sink component that is used for testing purposes.\n * It shows inputs in various states and configurations.\n *\n * @public\n */\nexport const FormKitKitchenSink = /* #__PURE__ */ defineComponent({\n  name: 'FormKitKitchenSink',\n  props: {\n    schemas: {\n      type: Array,\n      required: false,\n    },\n    pro: {\n      type: Boolean,\n      default: true,\n    },\n    addons: {\n      type: Boolean,\n      default: true,\n    },\n    forms: {\n      type: Boolean,\n      default: true,\n    },\n    navigation: {\n      type: Boolean,\n      default: true,\n    },\n  },\n  async setup(props) {\n    onMounted(() => {\n      const filterNode = getNode('filter-checkboxes')\n      data.filters = computed((): string[] => {\n        if (!filterNode?.context) return []\n        const filters = filterNode.context.value\n        const filterValues: string[] = []\n        Object.keys(filters).forEach((key) => {\n          filterValues.push(...filters[key])\n        })\n        return filterValues\n      }) as unknown as string[]\n    })\n\n    inputList = Object.keys(inputList).length\n      ? inputList\n      : await fetchInputList()\n    const promises = []\n    const activeTab = ref('')\n    const inputCheckboxes = computed(() => {\n      const inputGroups: Record<string, Record<string, string | string[]>> = {\n        core: { label: 'Inputs', name: 'core', inputs: inputList.core },\n      }\n      if (props.pro) {\n        inputGroups.pro = {\n          label: 'Pro Inputs',\n          name: 'pro',\n          inputs: inputList.pro,\n        }\n      }\n      if (props.addons) {\n        inputGroups.addons = {\n          label: 'Add-ons',\n          name: 'addons',\n          inputs: inputList.addons,\n        }\n      }\n      return inputGroups\n    })\n\n    if (!props.schemas) {\n      const coreInputPromises = inputList.core.map(async (schema: string) => {\n        const response = await fetchInputSchema(schema)\n        schemas[schema] = response\n      })\n      promises.push(...coreInputPromises)\n\n      if (props.forms) {\n        const formsPromises = inputList.forms.map(async (schema: string) => {\n          const schemaName = `form/${schema}`\n          const response = await fetchInputSchema(schemaName)\n          schemas[schemaName] = response\n        })\n        promises.push(...formsPromises)\n      }\n\n      if (props.pro) {\n        const proInputPromises = inputList.pro.map(async (schema: string) => {\n          const response = await fetchInputSchema(schema)\n          schemas[schema] = response\n        })\n        promises.push(...proInputPromises)\n      }\n\n      if (props.addons) {\n        const addonPromises = inputList.addons.map(async (schema: string) => {\n          const response = await fetchInputSchema(schema)\n          schemas[schema] = response\n        })\n        promises.push(...addonPromises)\n      }\n    } else {\n      const schemaPromises = props.schemas.map(async (schema: unknown) => {\n        const response = await fetchInputSchema(`${schema}`)\n        schemas[`${schema}`] = response\n      })\n      promises.push(...schemaPromises)\n    }\n\n    // a plugin required for the \"select all\" checkbox functionality\n    const selectAll = (node: FormKitNode) => {\n      let previousValue: string[] = []\n      let skip = false\n\n      if (node.props.type !== 'checkbox') return\n      node.on('created', () => {\n        // if the only checked item is the \"all\" checkbox, check all\n        const currentValue = node.value\n        if (\n          Array.isArray(currentValue) &&\n          currentValue.length === 1 &&\n          currentValue[0] === 'all'\n        ) {\n          node.input(\n            node.props.options.map((option: string | Record<string, any>) => {\n              if (typeof option !== 'string') return option.value\n              return option\n            })\n          )\n        }\n        previousValue = Array.isArray(node.value) ? node.value : []\n      })\n      node.on('commit', ({ payload }) => {\n        if (skip) {\n          skip = false\n          return\n        }\n        if (!Array.isArray(payload)) return\n\n        const previousValueHadAll = previousValue.includes('all')\n        const currentValueHasAll = payload.includes('all')\n\n        // if \"all\" was checked, check all\n        if (!previousValueHadAll && currentValueHasAll) {\n          const computedOptions = node.props.options.map(\n            (option: string | Record<string, any>) => {\n              if (typeof option !== 'string') return option.value\n              return option\n            }\n          )\n          node.input(computedOptions)\n          previousValue = computedOptions\n          return\n        }\n\n        // if \"all\" was unchecked, uncheck all\n        if (previousValueHadAll && !currentValueHasAll) {\n          node.input([])\n          previousValue = []\n          return\n        }\n\n        const valueMinusAll = payload.filter((value: string) => value !== 'all')\n        // uncheck \"all\" if we have less than all items checked\n        if (\n          valueMinusAll.length < node.props.options.length - 1 &&\n          currentValueHasAll\n        ) {\n          node.input(valueMinusAll)\n          previousValue = valueMinusAll\n          skip = true\n          return\n        }\n\n        // re-check \"all\" if we manually check all other items\n        if (\n          valueMinusAll.length === node.props.options.length - 1 &&\n          !currentValueHasAll\n        ) {\n          const computedOptions = node.props.options.map(\n            (option: string | Record<string, any>) => {\n              if (typeof option !== 'string') return option.value\n              return option\n            }\n          )\n          node.input(computedOptions)\n          previousValue = Array.isArray(node.value) ? node.value : []\n          return\n        }\n      })\n    }\n\n    // supporting schema functions for async input states\n    const data = reactive({\n      twClasses: classes,\n      basicOptions: Array.from({ length: 15 }, (_, i) => `Option ${i + 1}`),\n      asyncLoader: async () => {\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        return await new Promise<void>(() => {})\n      },\n      paginatedLoader: async ({\n        page,\n        hasNextPage,\n      }: {\n        page: number\n        hasNextPage: () => void\n      }) => {\n        const base = (page - 1) * 10\n        hasNextPage()\n        return Array.from({ length: 10 }, (_, i) => `Option ${base + i + 1}`)\n      },\n      formSubmitHandler: async (data: any) => {\n        await new Promise((resolve) => setTimeout(resolve, 1000))\n        alert('Form submitted (fake) — check console for data object')\n        console.log('Form data:', data)\n      },\n      includes: (array: any[], value: any) => {\n        if (!Array.isArray(array)) return false\n        return array.includes(value)\n      },\n      checkboxPlugins: [selectAll],\n      filters: [] as string[],\n    })\n\n    await Promise.all(promises)\n\n    const inputKeys = Object.keys(schemas)\n\n    // create friendly labels for use in tabs\n    const formNames = inputKeys.map((key: string) => {\n      if (key.startsWith('form/')) {\n        switch (key) {\n          case 'form/tshirt':\n            return {\n              id: key,\n              name: 'Order Form',\n            }\n          default:\n            const name = key.replace('form/', '')\n            return {\n              id: key,\n              name: name.charAt(0).toUpperCase() + name.slice(1) + ' Form',\n            }\n        }\n      }\n      return {\n        id: key,\n        name: '',\n      }\n    })\n    const filteredFormNames = formNames.filter((form) => form.name !== '')\n\n    const forms = inputKeys.filter((schema: string) => {\n      return schema.startsWith('form/')\n    })\n    const inputs = inputKeys.filter(\n      (schema: string) => !schema.startsWith('form/')\n    )\n\n    const tabs: Record<string, string>[] = []\n    if (inputs.length) {\n      tabs.push({\n        id: 'kitchen-sink',\n        name: 'Kitchen Sink',\n      })\n    }\n    if (forms.length) {\n      tabs.push(...filteredFormNames.sort((a, b) => (a.name > b.name ? 1 : -1)))\n    }\n    if (tabs.length) {\n      activeTab.value = tabs[0].id\n    }\n\n    // collection of all inputs to be rendered in the \"kitchen sink\" tab\n    const kitchenSinkRenders = computed(() => {\n      inputs.sort()\n\n      const schemaDefinitions: FormKitSchemaDefinition = inputs.reduce(\n        (schemaDefinitions, inputName: string) => {\n          const schemaDefinition = schemas[inputName]\n          schemaDefinitions.push({\n            $el: 'div',\n            if: '$includes($filters, \"' + inputName + '\")',\n            attrs: {\n              key: inputName,\n              class: '$twClasses.inputSection',\n              'data-type': inputName,\n            },\n            children: [\n              {\n                $el: 'h2',\n                attrs: {\n                  class: '$twClasses.inputType',\n                },\n                children: inputName,\n              },\n              {\n                $el: 'div',\n                attrs: {\n                  class: '$twClasses.specimenGroup',\n                },\n                children: [\n                  ...((Array.isArray(schemaDefinition)\n                    ? schemaDefinition\n                    : [schemaDefinition]\n                  ).map((specimen) => {\n                    return {\n                      $el: 'div',\n                      attrs: {\n                        class: '$twClasses.specimen',\n                      },\n                      children: [specimen],\n                    }\n                  }) as FormKitSchemaNode[]),\n                ],\n              },\n            ],\n          })\n          return schemaDefinitions\n        },\n        [] as FormKitSchemaNode[]\n      )\n\n      return h(\n        KeepAlive,\n        {},\n        {\n          default: () => {\n            return activeTab.value === 'kitchen-sink'\n              ? h(FormKitSchema, { schema: schemaDefinitions, data: data })\n              : null\n          },\n        }\n      )\n    })\n\n    const formRenders = computed(() => {\n      return filteredFormNames\n        .map((form) => {\n          const schemaDefinition = schemas[form.id]\n          return h(\n            'div',\n            {\n              key: form.id,\n            },\n            activeTab.value === form.id\n              ? [\n                  h(\n                    'div',\n                    {\n                      class: classes.formContainer,\n                    },\n                    [\n                      h(FormKitSchema, {\n                        schema: schemaDefinition[0],\n                        data: data,\n                      }),\n                    ]\n                  ),\n                ]\n              : ''\n          )\n        })\n        .filter((form) => form.children)\n    })\n\n    const tabBar = computed(() => {\n      return h(\n        'div',\n        {\n          key: 'tab-bar',\n          class: classes.tabs,\n        },\n        tabs.map((tab) => {\n          return h(\n            'span',\n            {\n              class: classes.tab,\n              key: tab.id,\n              'data-tab': tab.id,\n              'data-active': activeTab.value === tab.id || undefined,\n              onClick: () => {\n                activeTab.value = tab.id\n              },\n            },\n            tab.name\n          )\n        })\n      )\n    })\n\n    const filterCheckboxes = computed(() => {\n      const createCheckboxSchema = (\n        inputGroup: Record<string, string | string[]>\n      ) => {\n        return {\n          $el: 'div',\n          attrs: {\n            class: '$twClasses.filterGroup',\n          },\n          children: [\n            {\n              $formkit: 'checkbox',\n              name: inputGroup.name,\n              label: inputGroup.label,\n              plugins: '$checkboxPlugins',\n              value: ['all'],\n              options: [\n                {\n                  label: 'All',\n                  value: 'all',\n                },\n                ...(Array.isArray(inputGroup.inputs) ? inputGroup.inputs : []),\n              ],\n            },\n          ],\n        }\n      }\n\n      // render each set of checkboxes\n      const filterSchema = h(FormKitSchema, {\n        key: 'filter-checkboxes',\n        data: data,\n        schema: {\n          $formkit: 'group',\n          id: 'filter-checkboxes',\n          children: [\n            {\n              $el: 'div',\n              attrs: {\n                class: '$twClasses.filterContainer',\n              },\n              children: Object.keys(inputCheckboxes.value).map((key) => {\n                const inputGroup = inputCheckboxes.value[key]\n                return createCheckboxSchema(inputGroup)\n              }),\n            },\n          ],\n        },\n      })\n\n      return h(\n        KeepAlive,\n        {},\n        {\n          default: () => {\n            if (\n              !(\n                tabs.find((tab) => tab.id === 'kitchen-sink') &&\n                activeTab.value === 'kitchen-sink'\n              )\n            ) {\n              return null\n            }\n            return filterSchema\n          },\n        }\n      )\n    })\n\n    return () => {\n      return h(\n        'div',\n        {\n          class: classes.container,\n        },\n        [\n          tabs.length > 1 ? tabBar.value : undefined,\n          filterCheckboxes.value,\n          ...formRenders.value,\n          kitchenSinkRenders.value,\n        ]\n      )\n    }\n  },\n})\n\nexport default FormKitKitchenSink\n", "import {\n  defineComponent,\n  PropType,\n  computed,\n  inject,\n  watch,\n  h,\n  Component,\n} from 'vue'\nimport { createSection } from '@formkit/inputs'\nimport {\n  FormKitNode,\n  FormKitSchemaNode,\n  FormKitSchemaCondition,\n} from '@formkit/core'\nimport { parentSymbol } from './FormKit'\nimport FormKitSchema from './FormKitSchema'\nimport { undefine } from '@formkit/utils'\n\n/**\n * @internal\n */\nconst messages = createSection('messages', () => ({\n  $el: 'ul',\n  if: '$fns.length($messages)',\n}))\n\n/**\n * @internal\n */\nconst message = createSection('message', () => ({\n  $el: 'li',\n  for: ['message', '$messages'],\n  attrs: {\n    key: '$message.key',\n    id: `$id + '-' + $message.key`,\n    'data-message-type': '$message.type',\n  },\n}))\n\n/**\n * The actual schema to render for the messages.\n */\nconst definition = messages(message('$message.value'))\n\n/**\n * Renders the messages for a parent node, or any node explicitly passed to it.\n * @public\n */\nexport const FormKitMessages = /* #__PURE__ */ defineComponent({\n  props: {\n    node: {\n      type: Object as PropType<FormKitNode> | undefined,\n      required: false,\n    },\n    sectionsSchema: {\n      type: Object as PropType<\n        Record<string, Partial<FormKitSchemaNode> | FormKitSchemaCondition>\n      >,\n      default: {},\n    },\n    defaultPosition: {\n      type: [String, Boolean] as PropType<\n        'true' | 'false' | boolean | undefined\n      >,\n      default: false,\n    },\n    library: {\n      type: Object as PropType<Record<string, Component>>,\n      default: () => ({}),\n    },\n  },\n  setup(props, context) {\n    const node = computed<FormKitNode | undefined>(() => {\n      return props.node || inject(parentSymbol, undefined)\n    })\n    watch(\n      node,\n      () => {\n        if (node.value?.context && !undefine(props.defaultPosition)) {\n          node.value.context.defaultMessagePlacement = false\n        }\n      },\n      { immediate: true }\n    )\n\n    const schema = definition(props.sectionsSchema || {})\n    const data = computed(() => {\n      return {\n        messages: node.value?.context?.messages || {},\n        fns: node.value?.context?.fns || {},\n        classes: node.value?.context?.classes || {},\n      }\n    })\n    return () =>\n      node.value?.context\n        ? h(\n            FormKitSchema,\n            { schema, data: data.value, library: props.library },\n            { ...context.slots }\n          )\n        : null\n  },\n})\n", "import { defineComponent, SetupContext } from 'vue'\nimport { FormKitOptions, createConfig } from '@formkit/core'\nimport { optionsSymbol, configSymbol } from './plugin'\nimport { provide, inject } from 'vue'\nimport { h } from 'vue'\nimport { Suspense } from 'vue'\nimport { getCurrentInstance } from 'vue'\nimport { ComponentInternalInstance } from 'vue'\nimport { VNode } from 'vue'\n\n/**\n * A composable to provide a given configuration to all children.\n * @param config - A FormKit configuration object or a function\n */\nexport function useConfig(\n  config?: FormKitOptions | ((...args: any[]) => FormKitOptions)\n) {\n  const options = Object.assign(\n    {\n      alias: 'FormKit',\n      schemaAlias: 'FormKitSchema',\n    },\n    typeof config === 'function' ? config() : config\n  )\n  /**\n   * The root configuration options.\n   */\n  const rootConfig = createConfig(options.config || {})\n  /**\n   * We dont want to explicitly provide any \"config\" options, only a root\n   * config option — so here we override the existing config options.\n   */\n  options.config = { rootConfig }\n  /**\n   * Provide the config to children.\n   */\n  provide(optionsSymbol, options)\n  /**\n   * Provide the root config to the children.\n   */\n  provide(configSymbol, rootConfig)\n  /**\n   * Register the FormKit component globally.\n   */\n  if (typeof window !== 'undefined') {\n    globalThis.__FORMKIT_CONFIGS__ = (\n      globalThis.__FORMKIT_CONFIGS__ || []\n    ).concat([rootConfig])\n  }\n}\n\nexport interface FormKitProviderProps {\n  config?: FormKitOptions | ((...args: any[]) => FormKitOptions)\n}\n\nexport interface ConfigLoaderProps {\n  defaultConfig?: boolean\n  configFile?: string\n}\n\n/**\n * The FormKitProvider component provides the FormKit config to the children.\n *\n * @public\n */\nexport const FormKitProvider = /* #__PURE__ */ defineComponent(\n  function FormKitProvider<\n    P extends FormKitProviderProps,\n    S extends { default: FormKitOptions }\n  >(props: P, { slots, attrs }: SetupContext<S>) {\n    const options: FormKitOptions = {}\n    if (props.config) {\n      useConfig(props.config)\n    }\n\n    return () =>\n      slots.default\n        ? slots.default(options).map((vnode) => {\n            return h(vnode, {\n              ...attrs,\n              ...vnode.props,\n            })\n          })\n        : null\n  },\n  { props: ['config'], name: 'FormKitProvider', inheritAttrs: false }\n)\n\n/**\n * The FormKitConfigLoader is an async component (meaning it needs a parent or\n * grandparent Suspense component to render) that loads the FormKit config and\n * provides it to the children.\n *\n * @internal\n */\nconst FormKitConfigLoader = /* #__PURE__ */ defineComponent(\n  async function FormKitConfigLoader(props: ConfigLoaderProps, context) {\n    let config = {}\n    if (props.configFile) {\n      const configFile = await import(\n        /*@__formkit.config.ts__*/ /* @vite-ignore */ /* webpackIgnore: true */ props.configFile\n      )\n      config = 'default' in configFile ? configFile.default : configFile\n    }\n    // Ensure this a factory function for runtimeConfig in nuxt.\n    if (typeof config === 'function') {\n      config = config()\n    }\n    /* @__default-config__ */\n    const useDefaultConfig = props.defaultConfig ?? true\n    if (useDefaultConfig) {\n      const { defaultConfig } = await import('./defaultConfig')\n      config = /* @__PURE__ */ defaultConfig(config)\n    }\n    /* @__default-config__ */\n    return () => h(FormKitProvider, { ...context.attrs, config }, context.slots)\n  },\n  {\n    props: ['defaultConfig', 'configFile'],\n    inheritAttrs: false,\n  }\n)\n\n/**\n * The FormKitLazyProvider component performs 2 HOC functions:\n *\n * 1. It checks if a FormKit config has already been provided, if it has it will\n *   render the children immediately.\n * 2. If a config has not been provided, it will render a Suspense component\n *    which will render the children once the config has been loaded by using\n *    the FormKitConfigLoader component.\n *\n * @public\n */\nexport const FormKitLazyProvider = /* #__PURE__ */ defineComponent(\n  function FormKitLazyProvider(\n    props: ConfigLoaderProps,\n    context: SetupContext<typeof Suspense>\n  ) {\n    const config = inject(optionsSymbol, null)\n    /* pass any attrs through */\n    const passthru = (vnode: VNode) => {\n      return h(vnode, {\n        ...context.attrs,\n        ...vnode.props,\n      })\n    }\n    if (config) {\n      // If there is already a config provided, render the children immediately.\n      return () =>\n        context.slots?.default ? context.slots.default().map(passthru) : null\n    }\n    const instance = getCurrentInstance() as ComponentInternalInstance & {\n      suspense?: boolean\n    }\n    if (instance.suspense) {\n      // If there is a suspense boundary already in place, we can render the\n      // config loader without another suspense boundary.\n      return () =>\n        h(FormKitConfigLoader, props, {\n          default: () =>\n            context.slots?.default\n              ? context.slots.default().map(passthru)\n              : null,\n        })\n    }\n    // If there is no suspense boundary, and no config, we render the suspense\n    // boundary and the config loader.\n    return () =>\n      h(Suspense, null, {\n        ...context.slots,\n        default: () =>\n          h(FormKitConfigLoader, { ...context.attrs, ...props }, context.slots),\n      })\n  },\n  {\n    props: ['defaultConfig', 'configFile'],\n    inheritAttrs: false,\n  }\n)\n", "import { getNode, watchRegistry, stopWatch } from '@formkit/core'\nimport type {\n  FormKitFrameworkContext,\n  FormKitGroupValue,\n  FormKitNode,\n} from '@formkit/core'\nimport { parentSymbol } from '../FormKit'\nimport { ref, inject, onUnmounted } from 'vue'\nimport type { Ref } from 'vue'\n\n/**\n * Uses the FormKit context to access the current FormKit context. This must be\n * used in a component that is a child of the FormKit component.\n * @param effect - An optional effect callback to run when the context is available.\n */\nexport function useFormKitContext<T = FormKitGroupValue>(\n  effect?: (context: FormKitFrameworkContext<T>) => void\n): Ref<FormKitFrameworkContext<T> | undefined>\n/**\n * Allows access to a specific context by address.\n * @param address - An optional address of the context to access.\n * @param effect - An optional effect callback to run when the context is available.\n */\nexport function useFormKitContext<T = FormKitGroupValue>(\n  address?: string,\n  effect?: (context: FormKitFrameworkContext<T>) => void\n): Ref<FormKitFrameworkContext<T> | undefined>\nexport function useFormKitContext<T = FormKitGroupValue>(\n  addressOrEffect?: string | ((context: FormKitFrameworkContext<T>) => void),\n  optionalEffect?: (context: FormKitFrameworkContext<T>) => void\n): Ref<FormKitFrameworkContext<T> | undefined> {\n  const address =\n    typeof addressOrEffect === 'string' ? addressOrEffect : undefined\n  const effect =\n    typeof addressOrEffect === 'function' ? addressOrEffect : optionalEffect\n  const context = ref<FormKitFrameworkContext<T> | undefined>()\n  const parentNode = inject(parentSymbol, null)\n  if (true && !parentNode) {\n    console.warn(\n      'useFormKitContext must be used as a child of a FormKit component.'\n    )\n  }\n  if (parentNode) {\n    if (address) {\n      context.value = parentNode.at(address)?.context\n      const root = parentNode.at('$root')\n      if (root) {\n        const receipt = root.on('child.deep', () => {\n          const targetNode = parentNode.at(address)\n          if (targetNode && targetNode.context !== context.value) {\n            context.value = targetNode.context as FormKitFrameworkContext<T>\n            if (effect) effect(context.value)\n          }\n        })\n        onUnmounted(() => {\n          root.off(receipt)\n        })\n      }\n    } else {\n      context.value = parentNode?.context\n    }\n  }\n  if (context.value && effect) effect(context.value)\n  return context\n}\n\n/**\n * Allows global access to a specific context by id. The target node MUST have\n * an explicitly defined id.\n * @param id - The id of the node to access the context for.\n * @param effect - An effect callback to run when the context is available.\n */\nexport function useFormKitContextById<T = any>(\n  id: string,\n  effect?: (context: FormKitFrameworkContext<T>) => void\n): Ref<FormKitFrameworkContext<T> | undefined> {\n  const context = ref<FormKitFrameworkContext<T> | undefined>()\n  const targetNode = getNode<T>(id)\n  if (targetNode)\n    context.value = targetNode.context as FormKitFrameworkContext<T>\n  if (!targetNode) {\n    const receipt = watchRegistry(id, ({ payload: node }) => {\n      if (node) {\n        context.value = node.context as FormKitFrameworkContext<T>\n        stopWatch(receipt)\n        if (effect) effect(context.value)\n      }\n    })\n  }\n  if (context.value && effect) effect(context.value)\n  return context\n}\n\n/**\n * Fetches a node by id and returns a ref to the node. The node in question\n * must have an explicitly assigned id prop. If the node is not available, the\n * ref will be undefined until the node is available.\n * @param id - The id of the node to access.\n * @param effect - An optional effect callback to run when the node is available.\n * @returns\n */\nexport function useFormKitNodeById<T>(\n  id: string,\n  effect?: (node: FormKitNode<T>) => void\n): Ref<FormKitNode<T> | undefined> {\n  const nodeRef = ref<FormKitNode<T> | undefined>()\n  const targetNode = getNode<T>(id)\n  if (targetNode) nodeRef.value = targetNode\n  if (!targetNode) {\n    const receipt = watchRegistry(id, ({ payload: node }) => {\n      if (node) {\n        nodeRef.value = node\n        stopWatch(receipt)\n        if (effect) effect(node)\n      }\n    })\n  }\n  if (nodeRef.value && effect) effect(nodeRef.value)\n  return nodeRef\n}\n", "import { defineComponent, PropType, computed, inject, h } from 'vue'\nimport { createSection } from '@formkit/inputs'\nimport { token } from '@formkit/utils'\nimport {\n  FormKitNode,\n  FormKitSchemaNode,\n  FormKitSchemaCondition,\n  FormKitFrameworkContext,\n} from '@formkit/core'\nimport { parentSymbol } from './FormKit'\nimport FormKitSchema from './FormKitSchema'\nimport { ref } from 'vue'\nimport { localize } from '@formkit/inputs'\nimport { nextTick } from 'vue'\n\nconst summary = createSection('summary', () => ({\n  $el: 'div',\n  attrs: {\n    'aria-live': 'polite',\n  },\n}))\n\nconst summaryInner = createSection('summaryInner', () => ({\n  $el: 'div',\n  if: '$summaries.length && $showSummaries',\n}))\n\n/**\n * @internal\n */\nconst messages = createSection('messages', () => ({\n  $el: 'ul',\n  if: '$summaries.length && $showSummaries',\n}))\n\n/**\n * @internal\n */\nconst message = createSection('message', () => ({\n  $el: 'li',\n  for: ['summary', '$summaries'],\n  attrs: {\n    key: '$summary.key',\n    'data-message-type': '$summary.type',\n  },\n}))\n\nconst summaryHeader = createSection('summaryHeader', () => ({\n  $el: 'h2',\n  attrs: {\n    id: '$id',\n  },\n}))\n\nconst messageLink = createSection('messageLink', () => ({\n  $el: 'a',\n  attrs: {\n    id: '$summary.key',\n    href: '$: \"#\" + $summary.id',\n    onClick: '$jumpLink',\n  },\n}))\n\n/**\n * The actual schema to render for the messages.\n */\nconst definition = summary(\n  summaryInner(\n    summaryHeader('$summaryHeader'),\n    messages(message(messageLink('$summary.message')))\n  )\n)\n\nexport interface FormKitSummaryMessage {\n  message: string\n  id: string\n  key: string\n  type: string\n}\n\n/**\n * Renders the messages for a parent node, or any node explicitly passed to it.\n * @public\n */\nexport const FormKitSummary = /* #__PURE__ */ defineComponent({\n  props: {\n    node: {\n      type: Object as PropType<FormKitNode> | undefined,\n      required: false,\n    },\n    forceShow: {\n      type: Boolean,\n      default: false,\n    },\n    sectionsSchema: {\n      type: Object as PropType<\n        Record<string, Partial<FormKitSchemaNode> | FormKitSchemaCondition>\n      >,\n      default: {},\n    },\n  },\n  emits: {\n    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\n    show: (_summaries: Array<FormKitSummaryMessage>) => true,\n  },\n  setup(props, context) {\n    const id = `summary-${token()}`\n    const node = computed<FormKitNode | undefined>(() => {\n      return props.node || inject(parentSymbol, undefined)\n    })\n\n    if (!node)\n      throw new Error(\n        'FormKitSummary must have a FormKit parent or use the node prop.'\n      )\n\n    const summaryContexts = ref<Array<FormKitFrameworkContext>>([])\n    const showSummaries = ref(false)\n    const summaries = computed((): Array<FormKitSummaryMessage> => {\n      const summarizedMessages: Array<FormKitSummaryMessage> = []\n      summaryContexts.value.forEach((context) => {\n        for (const idx in context.messages) {\n          const message = context.messages[idx]\n          if (typeof message.value !== 'string') continue\n          summarizedMessages.push({\n            message: message.value,\n            id: context.id,\n            key: `${context.id}-${message.key}`,\n            type: message.type,\n          })\n        }\n      })\n      return summarizedMessages\n    })\n\n    const addContexts = () => {\n      summaryContexts.value = []\n      node.value?.walk(\n        (child) => child.context && summaryContexts.value.push(child.context)\n      )\n    }\n\n    node.value?.on('submit-raw', async () => {\n      addContexts()\n      if (summaries.value.length === 0) return\n      context.emit('show', summaries.value)\n      showSummaries.value = true\n      await nextTick()\n      if (typeof window !== 'undefined') {\n        document.getElementById(id)?.scrollIntoView({ behavior: 'smooth' })\n        if (summaries.value[0]) {\n          document.getElementById(summaries.value[0].key)?.focus()\n        }\n      }\n    })\n    node.value?.on('child', addContexts)\n\n    function jumpLink(e: MouseEvent) {\n      if (e.target instanceof HTMLAnchorElement) {\n        e.preventDefault()\n        const id = e.target.getAttribute('href')?.substring(1)\n        if (id) {\n          document.getElementById(id)?.scrollIntoView({ behavior: 'smooth' })\n          document.getElementById(id)?.focus()\n        }\n      }\n    }\n\n    localize('summaryHeader', 'There were errors in your form.')(node.value!)\n\n    const schema = definition(props.sectionsSchema || {})\n\n    const data = computed(() => {\n      return {\n        id,\n        fns: node.value?.context?.fns || {},\n        classes: node.value?.context?.classes || {},\n        summaries: summaries.value,\n        showSummaries: props.forceShow || showSummaries.value,\n        summaryHeader: node.value?.context?.ui?.summaryHeader?.value || '',\n        jumpLink,\n      }\n    })\n    return () =>\n      node.value?.context\n        ? h(FormKitSchema, { schema, data: data.value }, { ...context.slots })\n        : null\n  },\n})\n", "import type { FormKitRootConfig } from '@formkit/core'\n/**\n * The official FormKit/Vue integration. This package is responsible for\n * integrating Vue with FormKit core and other first-party packages.\n *\n *\n * @packageDocumentation\n */\n\ndeclare global {\n  // eslint-disable-next-line no-var\n  var __FORMKIT_CONFIGS__: FormKitRootConfig[]\n}\n\n/**\n * The useInput composable.\n */\nexport { useInput } from './composables/useInput'\n\n/**\n * Shorthand for creating inputs with standard FormKit features.\n */\nexport { createInput } from './composables/createInput'\n\n/**\n * The defineFormKitConfig composable.\n */\nexport { defineFormKitConfig } from './composables/defineFormKitConfig'\n\n/**\n * The plugin and plugin types.\n */\nexport * from './plugin'\n\n/**\n * The root FormKit component.\n */\nexport {\n  default as FormKit,\n  FormKitComponent,\n  FormKitSetupContext,\n  Slots,\n  parentSymbol,\n  componentSymbol,\n  getCurrentSchemaNode,\n} from './FormKit'\n\n/**\n * The FormKitRoot wrapper component used to provide context to FormKit\n * about whether a FormKit input is booting in a Document or ShadowRoot.\n */\nexport { FormKitRoot, rootSymbol } from './FormKitRoot'\n\n/**\n * The FormKitKitchenSink component.\n */\nexport { FormKitKitchenSink } from './FormKitKitchenSink'\n\n/**\n * The FormKitMessages component.\n * @public\n */\nexport { FormKitMessages } from './FormKitMessages'\n\n/**\n * The FormKitProvider component.\n * @public\n */\nexport {\n  FormKitProvider,\n  FormKitLazyProvider,\n  useConfig,\n} from './FormKitProvider'\n\n/**\n * Exports the useFormKitContext composable.\n */\nexport {\n  useFormKitContext,\n  useFormKitContextById,\n  useFormKitNodeById,\n} from './composables/useContext'\n\n/**\n * The FormKitSummary component.\n * @public\n */\nexport { FormKitSummary, FormKitSummaryMessage } from './FormKitSummary'\n\n/**\n * The FormKitSchema component.\n */\nexport {\n  FormKitSchema,\n  Renderable,\n  RenderableList,\n  RenderableSlot,\n  RenderableSlots,\n  FormKitComponentLibrary,\n  VirtualNode,\n} from './FormKitSchema'\n\n/**\n * The default configuration.\n */\nexport {\n  defaultConfig,\n  DefaultConfigOptions,\n  PluginConfigs,\n} from './defaultConfig'\n\n/**\n * The vue specific FormKit core plugin. This is generally required for all\n * vue based FormKit configurations.\n */\nexport { default as bindings } from './bindings'\n\n/**\n * A vue component for rendering icons from the FormKit icon registry\n */\nexport { FormKitIcon } from './FormKitIcon'\n\n/**\n * The counter reset for sequential identifiers.\n */\nexport { resetCount } from './utilities/resetCount'\n\n/**\n * Export the reset count explicitly\n */\nexport {\n  errorHandler,\n  setErrors,\n  clearErrors,\n  submitForm,\n  reset,\n} from '@formkit/core'\n\n/**\n * Export the changeLocale function explicitly.\n */\nexport { changeLocale } from '@formkit/i18n'\n\n/**\n * SSR support for cleanup operations relating to SSR.\n */\nexport { ssrComplete, onSSRComplete } from './composables/onSSRComplete'\n", "import { h, ref, watch, defineComponent, inject, PropType } from 'vue'\nimport { optionsSymbol } from './plugin'\nimport { parentSymbol } from './FormKit'\nimport { FormKitPlugin } from '@formkit/core'\nimport { FormKitIconLoader, createIconHandler } from '@formkit/themes'\n\n/**\n * Renders an icon using the current IconLoader set at the root FormKit config\n *\n * @public\n */\nexport const FormKitIcon = /* #__PURE__ */ defineComponent({\n  name: 'FormKitIcon',\n  props: {\n    icon: {\n      type: String,\n      default: '',\n    },\n    iconLoader: {\n      type: Function as PropType<FormKitIconLoader>,\n      default: null,\n    },\n    iconLoaderUrl: {\n      type: Function as PropType<(iconName: string) => string>,\n      default: null,\n    },\n  },\n  setup(props) {\n    const icon = ref<undefined | string>(undefined)\n    const config = inject(optionsSymbol, {})\n    const parent = inject(parentSymbol, null)\n    let iconHandler: FormKitIconLoader | undefined = undefined\n\n    function loadIcon() {\n      if (!iconHandler || typeof iconHandler !== 'function') return\n      const iconOrPromise = iconHandler(props.icon)\n      if (iconOrPromise instanceof Promise) {\n        iconOrPromise.then((iconValue) => {\n          icon.value = iconValue\n        })\n      } else {\n        icon.value = iconOrPromise\n      }\n    }\n\n    if (props.iconLoader && typeof props.iconLoader === 'function') {\n      // if we have a locally supplied loader, then use it\n      iconHandler = createIconHandler(props.iconLoader)\n    } else if (parent && parent.props?.iconLoader) {\n      // otherwise try to inherit from a parent\n      iconHandler = createIconHandler(parent.props.iconLoader)\n    } else if (\n      props.iconLoaderUrl &&\n      typeof props.iconLoaderUrl === 'function'\n    ) {\n      iconHandler = createIconHandler(iconHandler, props.iconLoaderUrl)\n    } else {\n      // grab our iconHandler from the global config\n      const iconPlugin = config?.plugins?.find((plugin) => {\n        return (\n          typeof (plugin as FormKitPlugin & { iconHandler: FormKitIconLoader })\n            .iconHandler === 'function'\n        )\n      }) as (FormKitPlugin & { iconHandler: FormKitIconLoader }) | undefined\n      if (iconPlugin) {\n        iconHandler = iconPlugin.iconHandler\n      }\n    }\n\n    watch(\n      () => props.icon,\n      () => {\n        loadIcon()\n      },\n      { immediate: true }\n    )\n\n    return () => {\n      if (props.icon && icon.value) {\n        return h('span', {\n          class: 'formkit-icon',\n          innerHTML: icon.value,\n        })\n      }\n      return null\n    }\n  },\n})\n\nexport default FormKitIcon\n", "/**\n * Reset any counters in the inputs package.\n */\nimport { resetCounts } from '@formkit/inputs'\nimport { resetCount as coreResetCount } from '@formkit/core'\n\nexport function resetCount() {\n  resetCounts()\n  coreResetCount()\n}\n"],
  "mappings": "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",
  "names": ["format", "clean", "clean", "use", "has", "isObject", "wrapper", "merge", "receipts", "meta", "node", "error", "token", "messages", "message", "errors", "errors2", "emit", "options", "emit", "message", "resetValue", "extend", "getNode", "options", "init", "calm", "hydrate", "isObject", "definition", "defaults", "cloneAny", "props", "merge", "plugin", "run", "createConfig", "setIndex", "getNode", "matches", "fragment", "errors", "errors2", "message", "extend", "trap", "has", "symbol", "length", "depth", "char", "token", "provide", "receipts", "watch", "events", "res", "has", "date_between", "ends_with", "is", "length", "min", "matches", "eq", "empty", "removeMessage", "validation", "message", "node", "matches", "group", "hints", "date", "date", "min", "max", "registry", "fragment", "plugin", "options", "option", "extend", "warn", "has", "files", "file", "createMessage", "_a", "toggleChecked", "select", "selectInput", "isComponent", "list", "select2", "select", "text", "themePlugin", "_a", "_b", "icon", "error", "register", "warn", "computed", "ref", "watch", "markRaw", "__export", "isRef", "createMessage", "eq", "has", "camel", "undefine", "shallowClone", "reactive", "message", "messages", "classes", "node", "value", "definition", "_a", "defaultConfig", "options", "register", "extend", "h", "parseCondition", "isServer", "token", "library", "getValue", "fragment", "slotData", "schema", "instanceKey", "_b", "isBrowser", "defineComponent", "stopWatch", "error", "provide", "getCurrentInstance", "onMounted", "getNode", "initialProps", "watchEffect", "option", "form", "inputs", "defaultConfig2", "inject", "createSection", "messages2", "message2", "createConfig", "FormKitConfigLoader", "icon", "resetCount"]
}
